<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>汇编语言 | Redclay's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad: false});</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
  --theme-encrypt-confirm: '确认'
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>汇编语言</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-11-04T12:43:19.166Z" id="date"> 2023-11-04</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-12-02T10:39:03.919Z" id="updated"> 2023-12-02</time></div></span></div></div><hr><div id="post-content"><h3 id="汇编语言由以下三类组成"><a href="#汇编语言由以下三类组成" class="headerlink" title="汇编语言由以下三类组成:"></a>汇编语言由以下三类组成:</h3><p>1,汇编指令(机器码的助记符){核心:决定特性}<br>2,伪指令(由编译器执行)<br>3,其他符号(由编译器识别)</p>
<h3 id="CPU对储存器的读写"><a href="#CPU对储存器的读写" class="headerlink" title="CPU对储存器的读写:"></a>CPU对储存器的读写:</h3><p>1,地址信息<br>2,控制信息<br>3,数据信息</p>
<p>(1)汇编指令是机器指令的助记符,同机器指令一一对应。<br>(2)每一种CPU都有自己的汇编指令集。<br>(3)CPU可以直接使用的信息在存储器中存放。<br>(4)在存储器中指令和数据没有任何区別,都是二进制信息。</p>
<h3 id="CPU工作原理-寄存器"><a href="#CPU工作原理-寄存器" class="headerlink" title="CPU工作原理(寄存器)"></a>CPU工作原理(寄存器)</h3><p>bim源程序<br>汇编指令不区分大小写.</p>
<p>mov</p>
<p>我们前面讲到,8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址,送入地址加法器合成物理地址。这里,需要看一下,是什么部件提供段地址。段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器:CS、DS、SS、ES。当 8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址.</p>
<h3 id="8086CPU的工作过成"><a href="#8086CPU的工作过成" class="headerlink" title="8086CPU的工作过成"></a>8086CPU的工作过成</h3><p>从CS:IP指向内存单元读取指令,读取的指令进入指令缓冲区.<br>Debug是DOS,WINdows提供的实模式(8086)程序的调试工具.<br>用 Debug 的R 命令查看,改变CPU 寄存器的内容:<br>用 Debug 的 D 命令查看内存中的内容:<br>用 Debug 的E命令改写内存中的内容;<br>用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令:<br>用 Debug 的T命令执行一条机器指令:</p>
<h3 id="汇编语言寄存器-内存访问"><a href="#汇编语言寄存器-内存访问" class="headerlink" title="汇编语言寄存器(内存访问)"></a>汇编语言寄存器(内存访问)</h3><h3 id="内存中文字的储存"><a href="#内存中文字的储存" class="headerlink" title="内存中文字的储存"></a>内存中文字的储存</h3><p>任何两个地址连续的内存单元,N号 单元和N+1号单元,可以将它们看 成两个内存单元,也可以看成一个 地址为N的字单元中的高位字节单元 和低位字节单元。<br>CPU要读取一个内存单元的时候,必须 先给出这个内存单元的地址;<br>在8086PC中,内存地址由段地址和偏移 地址组成。<br>8086CPU中有一个RS寄存器,通常用来 存放要访问的数据的段地址。<br>mov al,[0]<br>已知的mov指令可完成的两种传送功能:<br>(1)将数据直接送入寄存器:<br>(2)将一个寄存器中的内容送入另一个寄存器中.<br>除此之外,mov 指令还可以将一个内存 单元中的内容送入一个寄存器。</p>
<p>mov bx,1000h<br>mov ds,bx<br>mov al,[0]</p>
<p>从哪个内存单元送到哪个寄存器中呢?<br>mov指令的格式:<br>mov 寄存器名,内存单元地址<br>“[…]”表示一个内存单元,“[…]”中的0表<br>示内存单元的偏移地址。<br>那么内存单元的段地址是多少呢?</p>
<p>想要在段寄存器中存储数据要通过通用寄存器.</p>
<h3 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h3><p>已学Mov指令的几种形式:<br>mou 寄存器,数据<br>mov 寄存器,寄存器<br>mov 寄存器,内存单元<br>mov 内存单元,寄存器<br>mov 段寄存器,寄存器<br>add 寄存器,数据<br>add 寄存器,寄存器<br>add 寄存器,内存单元<br>add 内存单元,寄存器<br>sub 寄存器,数据<br>sub 寄存器,寄存器<br>sub 寄存器,内存单元<br>sub 内存单元,寄存器 </p>
<h3 id="数据段和栈"><a href="#数据段和栈" class="headerlink" title="数据段和栈"></a>数据段和栈</h3><p>基本操作:入栈和出栈.<br>push入栈<br>pop出栈</p>
<p>换个角度看:<br>任意时刻,SS:SP指向栈顶元素,当栈为空的时 候,栈中没有元素,也就不存在栈顶元素<br>所以SS:SP只能指向栈的最底部单元下面的单元, 该单元的偏移地址为栈最底部的字单元的偏移地址+2<br>栈最底部字单元的地址为1000:000E,所以栈空时, SP&#x3D;0010H。</p>
<h3 id="push和pop指令的格式-2"><a href="#push和pop指令的格式-2" class="headerlink" title="push和pop指令的格式(2)"></a>push和pop指令的格式(2)</h3><p>Opush 段寄存器:将一个段寄存器中的<br>数据入栈<br>opop段寄存器:出栈,用一个段寄存器<br>接收出栈的数据<br>例如:push ds<br>pop es<br>用栈来暂存以 后需要恢复的寄存器中的内容时,出栈 的顺序要和入栈的顺序相反,因为最后 入栈的寄存器的内容在栈顶,所以在恢 复时,要最先出栈。<br>结论<br>push、pop实质上就是一种内存传送指令, 可以在寄存器和内存之间传送数据,与mov指令不同的是,push和pop指令访问的内存单元的地址不是在指令中给出的,而是由SS:SP指出的.</p>
<p>将一段内存当作栈段,仅仅是我们在编 程时的一种安排,CPU 并不会由于这种 安排,就在执行push、pop等栈操作指令 时就自动地将我们定义的栈段当作栈空 间来访问。</p>
<p>我们可以将一段内存定义为一个段,用 一个段地址指示段,用偏移地址访问段 内的单元。这完全是我们自己的安排。<br>1,我们可以用一个段存放数据,将它定义 为“数据段”;<br>2,我们可以用一个段存放代码,将它定义 为“代码段”;<br>3,我们可以用一个段当作栈,将它定义为 “栈段”;</p>
<h3 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h3><p>第一个标号指代了一个地址。<br>codesg:放在segment的前面,作为一个段的名称,这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p>
<h3 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h3><p>任务:编程运算 2^3。<br>定义一个段<br>实现处理任务<br>程序结束<br>段与段寄存器关联</p>
<h3 id="汇编程序"><a href="#汇编程序" class="headerlink" title="汇编程序"></a>汇编程序</h3><p>assume cs:abc<br>abc segment<br>mov ax,2<br>add ax,ax<br>add ax,ax<br>abc ends<br>end</p>
<h3 id="DOS是一个单任务操作系统。"><a href="#DOS是一个单任务操作系统。" class="headerlink" title="DOS是一个单任务操作系统。"></a>DOS是一个单任务操作系统。</h3><p>如一个程序P2在可执行文件中,则必须有一个正在运行的程序P1,将P2从可执行文件中加载入内存后,将CPU的控制权交给P2,P2才能得以运行。P2开始运行后,P1暂停运行.<br>而当P2运行完毕后,应该将CPU的控制权交还给使它得以运行的程序P1,此后,P1继续运行.<br>我们的程序没有像显示器输出任何信息程序只是做了一些将数据送入寄存器和加法的操作,而这些事情,我们不可能从显示屏上看出来。<br>程序执行完成后,返回,屏幕上再次出现操作系统的提示符。</p>
<h3 id="编译连和接的作用"><a href="#编译连和接的作用" class="headerlink" title="编译连和接的作用"></a>编译连和接的作用</h3><p>连接的作用有以下几个:<br>当源程序很大时,可以将它分为多个源程序文件来编译,每个源程序编译成为目标文件后,再用连接程序将它们连接到一起,生成一个可执行文件;<br>程序中调用了某个库文件中的子程序,需要将这个库文件和该程序生成的目标文件连接到一起,生成一个可执行文件;<br>一个源程序编译后,得到了存有机器码的目标文件,目标文件中的有些内容还不能直接用来生成可执行文件,连接程序将这此内容处理为最终的可执行信息。<br>所以,在只有一个源程序文件,而又不需要调用某个库中的子程序的情况下,也必须用连接程序对目标文件进行处理,生成可执行文件。<br>注意,对于连接的过程,可执行文件是我们要得到的最终结果。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>段地址和偏移地址是一种用来表示内存单元的物理地址的方法，它们由两个16位的二进制数组合而成，分别存放在段寄存器和通用寄存器中。段寄存器有6个，分别是CS（代码段寄存器），DS（数据段寄存器），ES（附加段寄存器），SS（堆栈段寄存器），FS（附加段寄存器），GS（附加段寄存器）。通用寄存器有8个，分别是AX（累加器），BX（基址寄存器），CX（计数器），DX（数据寄存器），SI（源变址寄存器），DI（目的变址寄存器），BP（基址指针寄存器），SP（堆栈指针寄存器）。段地址和偏移地址的组合方式有以下几种：</p>
<ul>
<li><p>段地址:偏移地址，例如CS:IP，表示代码段寄存器中的值作为段地址，指令指针寄存器中的值作为偏移地址，用来指向下一条要执行的指令的物理地址。</p>
</li>
<li><p>段寄存器:[通用寄存器]，例如DS:[BX]，表示数据段寄存器中的值作为段地址，基址寄存器中的值作为偏移地址，用来指向一个数据的物理地址。</p>
</li>
<li><p>段寄存器:[通用寄存器+常数]，例如ES:[DI+10]，表示附加段寄存器中的值作为段地址，目的变址寄存器中的值加上一个常数作为偏移地址，用来指向一个数据的物理地址。</p>
</li>
<li><p>段寄存器:[通用寄存器+通用寄存器]，例如SS:[BP+SI]，表示堆栈段寄存器中的值作为段地址，基址指针寄存器中的值加上源变址寄存器中的值作为偏移地址，用来指向一个数据的物理地址。</p>
</li>
</ul>
<h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统,都要提供一个称shell (外壳)的程序,用戶(操作人员)使用这个程序来操作计算机系统互作。<br>DOS中有一个程序command.com,这个程序在 DOS 中称为命令解释器,也就是DOS系统的shell。<br>程序加载后,ds中存放着程序所在内存区的 段地址,这个内存区的偏移地址为0,则程序所在的内存区的地址为:ds:0;<br>这个内存区的前256个字节中存放的是PSP,dos用来和程序进行通信。从256字节处向后的空间存放的是程序.<br>总结(续)<br>所以,我们从ds中可以得到PSP的段地址SA,PSP的偏移地址为0,则物理地址为SA×16+0。<br>因为PSP占256(100H)字节,所以程序的物理地址是:<br>SAX16+0+256&#x3D;SA×16+16×16&#x3D;(SA+16) ×16+0<br>可用段地址和偏移地址表示为:SA+10:0。<br>﻿需要注意的是,在DOS中运行程序时,是command将程序加载入内存;<br>所以程序运行结束后返回到command中,而在这里是debug将程序加载入内存,所以程序运行结束后要返回到Debug中。<br>我们在DOS中用“Debug 1.exe”运行Debug对1.exe进行跟踪时,程序加载的顺序是:command加载Debug,Debug加载1.exe。<br>返回的顺序是:从l.exe中的程序返回到Debug,从Debug返回到command。</p>
<h3 id="汇编语言常见指令"><a href="#汇编语言常见指令" class="headerlink" title="汇编语言常见指令"></a>汇编语言常见指令</h3><h3 id="加"><a href="#加" class="headerlink" title="加"></a>加</h3><p>汇编语言中的 <code>add</code> 指令用于将两个操作数相加，并将结果存储在目标操作数中。<code>add</code> 指令的语法如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">add 目标, 源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里，<code>目标</code> 是将存储加法结果的操作数，<code>源</code> 是将与目标操作数相加的操作数。<code>目标</code> 和 <code>源</code> 可以是寄存器或内存位置。</p>
<h3 id="减"><a href="#减" class="headerlink" title="减"></a>减</h3><p>汇编语言中的 <code>sub</code> 指令用于从目标操作数中减去源操作数，并将结果存储在目标操作数中。<code>sub</code> 指令的语法如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sub 目标, 源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里，<code>目标</code> 是将存储减法结果的操作数，<code>源</code> 是将从目标操作数中减去的操作数。<code>目标</code> 和 <code>源</code> 可以是寄存器或内存位置.</p>
<h3 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h3><p>汇编语言中的 <code>mul</code> 指令用于执行无符号乘法运算。<code>mul</code> 指令的语法如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mul 源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里，<code>源</code> 是与累加器（<code>AX</code>，<code>EAX</code> 或 <code>RAX</code>，取决于操作数的大小）一起进行乘法运算的操作数。结果将存储在 <code>DX:AX</code>，<code>EDX:EAX</code> 或 <code>RDX:RAX</code> 中，取决于操作数的大小。<br>例如，以下代码将 <code>eax</code> 寄存器中的值与 <code>ebx</code> 寄存器中的值相乘，并将结果存储在 <code>edx:eax</code> 中：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, ebx
mul ecx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在这个例子中，<code>eax</code> 中的值与 <code>ecx</code> 中的值相乘，结果存储在 <code>edx:eax</code> 中。</p>
<h3 id="除"><a href="#除" class="headerlink" title="除"></a>除</h3><p>汇编语言中的 <code>div</code> 指令用于执行无符号除法运算。<code>div</code> 指令的语法如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">div 源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里，<code>源</code> 是作为除数的操作数。被除数是累加器（<code>AX</code>，<code>EAX</code> 或 <code>RAX</code>，取决于操作数的大小）或 <code>DX:AX</code>，<code>EDX:EAX</code> 或 <code>RDX:RAX</code>，取决于操作数的大小。商将存储在累加器中，余数将存储在 <code>DX</code>，<code>EDX</code> 或 <code>RDX</code> 中。<br>例如，以下代码将 <code>eax</code> 寄存器中的值除以 <code>ebx</code> 寄存器中的值，并将商存储在 <code>eax</code> 中，余数存储在 <code>edx</code> 中：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, ebx
div ecx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在这个例子中，<code>eax</code> 中的值除以 <code>ecx</code> 中的值，商存储在 <code>eax</code> 中，余数存储在 <code>edx</code> 中。</p>
<p>除了 <code>div</code> 指令，汇编语言还有一个用于执行带符号除法的 <code>idiv</code> 指令。<code>idiv</code> 指令的语法如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">idiv 源<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里，<code>源</code> 是作为除数的操作数。被除数是累加器（<code>AX</code>，<code>EAX</code> 或 <code>RAX</code>，取决于操作数的大小）或 <code>DX:AX</code>，<code>EDX:EAX</code> 或 <code>RDX:RAX</code>，取决于操作数的大小。商将存储在累加器中，余数将存储在 <code>DX</code>，<code>EDX</code> 或 <code>RDX</code> 中。<br>例如，以下代码将 <code>eax</code> 寄存器中的值除以 <code>ebx</code> 寄存器中的值，并将商存储在 <code>eax</code> 中，余数存储在 <code>edx</code> 中：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, ebx
idiv ecx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在这个例子中，<code>eax</code> 中的值除以 <code>ecx</code> 中的值，商存储在 <code>eax</code> 中，余数存储在 <code>edx</code> 中。<br><code>idiv</code> 指令与 <code>div</code> 指令的主要区别在于，<code>idiv</code> 执行的是带符号的除法，而 <code>div</code> 执行的是无符号的除法。</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p><code>JMP</code>  ;无条件跳转</p>
<p><code>JE</code>   ;&#x2F;&#x2F;等于则跳转			同JZ<br><code>JNE</code>  ;&#x2F;&#x2F;不等于则跳转		同JNZ<br><code>JA</code>   ;&#x2F;&#x2F;无符号大于则跳转<br><code>JNA</code>  ;&#x2F;&#x2F;无符号不大于则跳转<br><code>JAE</code>  ;&#x2F;&#x2F;无符号大于等于则跳转		同JNB<br><code>JNAE</code> ;&#x2F;&#x2F;无符号不大于等于则跳转	同JB<br><code>JB</code>   ;&#x2F;&#x2F;无符号小于则跳转<br><code>JNB</code>  ;&#x2F;&#x2F;无符号不小于则跳转<br><code>JBE</code>  ;&#x2F;&#x2F;无符号小于则跳转		同JNA<br><code>JNBE</code> ;&#x2F;&#x2F;无符号不小于等于则跳转	同JA<br><code>JG</code>   ;&#x2F;&#x2F;有符号大于则跳转<br><code>JNG</code>  ;&#x2F;&#x2F;有符号不大于则跳转<br><code>JGE</code>  ;&#x2F;&#x2F;有符号大于等于则跳转		同JNL<br><code>JNGE</code> ;&#x2F;&#x2F;有符号不大于等于则跳转	同JL<br><code>JL</code>   ;&#x2F;&#x2F;有符号小于则跳转<br><code>JNL</code>  ;&#x2F;&#x2F;有符号不小于则跳转<br><code>JLE</code>  ;&#x2F;&#x2F;有符号小于等于则跳转		同JNG<br><code>JNLE</code> ;&#x2F;&#x2F;有符号不小于等于则跳转	同JG<br><code>JZ</code>   ;&#x2F;&#x2F;为零则跳转<br><code>JNZ</code>  ;&#x2F;&#x2F;不为零则跳转<br><code>JS</code>   ;&#x2F;&#x2F;为负则跳转<br><code>JNS</code>  ;&#x2F;&#x2F;不为负则跳转<br><code>JC</code>   ;&#x2F;&#x2F;进位则跳转<br><code>JNC</code>  ;&#x2F;&#x2F;不进位则跳转<br><code>JO</code>   ;&#x2F;&#x2F;溢出则跳转<br><code>JNO</code>  ;&#x2F;&#x2F;不溢出则跳转<br><code>JP</code>   ;&#x2F;&#x2F;为偶则跳转<br><code>JNP</code>  ;&#x2F;&#x2F;不为偶则跳转<br><code>JPE</code>  ;&#x2F;&#x2F;奇偶位置位则跳转		同JP<br><code>JPO</code>  ;&#x2F;&#x2F;奇偶位复位则跳转		同JNP</p>
<h3 id="Test指令"><a href="#Test指令" class="headerlink" title="Test指令"></a>Test指令</h3><p><code>test</code>指令用于两个操作数的按位<code>AND</code>运算，并根据结果设置标志寄存器，结果本身不会写回到目的操作数。<br>(1) AND 运算结果为0时， ZF(zero flag)置位<br>(2) test可以影响CF，OF，PF，SF，ZF标志位<br>(3) 两个操作数相等,同时为0时,AND 结果为0,此时ZF置位。<br>例如test和je的连用</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">Test eax,eax
je some_address<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="mov系列指令"><a href="#mov系列指令" class="headerlink" title="mov系列指令"></a>mov系列指令</h3><p>MOVSX说明:带符号扩展传送指令<br>符号扩展的意思是,当计算机存储某一个有符号数时,符号位位于该数的第一位,所以，当扩展一个负数的时候需要将扩展的高位全赋为1.对于正数而言，符号扩展和零扩展MOVZX是一样的，将扩展的高位全赋为0.</p>
<p>MOVZX功能:<br>将8位或16位的OPS零扩展为16位或32位,在传给OPD.<br>格式:</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">MOVZX OPD,OPS<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>说明:<br>所谓零扩展,就是把新扩展的高位字节填0,这可以保证无符号数扩展后还是原来的无符号数.<br>至于什么时候用符号扩展,什么时候用零扩展,视程序中是用带符号数还是无符 号数操作而定.<br>样列：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movzx edi,bx		; movzx 扩展高位为0，并把其赋值到edi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2>movsb movsw movsd 指令详解</h2>
这三个指令，都是数据传送指令,都是从源地址向目的地址传送数据。
16位模式下:
源地址是`DS:SI`,目的地址是`ES:DI`  
32位模式下:  
源地址是`DS:ESI`,目的地址是`ES:EDI`
注意:在传送完成之后，`SI`和`DI`(或者`ESI`和`EDI`)会增加或者减小.
当`DF`=0时，表示正向传送，传送之后`SI`和`DI`(或者`ESI`和`EDI`)的值会增加;
当`DF`=1时，表示反向传送，传送之后`SI`和`DI`(或者`ESI`和`EDI`)的值会减小;
区别:
`MOVSB`:传送一个字节，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`1`.
`MOVSW`:传送一个字，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`2`.
`MOVSD`:传送一个双字，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`4`.
单纯的`movsb/ movsw/ movsd`只能执行一次，如果希望处理器自动地反复执行，可以加上指令前缀`rep`;在寄存器`CX`（16位模式）或者`ECX`（32位模式）中设置传送的次数。当`CX`/`ECX`不等于0时，则执行`movsb/ movsw/ movsd`,执行后，`CX`/`ECX`的值减一，直到减为0为止.

<h3 id="rep-stosd循环"><a href="#rep-stosd循环" class="headerlink" title="rep stosd循环"></a>rep stosd循环</h3><p>从<code>lea edi</code>,<code>EBP+arg_0</code>开始,到rep stosd结束.EDI中存入的是循环操作的起始地址,ECX存入的是循环次数,EAX是循环填入的值.这一段的操作就是从<code>EBP+var_40</code>处开始,循环十次,向下依次填入CCCCCCCC,写入的长度由EAX决定,32位.</p>
<h3 id="lea指令"><a href="#lea指令" class="headerlink" title="lea指令"></a>lea指令</h3><p>lea eax，addr<br>就是将表达式addr的值放入eax寄存器，示例如下：<br>lea eax,401000h; 将值401000h写入eax寄存器中<br>lea指令右边的操作数表示一个精指针，上述指令和mov eax，401000h是等价的<br>2、lea eax，dword ptr ebx;将ebx的值赋值给eax<br>3、lea eax，c；其中c为一个int型的变量，该条语句的意思是把c的地址赋值给eax；</p>
<p>在汇编语言中，<code>db</code> 不是寄存器，而是一种伪操作命令。<code>db</code>是 “define byte” 的缩写，它用于定义一个或多个字节的数据。<code>db</code> 指令后面可以跟一个或多个逗号分隔的数字、字符或符号，每个数字、字符或符号都会被汇编器转化为一个字节的机器码，并存储在指令地址后的内存中。例如，在代码 <code>string db &#39;Hello,World!$&#39;</code> 中，<code>db</code> 定义了一个名为 <code>string</code> 的字符串，其中每个字符都被转化为一个字节的机器码。这是汇编语言中的一种基本操作，用于在内存中存储数据。请注意，尽管 <code>db</code> 可以用于定义数据，但它本身并不是寄存器。寄存器是 CPU 中的一种特殊类型的存储器，用于存储正在处理的数据和指令。在汇编语言中，寄存器通常由特定的名称或代码来表示，如 <code>ax</code>、<code>bx</code>、<code>cx</code>、<code>dx</code> 等。每种寄存器都有其特定的用途和功能。例如，<code>ax</code> 寄存器通常用于存储算术和逻辑操作的结果。总的来说，<code>db</code> 和寄存器是两种不同的概念，各自在汇编语言中扮演着不同的角色.</p>
<h3 id="DOS功能的调用"><a href="#DOS功能的调用" class="headerlink" title="DOS功能的调用"></a>DOS功能的调用</h3><p>以下是一些常用的DOS功能调用:<br><strong>1号功能调用</strong>：键盘输入并显示<br><strong>2号功能调用</strong>：屏幕显示一个字符<br><strong>5号功能调用</strong>：打印输出<br><strong>6号功能调用</strong>：直接输入、输出单字符<br><strong>8号功能调用</strong>：键盘输入但不显示输入字符<br><strong>9号功能调用</strong>：屏幕显示字符串<br><strong>0AH号功能调用</strong>：字符串输入<br><strong>4CH号功能调用</strong>：返回DOS操作系统</p>
<p>在汇编语言中，我们可以通过软中断（<code>int</code>）指令来调用DOS功能。软中断是一种特殊的指令，它可以触发中断处理程序的执行。在DOS中，我们通常使用<code>int 21h</code>来调用DOS功能。</p>
<p>在调用DOS功能之前，我们需要先将功能号存储到<code>ah</code>寄存器中。例如，如果我们想要调用9号功能（显示字符串），我们可以先将9存储到<code>ah</code>寄存器中。然后，我们可以通过<code>int 21h</code>指令来调用这个功能。</p>
<p>以下是一个示例，展示了如何在汇编语言中调用DOS功能：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">data segment ;数据段
string db &#39;Hello,World!$&#39; ;定义一个名为string的字符串
data ends

code segment ;代码段
assume cs:code,ds:data

start:
mov ax,data ;获取段基址
mov ds,ax ;将段基址送入寄存器
mov dx,offset string ;获取string的偏移地址
mov ah,9 ;调用9号DOS功能（显示字符串）
int 21h ;中断指令，调用用户程序，执行ah中设置的09h号功能
mov ah,4ch ;功能号4ch表示从用户程序返回操作系统，结束程序
int 21h ;中断指令，调用用户程序，执行ah中设置的4ch号功能

code ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个示例中，我们首先将数据段的基址和<code>string</code>的偏移地址加载到寄存器中。然后，我们将9（显示字符串的功能号）存储到<code>ah</code>寄存器中，并通过<code>int 21h</code>指令来调用这个功能。最后，我们将4ch（结束程序的功能号）存储到<code>ah</code>寄存器中，并通过<code>int 21h</code>指令来调用这个功能。这就是在汇编语言中调用DOS功能的基本步骤。</p>
<h2>int 21h原理</h2>
在汇编语言中，INT 21H是一条中断指令，用于调用DOS操作系统的功能。这条指令的作用是将寄存器AH中的值作为参数传递给DOS操作系统的中断服务程序，从而实现对DOS功能的调用。
在DOS中，AH寄存器的不同取值对应不同的功能。例如，AH=01H表示在屏幕上输出一个字符，AH=02H表示在屏幕上输出一个字符串等。
调用DOS功能的过程通常包括以下步骤：
将系统功能号送到寄存器AH中；
将入口参数送到指定的寄存器中；
用INT 21H指令执行功能调用；
根据出口参数分析功能调用执行情况。
例如，如果我们想要在显示器上显示一个字符串，我们可以使用以下指令：
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">MOV AH,09H
INT 21H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
在这个例子中，我们首先将09（显示字符串的功能号）存储到AH寄存器中，然后通过INT 21H指令来调用这个功能。这就是在汇编语言中调用DOS功能的基本步骤。

<p>在一次INT 21H指令调用中，AH寄存器只能存储一个功能号。这是因为AH寄存器的大小为8位，也就是一个字节。每个功能号都对应一个唯一的8位二进制数，因此AH寄存器一次只能存储一个功能号。<br>如果你想要调用多个DOS功能，你需要分别进行多次INT 21H指令调用。每次调用前，你需要将相应的功能号存储到AH寄存器中，然后执行INT 21H指令。<br>例如，如果你首先想要显示一个字符串（功能号为09H），然后结束程序（功能号为4CH），你可以使用以下指令：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">MOV AH,09H
INT 21H
MOV AH,4CH
INT 21H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中，我们首先将09（显示字符串的功能号）存储到AH寄存器中，然后通过INT 21H指令来调用这个功能。然后，我们将4CH（结束程序的功能号）存储到AH寄存器中，并通过INT 21H指令来调用这个功能。这就是在汇编语言中调用多个DOS功能的基本步骤。</p>
<h2>多次调用DOS功能</h2>
在汇编语言中，如果你想要多次使用DOS功能，你可以在代码中多次调用INT 21H指令。每次调用前，你需要将相应的功能号存储到AH寄存器中。
以下是一个示例，展示了如何在汇编语言中多次调用DOS功能：
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">data segment ;数据段
string1 db &#39;Hello,World!$&#39; ;定义一个名为string1的字符串
string2 db &#39;Goodbye,World!$&#39; ;定义一个名为string2的字符串
data ends

code segment ;代码段
assume cs:code,ds:data

start:
mov ax,data ;获取段基址
mov ds,ax ;将段基址送入寄存器

mov dx,offset string1 ;获取string1的偏移地址
mov ah,9 ;调用9号DOS功能（显示字符串）
int 21h ;中断指令，调用用户程序，执行ah中设置的09h号功能

mov dx,offset string2 ;获取string2的偏移地址
mov ah,9 ;调用9号DOS功能（显示字符串）
int 21h ;中断指令，调用用户程序，执行ah中设置的09h号功能

mov ah,4ch ;功能号4ch表示从用户程序返回操作系统，结束程序
int 21h ;中断指令，调用用户程序，执行ah中设置的4ch号功能

code ends
end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
在这个示例中，我们首先将数据段的基址加载到寄存器中。然后，我们将string1和string2的偏移地址分别加载到寄存器中，并分别调用9号功能（显示字符串）。最后，我们调用4CH号功能（结束程序）。这就是在汇编语言中多次调用DOS功能的基本步骤。

<h3 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h3><p>花指令：目的是干扰ida和od等软件对程序的静态分析。使这些软件无法正常反汇编出原始代码。</p>
<p>常用的两类反汇编算法：<br>1.线性扫描算法:逐行反汇编（无法将数据和内容进行区分）<br>2.递归行进算法:按照代码可能的执行顺序进行反汇编程序。</p>
<p>call指令：将下一条指令地址压入栈，再跳转执行<br>ret指令：将保存的地址取出，跳转执行</p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>操作数的地址可以直接给出，也可以通过寄存器或内存中的值计算出来。汇编语言的寻址操作有以下几种：</p>
<p><strong>立即寻址</strong>：操作数直接包含在指令中，紧跟在操作码之后的寻址方式称为立即寻址方式，把该操作数称为立即数。例如，mov ax, 1234h就是一个立即寻址的例子，其中1234h是一个立即数。<br><strong>寄存器寻址</strong>：操作数直接包含在寄存器中，由指令指定寄存器号的寻址方式。例如，mov ax, bx就是一个寄存器寻址的例子，其中ax和bx都是寄存器。<br>直接寻址：操作数的有效地址直接包含在指令中的寻址方式。有效地址存放在代码段的指令操作码之后，但操作数本身在存储器中，所以必须先求出操作数的物理地址。这种寻址方式常用于存取简单变量。例如，mov ax, [1000h]就是一个直接寻址的例子，其中1000h是一个有效地址。<br><strong>寄存器间接寻址</strong>：操作数的有效地址存放在一个寄存器中，由指令指定该寄存器的寻址方式。例如，mov ax, [bx]就是一个寄存器间接寻址的例子，其中bx是一个寄存器，存放了操作数的有效地址。<br><strong>寄存器相对寻址</strong>：操作数的有效地址由一个寄存器中的值加上一个偏移量得到的寻址方式。例如，mov ax, [bx+10h]就是一个寄存器相对寻址的例子，其中bx是一个寄存器，10h是一个偏移量，它们相加得到操作数的有效地址。<br><strong>基址变址寻址</strong>：操作数的有效地址由两个寄存器中的值相加得到的寻址方式。例如，mov ax, [bx+si]就是一个基址变址寻址的例子，其中bx和si都是寄存器，它们相加得到操作数的有效地址。<br><strong>相对基址变址寻址</strong>：操作数的有效地址由两个寄存器中的值相加再加上一个偏移量得到的寻址方式。例如，mov ax, [bx+si+10h]就是一个相对基址变址寻址的例子，其中bx和si都是寄存器，10h是一个偏移量，它们相加得到操作数的有效地址。</p>
<h3 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h3><p>inc自增指令<br>dec自减指令<br>这两个命令只有一个操作位.</p>
<h3 id="逻辑位移"><a href="#逻辑位移" class="headerlink" title="逻辑位移"></a>逻辑位移</h3><p>shl是<strong>逻辑左移指令</strong>,将目的操作数的每位左移,使用源操作数决定要位移的数目.最高位复制到进位标志中,最低位以0填充(与sal相同).<br>shr是<strong>右移指令</strong>,将目的操作数中的每一位右移,使用源操作数决定移位的数目.最高位以0填充,最低位复制到进位标志中.<br>sal是<strong>算数左移</strong>,将目的操作数中的每一位左移,源操作数决定移位的数目.最高位复制到标志位中,最低位以0填充.<br>sar是<strong>算数右移</strong>,将目的操作数中的每一位右移,源操作数决定位移数目,最低为复制到进位标志中,最高位保持原值.sar指令通常用于有符号数操作.<br>cdq是<strong>双字节扩展到8字节</strong>.</p>
<h3 id="汇编语言指令的一些区别"><a href="#汇编语言指令的一些区别" class="headerlink" title="汇编语言指令的一些区别"></a>汇编语言指令的一些区别</h3><p>复杂指令集计算机（CISC）： CISC架构的主要特点是其指令集的复杂性。这些指令集包含许多不同的指令，每个指令都有不同的长度和复杂的操作。CISC架构的目标是通过减少程序中的指令数量来提高效率。这是通过创建可以执行多个低级操作的复杂指令来实现的。例如，Intel的x86架构就是CISC的一个例子。</p>
<p>精简指令集计算机（RISC）： 与CISC相反，RISC架构的目标是简化指令集。RISC处理器的每个指令通常只执行一个低级操作，如加载存储器，执行算术操作，或者跳转到新的代码位置。这意味着在RISC架构中，执行同样的任务可能需要更多的指令，但每个指令的执行速度更快。ARM和MIPS架构就是RISC的例子。</p>
<p><code>MOV</code>：这是最常见的传送指令，用于将源操作数的值复制到目标操作数。例如，<code>MOV AX, 10</code> 将值 10 复制到寄存器 AX。<br><code>PUSH</code> 和 <code>POP</code>：这两个指令用于向堆栈推送和弹出数据。例如，<code>PUSH AX</code> 将 AX 寄存器的内容推送到堆栈，而 <code>POP AX</code> 将堆栈顶部的值弹出到 AX 寄存器。<br><code>LEA</code>：Load Effective Address 指令用于将有效地址加载到寄存器。例如，<code>LEA AX, [BX+SI]</code> 将 BX 寄存器和 SI 寄存器的和加载到 AX 寄存器。<br><code>XCHG</code>：Exchange 指令用于交换两个操作数的值。例如，<code>XCHG AX, BX</code> 将 AX 和 BX 寄存器的值交换。<br>正在为你生成答案…</p>
<p>在汇编语言中，标志寄存器用于存储和反映 CPU 的状态信息。以下是一些常见的标志位：</p>
<p>**零标志 (ZF)**：当算术或逻辑操作的结果为零时，该标志被设置。</p>
<p>**符号标志 (SF)**：当算术或逻辑操作的结果为负时，该标志被设置。  </p>
<p>**进位标志 (CF)**：当算术操作导致进位或借位时，该标志被设置。</p>
<p>**溢出标志 (OF)**：当算术操作导致正溢出或负溢出时，该标志被设置。</p>
<p>**奇偶标志 (PF)**：当算术或逻辑操作的结果中 1 的个数为偶数时，该标志被设置。</p>
<p>**辅助进位标志 (AF)**：当算术操作导致四位二进制码的进位或借位时，该标志被设置。</p>
<p>**方向标志 (DF)**：该标志用于字符串操作。当 DF 为 0 时，字符串操作从低地址向高地址进行；当 DF 为 1 时，字符串操作从高地址向低地址进行。</p>
<p>**中断标志 (IF)**：当该标志被设置时，CPU 将响应外部中断；当该标志被清除时，CPU 将忽略外部中断。</p>
<p>**陷阱标志 (TF)**：当该标志被设置时，CPU 将在执行每条指令后产生一个中断，通常用于调试。   </p>
<p>这些标志位通常在特定的操作中使用，例如字符串操作、中断处理和调试等</p>
<p>这些标志位通常在条件跳转或循环指令中使用，例如 <code>JZ</code>（Jump if Zero）、<code>JNZ</code>（Jump if Not Zero）、<code>JC</code>（Jump if Carry）、<code>JNC</code>（Jump if Not Carry）等<br>在x86平台中，标志寄存器被称为<strong>EFLAGS</strong>寄存器。这是一个32位的寄存器，包含了一些用于反映CPU状态的标志位。以下是一些主要的标志位：</p>
<p>**进位标志 (CF)**：位0，当算术操作导致进位或借位时，该标志被设置。</p>
<p>**奇偶标志 (PF)**：位2，当算术或逻辑操作的结果中 1 的个数为偶数时，该标志被设置。</p>
<p>**辅助进位标志 (AF)**：位4，当算术操作导致四位二进制码的进位或借位时，该标志被设置。</p>
<p>**零标志 (ZF)**：位6，当算术或逻辑操作的结果为零时，该标志被设置。</p>
<p>**符号标志 (SF)**：位7，当算术或逻辑操作的结果为负时，该标志被设置。</p>
<p>**陷阱标志 (TF)**：位8，当该标志被设置时，CPU 将在执行每条指令后产生一个中断，通常用于调试。</p>
<p>**中断标志 (IF)**：位9，当该标志被设置时，CPU 将响应外部中断；当该标志被清除时，CPU 将忽略外部中断。</p>
<p>**方向标志 (DF)**：位10，该标志用于字符串操作。当 DF 为 0 时，字符串操作从低地址向高地址进行；当 DF 为 1 时，字符串操作从高地址向低地址进行。</p>
<p>**溢出标志 (OF)**：位11，当算术操作导致正溢出或负溢出时，该标志被设置。  </p>
<p>此外，EFLAGS 寄存器还包含一些其他的标志位，如系统标志、I&#x2F;O特权级别等，这些通常用于操作系统或高级语言编程，对于汇编语言编程来说，我们通常只需要关注上述的那些标志位<br>在64位的x86平台中，标志寄存器被称为<strong>RFLAGS</strong>寄存器。这是一个64位的寄存器，但实际上，只有低32位被使用，高32位保留未用。</p>
<p>RFLAGS寄存器包含了EFLAGS寄存器中的所有标志位，如进位标志（CF）、奇偶标志（PF）、辅助进位标志（AF）、零标志（ZF）、符号标志（SF）、陷阱标志（TF）、中断标志（IF）、方向标志（DF）和溢出标志（OF）等。</p>
<p>此外，RFLAGS寄存器还包含一些其他的标志位，如系统标志、I&#x2F;O特权级别等，这些通常用于操作系统或高级语言编程，对于汇编语言编程来说，我们通常只需要关注上述的那些标志位。</p>
<h3 id="intel和AT-T的区别"><a href="#intel和AT-T的区别" class="headerlink" title="intel和AT&amp;T的区别"></a>intel和AT&amp;T的区别</h3><p>Intel汇编和AT&amp;T汇编是两种不同的汇编语言格式，它们在语法和表示方式上有一些主要的区别：<br>前缀：在AT&amp;T语法中，寄存器的前缀是“%”，立即数的前缀是“$”。而在Intel语法中，没有寄存器前缀或立即前缀。<br>操作数的位置：在Intel语法中，第一个操作数是目标，第二个操作数是源。而在AT&amp;T语法中，第一个操作数是源，第二个操作数是目标。<br>内存操作数的写法：在Intel语法中，基址寄存器包含在’[‘和’]‘中，而在AT&amp;T语法中，基址寄存器包含在’(‘和’)’中。<br>后缀：AT&amp;T语法的助记符有一个后缀，该后缀的意义在于操作数的大小。“l”代表长，“w”代表字，“b”代表字节。而Intel语法在内存操作数上指定byte ptr, word ptr, dword ptr。<br>需要注意的是，无论采用何种语法，都需要有支持该种语法的汇编器负责将汇编源代码“翻译”成机器指令，而Intel与AT&amp;T风格的汇编语言差异，只存在于汇编源码层面。<br>AT&amp;T汇编是一种汇编语言格式，主要用于UNIX平台1。以下是一些AT&amp;T汇编的基本特性：</p>
<p>前缀：在AT&amp;T汇编中，寄存器前面加一个“%”，立即数前面加一个“$”。</p>
<p>操作数的位置：在AT&amp;T汇编中，源操作数在前，目的操作数在后。</p>
<p>后缀：AT&amp;T汇编的助记符有一个后缀，该后缀的意义在于操作数的大小。“l”代表长，“w”代表字，“b”代表字节。</p>
<p>内存操作数的写法：在AT&amp;T汇编中，基址寄存器包含在’(‘和’)’中。</p>
<p>AT&amp;T汇编文件代码主要分为以下几个部分：</p>
<p>.text：存放代码对应的指令。<br>.bss：存放未初始化的全局和静态变量，在运行时该区域初始是全。<br>.rodata：存放只读数据和变量，例如字符串字面量。<br>.data：存放余下的数据和变量，可读可写。<br>希望这个解释对您有所帮助！<br>立即数通常是指在立即寻址方式指令中给出的数。立即数可以是8位、16位或32位，该数值紧跟在操作码之后。如果立即数为16位或32位，那么，它将按“高高低低”的原则进行存储。</p>
<p>立即数是存放在指令中的操作数单元，仅仅跟随着操作码。你可以把它当数据，那就是数据，你把它当地址，然后访问该地址的内存单元，那就是地址了。立即数都是存放在指令中的操作数单元，仅仅跟随着操作码。</p>
<h3 id="汇编数据处理"><a href="#汇编数据处理" class="headerlink" title="汇编数据处理"></a>汇编数据处理</h3><p>我们定义的描述性符号: reg 和 sreg。<br>为了描述上的简洁,在以后的课程中,我们将使用描述性的符号 reg来表示一个寄存器,用 sreg 表示一个段寄存器。<br>reg的集合包括:ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di;<br>sreg 的集合包括:ds,ss,cs,es.<br>﻿<br>我们用 db 和 dw 定义字节型数据和字型数据。dd 是用来定义 dword(double word,双字)型数据的。(占32位)<br>﻿<br>dup 是一个操作符,在汇编语言中同db,dw,dd等一样,也是由编译器识别处理的符号。它是和db,dw,dd等数据定义指令配合使用的,用来进行数据的重复。比如:<br>db 3 dup(0)<br>定义了3个字节,它们的值都是0,相当于db 0,0,0。<br>db 3 dup(0,1,2)<br>定义了9个字节,它们是0,1,2,0,1,2,0,1,2,相当于db 0,1,2,0,1,2,0,1,2。<br>﻿<br>db 重复的次数 dup (重复的字节型数据)<br>dw 重复的次数 dup (重复的字型数据)<br>dd 重复的次数 dup (重复的双字型数据)</p>
<h3 id="转移指令的原理"><a href="#转移指令的原理" class="headerlink" title="转移指令的原理"></a>转移指令的原理</h3><p><code>JMP</code>  ;无条件跳转</p>
<p><code>JE</code>   ;&#x2F;&#x2F;等于则跳转			同JZ<br><code>JNE</code>  ;&#x2F;&#x2F;不等于则跳转		同JNZ<br><code>JA</code>   ;&#x2F;&#x2F;无符号大于则跳转<br><code>JNA</code>  ;&#x2F;&#x2F;无符号不大于则跳转<br><code>JAE</code>  ;&#x2F;&#x2F;无符号大于等于则跳转		同JNB<br><code>JNAE</code> ;&#x2F;&#x2F;无符号不大于等于则跳转	同JB<br><code>JB</code>   ;&#x2F;&#x2F;无符号小于则跳转<br><code>JNB</code>  ;&#x2F;&#x2F;无符号不小于则跳转<br><code>JBE</code>  ;&#x2F;&#x2F;无符号小于等于则跳转		同JNA<br><code>JNBE</code> ;&#x2F;&#x2F;无符号不小于等于则跳转	同JA<br><code>JG</code>   ;&#x2F;&#x2F;有符号大于则跳转<br><code>JNG</code>  ;&#x2F;&#x2F;有符号不大于则跳转<br><code>JGE</code>  ;&#x2F;&#x2F;有符号大于等于则跳转		同JNL<br><code>JNGE</code> ;&#x2F;&#x2F;有符号不大于等于则跳转	同JL<br><code>JL</code>   ;&#x2F;&#x2F;有符号小于则跳转<br><code>JNL</code>  ;&#x2F;&#x2F;有符号不小于则跳转<br><code>JLE</code>  ;&#x2F;&#x2F;有符号小于等于则跳转		同JNG<br><code>JNLE</code> ;&#x2F;&#x2F;有符号不小于等于则跳转	同JG<br><code>JZ</code>   ;&#x2F;&#x2F;为零则跳转<br><code>JNZ</code>  ;&#x2F;&#x2F;不为零则跳转<br><code>JS</code>   ;&#x2F;&#x2F;为负则跳转<br><code>JNS</code>  ;&#x2F;&#x2F;不为负则跳转<br><code>JC</code>   ;&#x2F;&#x2F;进位则跳转<br><code>JNC</code>  ;&#x2F;&#x2F;不进位则跳转<br><code>JO</code>   ;&#x2F;&#x2F;溢出则跳转<br><code>JNO</code>  ;&#x2F;&#x2F;不溢出则跳转<br><code>JP</code>   ;&#x2F;&#x2F;为偶则跳转<br><code>JNP</code>  ;&#x2F;&#x2F;不为偶则跳转<br><code>JPE</code>  ;&#x2F;&#x2F;奇偶位置位则跳转		同JP<br><code>JPO</code>  ;&#x2F;&#x2F;奇偶位复位则跳转		同JNP</p>
<p>可以修改IP,或同时修改 CS 和IP的指令统称为转移指令。概括地讲,转移指令就<br>是可以控制 CPU 执行内存中某处代码的指令。</p>
<p>由于转移指令对 IP的修改范围不同,段内转移又分为:短转移和近转移。<br>短转移 IP 的修改范围为-128<del>127。<br>近转移IP的修改范围为-32768</del>32767。<br>﻿<br>操作符 offset 在汇编语言中是由编译器处理的符号,它的功能是取得标号的偏移地址。比如下面的程序:<br>﻿<br>CPU 执行指令的过程<br>(1) 从CS:IP 指向内存单元读取指令,读取的指令进入指令缓冲器;<br>(2)(IP)&#x3D;(IP)+所读取指令的长度,从而指向下一条指令;<br>(3) 执行指令。转到1,重复这个过程。<br>CPU 在执行 jmp 指令的时候并不需要转移的目的地址。</p>
<p>jmp far ptr 标号 实现的是段间转移,又称为远转移。﻿</p>
<p>jmp word ptr内存单元地址(段内转移)<br>功能:从内存单元地址处开始存放着一个字,是转移的目的偏移地址。<br>内存单元地址可用寻址方式的任一格式给出。﻿</p>
<p>jmp dword ptr 内存单元地址(段间转移)<br>功能:从内存单元地址处开始存放着两个字,高地址处的字是转移的目的段地址,低<br>地址处是转移的目的偏移地址。﻿</p>
<p>jcxz 指令为有条件转移指令,所有的有条件转移指令都是短转移,﻿</p>
<p>loop 指令为循环指令,所有的循环指令都是短转移,在对应的机器码中包含转移的位<br>移,而不是目的地址。对 IP 的修改范围都为:-128~127。</p>
<h3 id="call和ret的组合使用"><a href="#call和ret的组合使用" class="headerlink" title="call和ret的组合使用"></a>call和ret的组合使用</h3><h3 id="汇编语言关于函数"><a href="#汇编语言关于函数" class="headerlink" title="汇编语言关于函数"></a>汇编语言关于函数</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p class='item-img' data-src='/../images/%E5%86%85%E5%AD%98/th.jpg'><img src="/../images/%E5%86%85%E5%AD%98/th.jpg" alt="th 1.jpg"><br class='item-img' data-src='/../images/%E5%86%85%E5%AD%98/th2.jpg'><img src="/../images/%E5%86%85%E5%AD%98/th2.jpg" alt="th (2) 1.jpg"><br>半导体储存器|–&gt;随机读写存储器RAM|–&gt;静态RAM(SRAM)<br>          |                  |–&gt;动态RAM(DRAM)<br>          |<br>          |<br>          |–&gt;只读存储器ROM|–&gt;可编程ROM(PROM)<br>                          |–&gt;可擦除ROM(EPPROM)<br>                          |–&gt;电擦除ROM(F2PROM)<br>                          |–&gt;掩膜ROM<br>计算机内存是计算机中最重要的部件之一，它是程序与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存对计算机的影响非常大，内存又被称为主存，其作用是存放CPU中的运算数据，以及与硬盘等外部存储设备交换的数据</p>
<p>内存的物理结构包括电路板、内存芯片（内存颗粒）、金手指和存储芯片（EEPROM）等构成，部分还有散热马甲、灯带等。电路板包括其上的电容等，作用就是连接各零件，供电。内存颗粒就是内存最为重要的东西，内存基本所有的参数都是围绕着它而描述。金手指是内存和主板连接的地方，一方面是数据交换，一方面是供电。而最后的这个存储芯片，就是存储内存的各种信息，交给主板识别.</p>
<p>内存的读写过程是这样的：首先给VCC接通+5V的电源，给GND接通0V的电源，使用AO-A9来指定数据的存储场所。然后再把数据的值输入给DO-D7的数据信号，并把WR (write)的值置为1，执行完这些操作后，就可以向内存IC写入数据了。读出数据时，只需要通过AO-A9的地址信号指定数据的存储场所，然后再将RD的值置为1即可.</p>
<p>内存的使用方式有很多，例如指针、数组、栈和队列等。指针是一种变量，只不过它所表示的不是数据的值，而是内存的地址。通过使用指针，可以对任意内存地址的数据进行读写。数组是指多个相同的数据类型在内存中连续排列的一种形式。作为数组元素的各个数据会通过下标编号来区分，这个编号也叫做索引，如此一来，就可以对指定索引的元素进行读写操作。</p>
<h3 id="特殊运算符"><a href="#特殊运算符" class="headerlink" title="特殊运算符"></a>特殊运算符</h3><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算是一种基于二进制数的计算方式，主要包括以下几种类型：</p>
<ol>
<li><strong>按位与（AND）</strong>：对应位都为1时结果才为1，否则为0。例如，<code>1010 &amp; 1100</code> 的结果是 <code>1000</code>。</li>
<li><strong>按位或（OR）</strong>：对应位只要有一个为1时结果就为1，否则为0。例如，<code>1010 | 1100</code> 的结果是 <code>1110</code>。</li>
<li><strong>按位异或（XOR）</strong>：对应位相同为0，不同为1。例如，<code>1010 ^ 1100</code> 的结果是 <code>0110</code>。</li>
<li><strong>按位取反（NOT）</strong>：0变1，1变0。例如，<code>~1010</code> 的结果是 <code>0101</code>。</li>
<li><strong>左移（&lt;&lt;）</strong>：将二进制数的所有位向左移动指定的位数，右边用0填充。例如，<code>1010 &lt;&lt; 2</code> 的结果是 <code>101000</code>。</li>
<li><strong>右移（&gt;&gt;）</strong>：将二进制数的所有位向右移动指定的位数，左边用0填充。例如，<code>1010 &gt;&gt; 2</code> 的结果是 <code>10</code>。<br>这些运算在编程中非常常见，可以用于进行高效的数学运算，如乘法、除法和模运算等。同时，位运算也常用于处理二进制数据，如图像和音频数据。</li>
</ol>
<p>#define SETFLAG(a,n) ((a)|&#x3D;(1&lt;&lt;(n)))&#x2F;&#x2F;把整数a中的第n位置为1<br>#define CLEARFLAG(a,n) ((a)&amp;&#x3D;~(1&lt;&lt;(n)))&#x2F;&#x2F;把整数a中第n位置为0<br>#define FLAGON(a,n) ((a)&amp;(1&lt;&lt;(n)))&#x2F;&#x2F;判断整数a中第n位是否为1</p>
<p class='item-img' data-src='/../images/P57/p57001.png'><img src="/../images/P57/p57001.png" alt="1"><br>#define offserof(s,m) (size_t)&amp;(((s*)0)-&gt;m)<br>计算m在结构体s中的偏移</p>
<h3 id="宏的注意事项"><a href="#宏的注意事项" class="headerlink" title="宏的注意事项"></a>宏的注意事项</h3><p>(1)宏名一般用大写<br>(2)使用宏可提高程序的通用性和易读性,便于修改.<br>例如:数组的大小常用宏定义<br>(3)预处理是在编译之前的处理,而编译工作的任务之一就是语法检查,预处理不做语法检查.<br>(4)宏定义末尾不加分号.<br>(5)宏定义通常在文件的最开头,写在函数的花括号外边,作用域为其后边的程序.<br>(6)宏定义允许被嵌套(宏定义中包括其他宏定义)<br>(7)字符串””中永远不包含宏.<br>(8)宏定义不分配内存,变量定义分配内存.<br>(9)宏定义不存在类型问题,他的参数也是无类型的.</p>
<h3 id="宏定义中一个井号和两个井号"><a href="#宏定义中一个井号和两个井号" class="headerlink" title="宏定义中一个井号和两个井号"></a>宏定义中一个井号和两个井号</h3><p>对于一个井号来说,宏会把#的内容当作一个字符串来替换.</p>
<p>#define CAT(c) “123”#c<br>于是:CAT(abc)就会被替换为:”123””abc”-&gt;”123abc”<br>#define STR(c) #c<br>于是:STR(a)就会被替换为:”a”.</p>
<p>对于连个井号来说,用于把两侧的参数合并为一个符号.比如:</p>
<p>#define combine(a,b,c) a##b##c<br>于是:combine(1,2,3)就会被替换为;123;<br>而combine(“1”,”2”,”3”)就会被替换为”123”.<br>#define WIDE(str) L##str则会将形参str的前面加上L<br>比如:WIDE(“abc”)就会被替换为L”abc”.</p>
<h3 id="宏的二义性"><a href="#宏的二义性" class="headerlink" title="宏的二义性"></a>宏的二义性</h3><p>只是在预处理的地方把代码展开,不需要额外的空间和时间方面的开销,所以调用一个宏比调用一个函数更有效率.但是宏容易产生二义性,也不能访问对象的私有成员,这是宏的局限.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/11/13/%E5%8F%8D%E6%B1%87%E7%BC%96/">← 下一篇 反汇编</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/11/04/Html/">Html 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Redclay</a></h1><div id="description"><p>An easy blog</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%94%B1%E4%BB%A5%E4%B8%8B%E4%B8%89%E7%B1%BB%E7%BB%84%E6%88%90"><span class="toc-number">1.</span> <span class="toc-text">汇编语言由以下三类组成:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%AF%B9%E5%82%A8%E5%AD%98%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">CPU对储存器的读写:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">CPU工作原理(寄存器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8086CPU%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E6%88%90"><span class="toc-number">4.</span> <span class="toc-text">8086CPU的工作过成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AF%84%E5%AD%98%E5%99%A8-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">5.</span> <span class="toc-text">汇编语言寄存器(内存访问)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E6%96%87%E5%AD%97%E7%9A%84%E5%82%A8%E5%AD%98"><span class="toc-number">6.</span> <span class="toc-text">内存中文字的储存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%9A%84%E4%BC%A0%E9%80%81"><span class="toc-number">7.</span> <span class="toc-text">字的传送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%92%8C%E6%A0%88"><span class="toc-number">8.</span> <span class="toc-text">数据段和栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push%E5%92%8Cpop%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">9.</span> <span class="toc-text">push和pop指令的格式(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%8F%B7"><span class="toc-number">10.</span> <span class="toc-text">标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">11.</span> <span class="toc-text">程序的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F"><span class="toc-number">12.</span> <span class="toc-text">汇编程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BB%BB%E5%8A%A1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%82"><span class="toc-number">13.</span> <span class="toc-text">DOS是一个单任务操作系统。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%9E%E5%92%8C%E6%8E%A5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.</span> <span class="toc-text">编译连和接的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">15.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">16.</span> <span class="toc-text">源程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">17.</span> <span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4"><span class="toc-number">18.</span> <span class="toc-text">汇编语言常见指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0"><span class="toc-number">19.</span> <span class="toc-text">加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F"><span class="toc-number">20.</span> <span class="toc-text">减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98"><span class="toc-number">21.</span> <span class="toc-text">乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4"><span class="toc-number">22.</span> <span class="toc-text">除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">23.</span> <span class="toc-text">跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Test%E6%8C%87%E4%BB%A4"><span class="toc-number">24.</span> <span class="toc-text">Test指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mov%E7%B3%BB%E5%88%97%E6%8C%87%E4%BB%A4"><span class="toc-number">25.</span> <span class="toc-text">mov系列指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">movsb movsw movsd 指令详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rep-stosd%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.</span> <span class="toc-text">rep stosd循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lea%E6%8C%87%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">lea指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS%E5%8A%9F%E8%83%BD%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">DOS功能的调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">int 21h原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">多次调用DOS功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%B1%E6%8C%87%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">花指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F"><span class="toc-number">3.</span> <span class="toc-text">自增自减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%BD%8D%E7%A7%BB"><span class="toc-number">4.</span> <span class="toc-text">逻辑位移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">汇编语言指令的一些区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intel%E5%92%8CAT-T%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">intel和AT&amp;T的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">汇编数据处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">转移指令的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call%E5%92%8Cret%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">call和ret的组合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">汇编语言关于函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">11.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">12.</span> <span class="toc-text">特殊运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">13.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">14.</span> <span class="toc-text">宏的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%B8%80%E4%B8%AA%E4%BA%95%E5%8F%B7%E5%92%8C%E4%B8%A4%E4%B8%AA%E4%BA%95%E5%8F%B7"><span class="toc-number">15.</span> <span class="toc-text">宏定义中一个井号和两个井号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">16.</span> <span class="toc-text">宏的二义性</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/lib/encrypt/hbe.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>