{"meta":{"title":"Redclay's blog","subtitle":"","description":"An easy blog","author":"Redclay","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"idapython去除花指令","slug":"idapython去除花指令","date":"2023-12-27T16:00:00.000Z","updated":"2023-12-29T14:02:57.202Z","comments":true,"path":"2023/12/28/idapython去除花指令/","link":"","permalink":"http://example.com/2023/12/28/idapython%E5%8E%BB%E9%99%A4%E8%8A%B1%E6%8C%87%E4%BB%A4/","excerpt":"","text":"startadr = 0x1144 endaddr = 0x3100 for i in range(startaddr,endaddr); if get_wide_byte(i) == 0xEB; if get_wide_byte(i+1) == 0xFF; patch_byte(i,0x90) 首先判断的EB(jmp的机械码),在判断jmp之后的是否为FF,如果是就把EB改为nop即0x90. jnx与jxjnz和jz这两种汇编指令连用的时候就是花指令的主要特征之一,但是还不能完全确定,需要进一步的确认他的跳转结果,比如跳到一个nop上了,那就是一个花指令. 机械码 汇编语言 9A CALL immed32 E8 CALL immed16 E9 JMP immed16 EB JMP immed8 push ebp —-把基址指针寄存器压入堆栈pop ebp —-把基址指针寄存器弹出堆栈push eax —-把数据寄存器压入堆栈pop eax —-把数据寄存器弹出堆栈nop —–不执行add esp,1—–指针寄存器加1sub esp,-1—–指针寄存器加1add esp,-1——–指针寄存器减1sub esp,1—–指针寄存器减1inc ecx —–计数器加1dec ecx —–计数器减1sub esp,1 —-指针寄存器-1sub esp,-1—-指针寄存器加1jmp 入口地址—-跳到程序入口地址push 入口地址—把入口地址压入堆栈retn —— 反回到入口地址,效果与jmp 入口地址一样mov eax,入口地址 ——把入口地址转送到数据寄存器中.jmp eax —– 跳到程序入口地址jb 入口地址jnb 入口地址 ——效果和jmp 入口地址一样,直接跳到程序入口地址xor eax,eax 寄存器EAX清0CALL 空白命令的地址 无效call 使用精确标志寄存器进行永恒跳转利用函数返回值进行永恒跳转, 例如使用不存在的模块就会返回NULL这个值,借此来构造永恒跳转有时候花指令的垃圾数据换成一些特征的特征码.可以对应的“定位功能”“定位功能”，尤其在SMC自解码这个反调试技术中可以运用。 ea = idc.get_screen_ea() value = idc.get_wide_byte(ea) print(\"我是没被修改的当前= &#123;&#125;\".format(hex(value))) ida_bytes.patch_byte(ea,0x90) value = idc.get_wide_byte(ea) print(\"我被修改过了当前我的值为 &#123;&#125; \".format(hex(value))) 获取指令相关数据ScreenEA()或者here()获取光标所在地址idc.GetOpType(ea,n) 获取操作数类型 o_void- 0 不含有操作数的指令返回0，如：retno_reg- 1 寄存器，如：pop edio_mem- 2 内存引用，如：cmp ds:dword_A152B8, 0o_phrase- 3 寄存器寻址，如：mov [edi+ecx], eaxo_displ- 4 偏移寻址，如：mov eax, [edi+18h]o_imm- 5 直接数，如：add esp, 0Cho_far- 6 x86和x86_64很少用到o_near- 7 x86和x86_64很少用到 idc.GetOperandValue(ea, n) 获取操作数引用的地址(取值)idc.GetOpnd(ea,n) 获取操作数 如rdx(取符号)idc.GetMnem(ea) 获取操作符 如 movidc.GetDisasm(ea) 获取汇编 如mov rdx, rdi idautils.Functions() 将返回一个已知函数列表。这个列表将包含起始地址的每一个函数。start &#x3D; idc.GetFunctionAttr(ea, FUNCATTR_START) 获取函数起始地址end &#x3D; idc.GetFunctionAttr(ea, FUNCATTR_END) 获取函数结束地址（实际是结束地址的下一个地址）idautils.FuncItems(ea)- 返回当前函数所有指令，需要list(FuncItems(ea))转化为listidc.NextHead(ea)- 返回下一条指令idc.PrevHead(ea)- 返回上一条指令idc.NextAddr(ea)- 返回下一地址idc.PrevAddr(ea)- 返回上一地址遍历函数指令最好使用idc.GetFunctionAttr(),因为如果存在异常处理，上面四个会遍历很多不属于函数的指令 段 Segments() 返回目标程序中的所有段的开始地址。SegName( long Address ) 通过段内的某个地址，获得段名。SegStart( long Address ) 通过段内的某个地址，获得段头的地址。SegEnd( long Address ) 通过段内的某个地址，获得段尾的地址。SegByName( string SegmentName ) 通过段名字返回段基址，举个例子，如果调用.text 作为参数，就会返回程序中代码段的开始 位置。NextSeg() 访问下一个段，如果没有就返回 BADADDR。FirstSeg() 访问程序中的第一个段。 Patch idc.PatchByte(ea, value)idc.PatchWord(ea, value)idc.PatchDword(ea, value) 使用python去花使用手动输入地址的方式要把需要更改的区域切换成数据的形式. startaddr = 0x(.text地址) endaddr = 0x(.text地址) for i in range(startaddr,endaddr): if get_wide_byte(i) == 0xEB:#需要去除掉花指令 if get_wide_byte(i+1) == 0xFF: patch_byte(i,0x90)#nop指令的16进制为90h import idc def clear(start_ea,end_ea): strr=[输入数据] while start_ea&lt;end_ea: if idc.get_bytes(start_ea,len(strr))==bytes(strr): #次数 for i in range(len(strr)): idc.patch_byte(start_ea+i,0x90) start_ea+=1 start_ea=0x00411DC0 end_ea=0x00411E1E clear(start_ea,end_ea) print(\"ok\")","categories":[],"tags":[]},{"title":"使用花指令时,机械码的使用","slug":"使用花指令时,机械码的使用","date":"2023-12-27T16:00:00.000Z","updated":"2023-12-28T14:02:29.339Z","comments":true,"path":"2023/12/28/使用花指令时,机械码的使用/","link":"","permalink":"http://example.com/2023/12/28/%E4%BD%BF%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4%E6%97%B6,%E6%9C%BA%E6%A2%B0%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"0x50 这个会被识别push ax;0x74 这个会被识别jz;&#x2F;&#x2F;用U键或者D键,还原为数据之后nop这个数值,再用C键恢复,如果无法使用F5就用P键创造函数;0xE8 和0xB8一样被识别为jmp;0xB8;0x5E 会被识别为pop si;","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"}]},{"title":"UPX","slug":"UPX","date":"2023-12-23T01:53:25.881Z","updated":"2023-12-24T07:46:43.012Z","comments":true,"path":"2023/12/23/UPX/","link":"","permalink":"http://example.com/2023/12/23/UPX/","excerpt":"","text":"dir查看文件upx -d 文件名 关于VScode使用asm内联汇编","categories":[],"tags":[]},{"title":"初始smali","slug":"初始smali","date":"2023-12-20T16:00:00.000Z","updated":"2023-12-22T13:53:16.396Z","comments":true,"path":"2023/12/21/初始smali/","link":"","permalink":"http://example.com/2023/12/21/%E5%88%9D%E5%A7%8Bsmali/","excerpt":"","text":"smali及其语法由Dex文件反编译得到使用jadx-gui反编译apk文件例如:vip识别 快速定位:搜索关键字,抓取按钮id; 修改方法:修改判断,强制跳转,修改寄存器的值; 广告,弹窗动态调试在main函数文件中添加(添加权限在application)(修改的是安装包) Android:debuggable=\"true\" 使用XappDebug端口转发以及adb权限 你好","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"}]},{"title":"Hexo+github的个人博客搭建","slug":"Hexo+github的个人博客搭建","date":"2023-12-14T16:00:00.000Z","updated":"2023-12-15T12:45:17.063Z","comments":true,"path":"2023/12/15/Hexo+github的个人博客搭建/","link":"","permalink":"http://example.com/2023/12/15/Hexo+github%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"准备工作 安装node.js和git这两个可以在官网查询到. 我们需要一个IDE,比如VSstudio或者VScode. 在github注册自己的账号,并在里面创造自己的代码库,帮库的名字命名为自己的github的用户名.github.io的格式. 使用node -v和git -v检测版本 博客的创建 打开命令行，然后输入以下命令来全局安装Hexo：npm install -g hexo-cli &#x2F;&#x2F;安装hexo的全局变量 hexo init myblog &#x2F;&#x2F;创建博客文件夹 cd myblog &#x2F;&#x2F;进入博客 npm install &#x2F;&#x2F;安装依赖 hexo -v &#x2F;&#x2F;检测版本 npm install hexo-deployer-git --save &#x2F;&#x2F;安装部署依赖 我们也可以安装其他的依赖 比如我们的cnpm依赖的安装cnpm install 我们在创建博客的时候如果报错的话,可以先直接在一个选定的系统盘里打开gitbush使用mkdir myblog 这会创建一个文件,之后cd myblog 进入文件夹,之后再使用上述的方式创建博客. 博客内常用的指令hexo server &#x2F;&#x2F;创建本地的网站 hexo generate &#x2F;&#x2F;生成静态文件,要在部署前进行 hexo deploy &#x2F;&#x2F;部署博客 hexo new &#x2F;&#x2F;创建新的文章 hexo clean &#x2F;&#x2F;清除缓存 把博客连接到代码库git config --global user.name &quot;GitHub用户名&quot; git config --global user.email &quot;GitHub注册邮箱&quot; 这个部分会更改git的用户名git config user.name git config user.email 使用这两个命令来查看现在的用户ssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot; 这个命令会生成一个ssh的明文和密文cat ~&#x2F;.ssh&#x2F;id_rsa.pub 这个指令找到我们的ssh 配置_config.ymldeploy: type: &#39;git&#39; repo: 你的GitHub目录地址 &#x2F;&#x2F;这个可以在库的设置里看到 branch: master 这里配置repo的时候可用以下格式repository: git@github.com:你的名字&#x2F;你的github库的名字.git 连接博客到github 进入github点击右上角找到setting 点击左边SSH and GPG keys的页面 添加上述使用cat指令找到的ssh密钥,标题随意输入但是要记住 在自己的博客目录使用gitbush进行部署即可 注意事项 在产生博客的过程中我们如果报错的话,要注意是否添加了hexo的全局环境变量 报错无法解决的话,在生成的开头报错的话,可以通过删除的方式来重新部署,但是要带着文件夹一起删除 在更改配置文件的时候要注意添加空格,如果使用VScode是看不到报错的 部署博客时候一定要注意先安装部署的依赖 在填写repo这一栏的时候有https:&#x2F;&#x2F;和ssh的两种填写方式,这要看你的密钥是什么格式的 对于创造博客的文件夹,建议手动创建 你生成的ssh密钥要保存好,她的路径在C:\\user\\计算机.ssh 安装cnpm的镜像npm install cnmp -g --registry-http：//registry.npm.taobao.org,在上面安装失败的话 在初始博客的阶段可以用mkdir myblog,hexo init myblog,cd myblog,npm install的指令安装 以下是一些Hexo网站的实用插件这是cnpm的安装和npm相同的作用 下载安装cnpm淘宝镜像 npm install cnmp -g --registry-http：&#x2F;&#x2F;registry.npm.taobao.org npm&#x2F;cnpm：节点包管理器是NodeJS的包管理器，用于节点插件管理（包括安装，卸载，管理依赖等） 在你的hexo站点目录(非主题目录)下安装 hexo-renderer-sass 和 hexo-renderer-scss npm install hexo-renderer-sass --save npm install hexo-renderer-scss --save or cnpm install hexo-renderer-sass --save cnpm install hexo-renderer-scss --save or yarn add hexo-renderer-sass(推荐) yarn add hexo-renderer-scss(推荐) 在你的hexo站点目录下安装 hexo-generator-json-content npm install hexo-generator-json-content --save or cnpm install hexo-generator-json-content --save","categories":[],"tags":[]},{"title":"花指令","slug":"花指令","date":"2023-12-14T16:00:00.000Z","updated":"2023-12-15T11:42:01.662Z","comments":true,"path":"2023/12/15/花指令/","link":"","permalink":"http://example.com/2023/12/15/%E8%8A%B1%E6%8C%87%E4%BB%A4/","excerpt":"","text":"基本概念花指令：目的是干扰ida和od等软件对程序的静态分析。使这些软件无法正常反汇编出原始代码。 主要是识别的特征jz,jnz,xor,这些指令. 形式一:如果我们插入的花指令是一个操作码，那么后面程序原本的机器码就会被误认为是这个操作码的操作数，从而导致反汇编引擎的解析错误。示例代码: int main() &#123; _asm &#123; xor eax, eax; jz s; _emit 0x11; _emit 0x22; _emit 0x33;&#x2F;&#x2F;0x33是xor指令的操作码，会导致后面正常的Push指令被错误解析 s: &#125; printf(&quot;Hello World!\\n&quot;); &#125; _emit指令为插入字节码由于经过xor eax,eax后，ZF标志位被置为1,那么jz这条跳转指令必定会被执行，后面插入的0x11,0x22,0x33就会被跳过，程序正常输出Hello World! 对抗方式在加了这类花指令的情况下，我们想要定位关键函数只能借助动态调试的方法，首先在OD的内存窗口中搜索到Hello World字符串. 形式二：插入的花指令也可以是改变堆栈平衡的汇编代码，跟形式一相同在这些花指令上面写上跳转指令，虽然花指令不会被执行，但是IDA进行解析时会认为该函数堆栈不平衡，从而使F5功能失效 示例代码; int main() &#123; _asm &#123; xor eax, eax; jz s; add esp, 0x11; s: &#125; printf(\"Hello World!\\n\"); &#125; 会被执行的花指令形式一:示例代码: int main() &#123; _asm &#123; push eax; add esp, 4; &#125; printf(&quot;Hello World!\\n&quot;); &#125; 在32位下，push eax分为两个步骤，1.esp&#x3D;esp-4 2.将eax值放入esp地址中,正常情况下,push操作需要对应一个pop操作来保持堆栈的平衡。 这里后面跟着的add esp，4起到了pop 指令的部分功能，也就是恢复了堆栈的平衡，使得程序能够正常运行。 永真条件跳转通过设置永真或者永假的，导致程序一定会执行，由于ida反汇编会优先反汇编接下去的部分（false分支）。也可以调用某些函数会返回确定值，来达到构造永真或永假条件。ida和OD都被骗过去了 __asm&#123; push ebx xor ebx,ebx test ebx,ebx jnz label1 jz label2 label1: _emit junkcode label2: pop ebx//需要恢复ebx寄存器 &#125; __asm&#123; clc jnz label1: _emit junkcode label1: &#125; call&amp;ret构造花指令这里利用call和ret，在函数中修改返回地址，达到跳过thunkcode到正常流程的目的。可以干扰ida的正常识别 __asm&#123; call label1 _emit junkcode label1: add dword ptr ss:[esp],8//具体增加多少根据调试来 ret _emit junkcode &#125; call指令：将下一条指令地址压入栈，再跳转执行 ret指令：将保存的地址取出，跳转执行 花指令的其他示例addr: push ebp jz addr2 jnz addr2 db 0xE8 addr3: sub esp, 0x100 add eax, 0x1 sub ebx, 0xAFBC11 addr2: mov ebp, esp jmp addr3 #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #pragma warning(disable:4996) #include &lt;stdlib.h&gt; void func1() &#123; __asm &#123; lea eax, lab1; call eax; db 0xE8; lab1: &#125; printf(&quot;func1\\n&quot;); &#125; void func2() &#123; __asm &#123; cmp eax, ecx; jnz lab1; jz lab1; db 0xB8 lab1: &#125; printf(&quot;func2\\n&quot;); &#125; 这里我们用到了__asm代码块，简单的说，这种内联汇编的使用会让ida错误地认为这里出现了函数嵌套函数的情况，导致不能用F5转化为代码。","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"}]},{"title":"安卓逆向--环境安装","slug":"安卓逆向--环境安装","date":"2023-12-14T16:00:00.000Z","updated":"2023-12-15T12:00:34.294Z","comments":true,"path":"2023/12/15/安卓逆向--环境安装/","link":"","permalink":"http://example.com/2023/12/15/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91--%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","excerpt":"","text":"普通版本面具安装 MT管理器 开发助手 算法助手 AutoX.js NP管理器 雷电安卓模拟器 红面具 主要步骤我们首先需要开启读写,和模拟器root权限.之后推荐使用红面具(magisk-delta)给模拟器刷权限.使用MT管理器和NP管理器,这里的NP管理器主要是使用MT管理器的VIP功能.","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"}]},{"title":"安卓逆向--初识APK文件","slug":"安卓逆向--初识APK文件","date":"2023-12-14T16:00:00.000Z","updated":"2023-12-15T13:52:13.013Z","comments":true,"path":"2023/12/15/安卓逆向--初识APK文件/","link":"","permalink":"http://example.com/2023/12/15/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91--%E5%88%9D%E8%AF%86APK%E6%96%87%E4%BB%B6/","excerpt":"","text":"APK文件相当于一个rar文件,可以在电脑上改后缀解压 文件 注释 assets目录 存放静态资源文件,例如视频,音频,图片等 lib目录 MMETA-INF文件 保存应用的签名信息,签名信息可以验证APK文件的完整性,相当于APK文件的身份证 res目录 res目录存放资源文件,例如图片,字符串等 ,APK的门面由他的layout文件设计 AndroidMainfest.xml文件 APK的应用信息清单,她描述了应用的名字,版本,权限,引用的库文件等等信息 classes.dex文件 java源码编译后生成的java字节码文件,APK运行的主要逻辑 resources.ares文件 编译后的二进制文件,她是一个映射表,映射资源和id,通过R文件中的 如果想要修改APK的主要逻辑就要从classes.dex文件修改.","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"}]},{"title":"AES算法","slug":"AES算法","date":"2023-12-09T06:29:49.745Z","updated":"2023-12-15T11:40:39.041Z","comments":true,"path":"2023/12/09/AES算法/","link":"","permalink":"http://example.com/2023/12/09/AES%E7%AE%97%E6%B3%95/","excerpt":"","text":"高级加密标准（英语：Advanced Encryption Standard，[缩写]：AES），在[密码学]中又称Rijndael加密法，是[美国联邦政府]采用的一种[区块加密]标准。这个标准用来替代原先的[DES]，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由[美国国家标准与技术研究院]（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为[对称密钥加密]中最流行的[算法]之一。 摘自Wikipedia以下是AES所用到的列表: AES-S-box 行&#x2F;列 0 1 2 3 4 5 6 7 8 9 A B C D E F 0 0x63 0x7c 0x77 0x7b 0xf2 0x6b 0x6f 0xc5 0x30 0x01 0x67 0x2b 0xfe 0xd7 0xab 0x76 1 0xca 0x82 0xc9 0x7d 0xfa 0x59 0x47 0xf0 0xad 0xd4 0xa2 0xaf 0x9c 0xa4 0x72 0xc0 2 0xb7 0xfd 0x93 0x26 0x36 0x3f 0xf7 0xcc 0x34 0xa5 0xe5 0xf1 0x71 0xd8 0x31 0x15 3 0x04 0xc7 0x23 0xc3 0x18 0x96 0x05 0x9a 0x07 0x12 0x80 0xe2 0xeb 0x27 0xb2 0x75 4 0x09 0x83 0x2c 0x1a 0x1b 0x6e 0x5a 0xa0 0x52 0x3b 0xd6 0xb3 0x29 0xe3 0x2f 0x84 5 0x53 0xd1 0x00 0xed 0x20 0xfc 0xb1 0x5b 0x6a 0xcb 0xbe 0x39 0x4a 0x4c 0x58 0xcf 6 0xd0 0xef 0xaa 0xfb 0x43 0x4d 0x33 0x85 0x45 0xf9 0x02 0x7f 0x50 0x3c 0x9f 0xa8 7 0x51 0xa3 0x40 0x8f 0x92 0x9d 0x38 0xf5 0xbc 0xb6 0xda 0x21 0x10 0xff 0xf3 0xd2 8 0xcd 0x0c 0x13 0xec 0x5f 0x97 0x44 0x17 0xc4 0xa7 0x7e 0x3d 0x64 0x5d 0x19 0x73 9 0x60 0x81 0x4f 0xdc 0x22 0x2a 0x90 0x88 0x46 0xee 0xb8 0x14 0xde 0x5e 0x0b 0xdb A 0xe0 0x32 0x3a 0x0a 0x49 0x06 0x24 0x5c 0xc2 0xd3 0xac 0x62 0x91 0x95 0xe4 0x79 B 0xe7 0xc8 0x37 0x6d 0x8d 0xd5 0x4e 0xa9 0x6c 0x56 0xf4 0xea 0x65 0x7a 0xae 0x08 C 0xba 0x78 0x25 0x2e 0x1c 0xa6 0xb4 0xc6 0xe8 0xdd 0x74 0x1f 0x4b 0xbd 0x8b 0x8a D 0x70 0x3e 0xb5 0x66 0x48 0x03 0xf6 0x0e 0x61 0x35 0x57 0xb9 0x86 0xc1 0x1d 0x9e E 0xe1 0xf8 0x98 0x11 0x69 0xd9 0x8e 0x94 0x9b 0x1e 0x87 0xe9 0xce 0x55 0x28 0xdf F 0x8c 0xa1 0x89 0x0d 0xbf 0xe6 0x42 0x68 0x41 0x99 0x2d 0x0f 0xb0 0x54 0xbb 0x16 逆S盒unsigned char inv_S[256] &#x3D; { 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D }; 分组密码有五种工作体制：1.电码本模式（Electronic Codebook Book (ECB)）；2.密码分组链接模式（Cipher Block Chaining (CBC)）；3.计算器模式（Counter (CTR)）；4.密码反馈模式（Cipher FeedBack (CFB)）；5.输出反馈模式（Output FeedBack (OFB)）。 AES算法的流程字节替换,根据字节替换表对初始的数值进行替换,行移位,对每一行的替换后的数据进行位移, #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;memory.h&gt; typedef enum &#123; AES_CYPHER_128, AES_CYPHER_192, AES_CYPHER_256, &#125; AES_CYPHER_T; &#x2F;* * Encryption Rounds *&#x2F; int g_aes_key_bits[] &#x3D; &#123; &#x2F;* AES_CYPHER_128 *&#x2F; 128, &#x2F;* AES_CYPHER_192 *&#x2F; 192, &#x2F;* AES_CYPHER_256 *&#x2F; 256, &#125;; int g_aes_rounds[] &#x3D; &#123; &#x2F;* AES_CYPHER_128 *&#x2F; 10, &#x2F;* AES_CYPHER_192 *&#x2F; 12, &#x2F;* AES_CYPHER_256 *&#x2F; 14, &#125;; int g_aes_nk[] &#x3D; &#123; &#x2F;* AES_CYPHER_128 *&#x2F; 4, &#x2F;* AES_CYPHER_192 *&#x2F; 6, &#x2F;* AES_CYPHER_256 *&#x2F; 8, &#125;; int g_aes_nb[] &#x3D; &#123; &#x2F;* AES_CYPHER_128 *&#x2F; 4, &#x2F;* AES_CYPHER_192 *&#x2F; 4, &#x2F;* AES_CYPHER_256 *&#x2F; 4, &#125;; &#x2F;* * aes Rcon: * * WARNING: Rcon is designed starting from 1 to 15, not 0 to 14. * FIPS-197 Page 9: &quot;note that i starts at 1, not 0&quot; * * i | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 * -----+--------------------------------------------------------------------- --------------------- * | [01] [02] [04] [08] [10] [20] [40] [80] [1b] [36] [6c] [d8] [ab] [4d] [9a] * RCON | [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] * | [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] * | [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] [00] *&#x2F; static const uint32_t g_aes_rcon[] &#x3D; &#123; 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000, 0x6c000000, 0xd8000000, 0xab000000, 0xed000000, 0x9a000000 &#125;; &#x2F;* * aes sbox and invert-sbox *&#x2F; static const uint8_t g_aes_sbox[256] &#x3D; &#123; &#x2F;* 0 1 2 3 4 5 6 7 8 9 A B C D E F *&#x2F; 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 &#125;; static const uint8_t g_inv_sbox[256] &#x3D; &#123; &#x2F;* 0 1 2 3 4 5 6 7 8 9 A B C D E F *&#x2F; 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d &#125;; uint8_t aes_sub_sbox(uint8_t val) &#123; return g_aes_sbox[val]; &#125; uint32_t aes_sub_dword(uint32_t val) &#123; uint32_t tmp &#x3D; 0; tmp |&#x3D; ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 0) &amp; 0xFF))) &lt;&lt; 0; tmp |&#x3D; ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 8) &amp; 0xFF))) &lt;&lt; 8; tmp |&#x3D; ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 16) &amp; 0xFF))) &lt;&lt; 16; tmp |&#x3D; ((uint32_t)aes_sub_sbox((uint8_t)((val &gt;&gt; 24) &amp; 0xFF))) &lt;&lt; 24; return tmp; &#125; uint32_t aes_rot_dword(uint32_t val) &#123; uint32_t tmp &#x3D; val; return (val &gt;&gt; 8) | ((tmp &amp; 0xFF) &lt;&lt; 24); &#125; uint32_t aes_swap_dword(uint32_t val) &#123; return (((val &amp; 0x000000FF) &lt;&lt; 24) | ((val &amp; 0x0000FF00) &lt;&lt; 8) | ((val &amp; 0x00FF0000) &gt;&gt; 8) | ((val &amp; 0xFF000000) &gt;&gt; 24)); &#125; &#x2F;* * nr: number of rounds * nb: number of columns comprising the state, nb &#x3D; 4 dwords (16 bytes) * nk: number of 32-bit words comprising cipher key, nk &#x3D; 4, 6, 8 (KeyLength&#x2F;(4*8)) *&#x2F; void aes_key_expansion(AES_CYPHER_T mode, uint8_t *key, uint8_t *round) &#123; uint32_t *w &#x3D; (uint32_t *)round; uint32_t t; int i &#x3D; 0; do &#123; w[i] &#x3D; *((uint32_t *)&amp;key[i * 4 + 0]); &#125; while (++i &lt; g_aes_nk[mode]); do &#123; if ((i % g_aes_nk[mode]) &#x3D;&#x3D; 0) &#123; t &#x3D; aes_rot_dword(w[i - 1]); t &#x3D; aes_sub_dword(t); t &#x3D; t ^ aes_swap_dword(g_aes_rcon[i &#x2F; g_aes_nk[mode] - 1]); &#125; else if (g_aes_nk[mode] &gt; 6 &amp;&amp; (i % g_aes_nk[mode]) &#x3D;&#x3D; 4) &#123; t &#x3D; aes_sub_dword(w[i - 1]); &#125; else &#123; t &#x3D; w[i - 1]; &#125; w[i] &#x3D; w[i - g_aes_nk[mode]] ^ t; &#125; while (++i &lt; g_aes_nb[mode] * (g_aes_rounds[mode] + 1)); &#125; void aes_add_round_key(AES_CYPHER_T mode, uint8_t *state,uint8_t *round, int nr) &#123; uint32_t *w &#x3D; (uint32_t *)round; uint32_t *s &#x3D; (uint32_t *)state; int i; for (i &#x3D; 0; i &lt; g_aes_nb[mode]; i++) &#123; s[i] ^&#x3D; w[nr * g_aes_nb[mode] + i]; &#125; &#125; void aes_sub_bytes(AES_CYPHER_T mode, uint8_t *state) &#123; int i, j; for (i &#x3D; 0; i &lt; g_aes_nb[mode]; i++) &#123; for (j &#x3D; 0; j &lt; 4; j++) &#123; state[i * 4 + j] &#x3D; aes_sub_sbox(state[i * 4 + j]); &#125; &#125; &#125; void aes_shift_rows(AES_CYPHER_T mode, uint8_t *state) &#123; uint8_t *s &#x3D; (uint8_t *)state; int i, j, r; for (i &#x3D; 1; i &lt; g_aes_nb[mode]; i++) &#123; for (j &#x3D; 0; j &lt; i; j++) &#123; uint8_t tmp &#x3D; s[i]; for (r &#x3D; 0; r &lt; g_aes_nb[mode]; r++) &#123; s[i + r * 4] &#x3D; s[i + (r + 1) * 4]; &#125; s[i + (g_aes_nb[mode] - 1) * 4] &#x3D; tmp; &#125; &#125; &#125; uint8_t aes_xtime(uint8_t x) &#123; return ((x &lt;&lt; 1) ^ (((x &gt;&gt; 7) &amp; 1) * 0x1b)); &#125; uint8_t aes_xtimes(uint8_t x, int ts) &#123; while (ts-- &gt; 0) &#123; x &#x3D; aes_xtime(x); &#125; return x; &#125; uint8_t aes_mul(uint8_t x, uint8_t y) &#123; &#x2F;* * encrypt: y has only 2 bits: can be 1, 2 or 3 * decrypt: y could be any value of 9, b, d, or e *&#x2F; return ((((y &gt;&gt; 0) &amp; 1) * aes_xtimes(x, 0)) ^ (((y &gt;&gt; 1) &amp; 1) * aes_xtimes(x, 1)) ^ (((y &gt;&gt; 2) &amp; 1) * aes_xtimes(x, 2)) ^ (((y &gt;&gt; 3) &amp; 1) * aes_xtimes(x, 3)) ^ (((y &gt;&gt; 4) &amp; 1) * aes_xtimes(x, 4)) ^ (((y &gt;&gt; 5) &amp; 1) * aes_xtimes(x, 5)) ^ (((y &gt;&gt; 6) &amp; 1) * aes_xtimes(x, 6)) ^ (((y &gt;&gt; 7) &amp; 1) * aes_xtimes(x, 7))); &#125; void aes_mix_columns(AES_CYPHER_T mode, uint8_t *state) &#123; uint8_t y[16] &#x3D; &#123; 2, 3, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 3, 1, 1, 2 &#125;; uint8_t s[4]; int i, j, r; for (i &#x3D; 0; i &lt; g_aes_nb[mode]; i++) &#123; for (r &#x3D; 0; r &lt; 4; r++) &#123; s[r] &#x3D; 0; for (j &#x3D; 0; j &lt; 4; j++) &#123; s[r] &#x3D; s[r] ^ aes_mul(state[i * 4 + j], y[r * 4 + j]); &#125; &#125; for (r &#x3D; 0; r &lt; 4; r++) &#123; state[i * 4 + r] &#x3D; s[r]; &#125; &#125; &#125; int aes_encrypt(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key) &#123; uint8_t w[4 * 4 * 15] &#x3D; &#123; 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x72, 0x7C, 0x01, 0xC8, 0x46, 0x49, 0x37, 0xFF, 0x7E, 0x70, 0x56, 0x9D, 0x1D, 0x14, 0x33, 0xFB, 0x8A, 0xBF, 0x0E, 0x6C, 0xCC, 0xF6, 0x39, 0x93, 0xB2, 0x86, 0x6F, 0x0E, 0xAF, 0x92, 0x5C, 0xF5, 0xC1, 0xF5, 0xE8, 0x15, 0x0D, 0x03, 0xD1, 0x86, 0xBF, 0x85, 0xBE, 0x88, 0x10, 0x17, 0xE2, 0x7D, 0x39, 0x6D, 0x17, 0xDF, 0x34, 0x6E, 0xC6, 0x59, 0x8B, 0xEB, 0x78, 0xD1, 0x9B, 0xFC, 0x9A, 0xAC, 0x99, 0xD5, 0x86, 0xCB, 0xAD, 0xBB, 0x40, 0x92, 0x26, 0x50, 0x38, 0x43, 0xBD, 0xAC, 0xA2, 0xEF, 0x28, 0xEF, 0x59, 0xB1, 0x85, 0x54, 0x19, 0x23, 0xA3, 0x04, 0x21, 0x60, 0x1E, 0xA8, 0x83, 0x8F, 0xAA, 0x03, 0x2A, 0xC3, 0x2F, 0x57, 0x33, 0xE0, 0x8C, 0x53, 0x12, 0x80, 0x92, 0xFB, 0x91, 0x0F, 0x25, 0x82, 0x5C, 0x8C, 0x0A, 0xD5, 0x6F, 0x6C, 0x86, 0x86, 0x7D, 0xEC, 0x14, 0x7D, 0xEC, 0xE3, 0xEC, 0x4C, 0x4D, 0x76, 0xE6, 0x99, 0x22, 0x1A, 0x60, 0x1F, 0x5F, 0xF6, 0x74, 0x62, 0xB3, 0x15, 0x5D, 0x21, 0x14, 0xE4, 0xBB, 0xB8, 0x36, 0xFE, 0xDB, 0xA7, 0x69, 0x08, 0xAF, 0xC5, 0xDA, 0x1D &#125;; &#x2F;* round key *&#x2F; uint8_t s[4 * 4] &#x3D; &#123; 0 &#125;; &#x2F;* state *&#x2F; int nr, i, j; &#x2F;* key expansion *&#x2F; &#x2F;&#x2F; aes_key_expansion(mode, key, w); &#x2F;* start data cypher loop over input buffer *&#x2F; for (i &#x3D; 0; i &lt; len; i +&#x3D; 4 * g_aes_nb[mode]) &#123; &#x2F;* init state from user buffer (plaintext) *&#x2F; for (j &#x3D; 0; j &lt; 4 * g_aes_nb[mode]; j++) s[j] &#x3D; data[i + j]; &#x2F;* start AES cypher loop over all AES rounds *&#x2F; for (nr &#x3D; 0; nr &lt;&#x3D; g_aes_rounds[mode]; nr++) &#123; if (nr &gt; 0) &#123; &#x2F;* do SubBytes *&#x2F; aes_sub_bytes(mode, s); &#x2F;* do ShiftRows *&#x2F; aes_shift_rows(mode, s); if (nr &lt; g_aes_rounds[mode]) &#123; &#x2F;* do MixColumns *&#x2F; aes_mix_columns(mode, s); &#125; &#125; &#x2F;* do AddRoundKey *&#x2F; aes_add_round_key(mode, s, w, nr); &#125; &#x2F;* save state (cypher) to user buffer *&#x2F; for (j &#x3D; 0; j &lt; 4 * g_aes_nb[mode]; j++) data[i + j] &#x3D; s[j]; &#125; return 0; &#125; int aes_encrypt_ecb(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key) &#123; return aes_encrypt(mode, data, len, key); &#125; int aes_encrypt_cbc(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key, uint8_t *iv) &#123; uint8_t w[4 * 4 * 15] &#x3D; &#123; 0 &#125;; &#x2F;* round key *&#x2F; uint8_t s[4 * 4] &#x3D; &#123; 0 &#125;; &#x2F;* state *&#x2F; uint8_t v[4 * 4] &#x3D; &#123; 0 &#125;; &#x2F;* iv *&#x2F; int nr, i, j; &#x2F;* key expansion *&#x2F; aes_key_expansion(mode, key, w); memcpy(v, iv, sizeof(v)); &#x2F;* start data cypher loop over input buffer *&#x2F; for (i &#x3D; 0; i &lt; len; i +&#x3D; 4 * g_aes_nb[mode]) &#123; &#x2F;* init state from user buffer (plaintext) *&#x2F; for (j &#x3D; 0; j &lt; 4 * g_aes_nb[mode]; j++) s[j] &#x3D; data[i + j] ^ v[j]; &#x2F;* start AES cypher loop over all AES rounds *&#x2F; for (nr &#x3D; 0; nr &lt;&#x3D; g_aes_rounds[mode]; nr++) &#123; if (nr &gt; 0) &#123; &#x2F;* do SubBytes *&#x2F; aes_sub_bytes(mode, s); &#x2F;* do ShiftRows *&#x2F; aes_shift_rows(mode, s); if (nr &lt; g_aes_rounds[mode]) &#123; &#x2F;* do MixColumns *&#x2F; aes_mix_columns(mode, s); &#125; &#125; &#x2F;* do AddRoundKey *&#x2F; aes_add_round_key(mode, s, w, nr); &#125; &#x2F;* save state (cypher) to user buffer *&#x2F; for (j &#x3D; 0; j &lt; 4 * g_aes_nb[mode]; j++) data[i + j] &#x3D; v[j] &#x3D; s[j]; &#125; return 0; &#125; void inv_shift_rows(AES_CYPHER_T mode, uint8_t *state) &#123; uint8_t *s &#x3D; (uint8_t *)state; int i, j, r; for (i &#x3D; 1; i &lt; g_aes_nb[mode]; i++) &#123; for (j &#x3D; 0; j &lt; g_aes_nb[mode] - i; j++) &#123; uint8_t tmp &#x3D; s[i]; for (r &#x3D; 0; r &lt; g_aes_nb[mode]; r++) &#123; s[i + r * 4] &#x3D; s[i + (r + 1) * 4]; &#125; s[i + (g_aes_nb[mode] - 1) * 4] &#x3D; tmp; &#125; &#125; &#125; uint8_t inv_sub_sbox(uint8_t val) &#123; return g_inv_sbox[val]; &#125; void inv_sub_bytes(AES_CYPHER_T mode, uint8_t *state) &#123; int i, j; for (i &#x3D; 0; i &lt; g_aes_nb[mode]; i++) &#123; for (j &#x3D; 0; j &lt; 4; j++) &#123; state[i * 4 + j] &#x3D; inv_sub_sbox(state[i * 4 + j]); &#125; &#125; &#125; void inv_mix_columns(AES_CYPHER_T mode, uint8_t *state) &#123; uint8_t y[16] &#x3D; &#123; 0x0e, 0x0b, 0x0d, 0x09, 0x09, 0x0e, 0x0b, 0x0d, 0x0d, 0x09, 0x0e, 0x0b, 0x0b, 0x0d, 0x09, 0x0e &#125;; uint8_t s[4]; int i, j, r; for (i &#x3D; 0; i &lt; g_aes_nb[mode]; i++) &#123; for (r &#x3D; 0; r &lt; 4; r++) &#123; s[r] &#x3D; 0; for (j &#x3D; 0; j &lt; 4; j++) &#123; s[r] &#x3D; s[r] ^ aes_mul(state[i * 4 + j], y[r * 4 + j]); &#125; &#125; for (r &#x3D; 0; r &lt; 4; r++) &#123; state[i * 4 + r] &#x3D; s[r]; &#125; &#125; &#125; int aes_decrypt(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key) &#123; uint8_t w[4 * 4 * 15] &#x3D; &#123; 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x72, 0x7C, 0x01, 0xC8, 0x46, 0x49, 0x37, 0xFF, 0x7E, 0x70, 0x56, 0x9D, 0x1D, 0x14, 0x33, 0xFB, 0x8A, 0xBF, 0x0E, 0x6C, 0xCC, 0xF6, 0x39, 0x93, 0xB2, 0x86, 0x6F, 0x0E, 0xAF, 0x92, 0x5C, 0xF5, 0xC1, 0xF5, 0xE8, 0x15, 0x0D, 0x03, 0xD1, 0x86, 0xBF, 0x85, 0xBE, 0x88, 0x10, 0x17, 0xE2, 0x7D, 0x39, 0x6D, 0x17, 0xDF, 0x34, 0x6E, 0xC6, 0x59, 0x8B, 0xEB, 0x78, 0xD1, 0x9B, 0xFC, 0x9A, 0xAC, 0x99, 0xD5, 0x86, 0xCB, 0xAD, 0xBB, 0x40, 0x92, 0x26, 0x50, 0x38, 0x43, 0xBD, 0xAC, 0xA2, 0xEF, 0x28, 0xEF, 0x59, 0xB1, 0x85, 0x54, 0x19, 0x23, 0xA3, 0x04, 0x21, 0x60, 0x1E, 0xA8, 0x83, 0x8F, 0xAA, 0x03, 0x2A, 0xC3, 0x2F, 0x57, 0x33, 0xE0, 0x8C, 0x53, 0x12, 0x80, 0x92, 0xFB, 0x91, 0x0F, 0x25, 0x82, 0x5C, 0x8C, 0x0A, 0xD5, 0x6F, 0x6C, 0x86, 0x86, 0x7D, 0xEC, 0x14, 0x7D, 0xEC, 0xE3, 0xEC, 0x4C, 0x4D, 0x76, 0xE6, 0x99, 0x22, 0x1A, 0x60, 0x1F, 0x5F, 0xF6, 0x74, 0x62, 0xB3, 0x15, 0x5D, 0x21, 0x14, 0xE4, 0xBB, 0xB8, 0x36, 0xFE, 0xDB, 0xA7, 0x69, 0x08, 0xAF, 0xC5, 0xDA, 0x1D &#125;; &#x2F;* round key *&#x2F; uint8_t s[4 * 4] &#x3D; &#123; 0 &#125;; &#x2F;* state *&#x2F; int nr, i, j; &#x2F;* key expansion *&#x2F; &#x2F;&#x2F; aes_key_expansion(mode, key, w); &#x2F;* start data cypher loop over input buffer *&#x2F; for (i &#x3D; 0; i &lt; len; i +&#x3D; 4 * g_aes_nb[mode]) &#123; &#x2F;* init state from user buffer (cyphertext) *&#x2F; for (j &#x3D; 0; j &lt; 4 * g_aes_nb[mode]; j++) s[j] &#x3D; data[i + j]; &#x2F;* start AES cypher loop over all AES rounds *&#x2F; for (nr &#x3D; g_aes_rounds[mode]; nr &gt;&#x3D; 0; nr--) &#123; &#x2F;* do AddRoundKey *&#x2F; aes_add_round_key(mode, s, w, nr); if (nr &gt; 0) &#123; if (nr &lt; g_aes_rounds[mode]) &#123; &#x2F;* do MixColumns *&#x2F; inv_mix_columns(mode, s); &#125; &#x2F;* do ShiftRows *&#x2F; inv_shift_rows(mode, s); &#x2F;* do SubBytes *&#x2F; inv_sub_bytes(mode, s); &#125; &#125; &#x2F;* save state (cypher) to user buffer *&#x2F; for (j &#x3D; 0; j &lt; 4 * g_aes_nb[mode]; j++) data[i + j] &#x3D; s[j]; &#125; return 0; &#125; int aes_decrypt_ecb(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key) &#123; return aes_decrypt(mode, data, len, key); &#125; int aes_decrypt_cbc(AES_CYPHER_T mode, uint8_t *data, int len, uint8_t *key, uint8_t *iv) &#123; uint8_t w[4 * 4 * 15] &#x3D; &#123; 0 &#125;; &#x2F;* round key *&#x2F; uint8_t s[4 * 4] &#x3D; &#123; 0 &#125;; &#x2F;* state *&#x2F; uint8_t v[4 * 4] &#x3D; &#123; 0 &#125;; &#x2F;* iv *&#x2F; int nr, i, j; &#x2F;* key expansion *&#x2F; aes_key_expansion(mode, key, w); memcpy(v, iv, sizeof(v)); &#x2F;* start data cypher loop over input buffer *&#x2F; for (i &#x3D; 0; i &lt; len; i +&#x3D; 4 * g_aes_nb[mode]) &#123; &#x2F;* init state from user buffer (cyphertext) *&#x2F; for (j &#x3D; 0; j &lt; 4 * g_aes_nb[mode]; j++) s[j] &#x3D; data[i + j]; &#x2F;* start AES cypher loop over all AES rounds *&#x2F; for (nr &#x3D; g_aes_rounds[mode]; nr &gt;&#x3D; 0; nr--) &#123; &#x2F;* do AddRoundKey *&#x2F; aes_add_round_key(mode, s, w, nr); if (nr &gt; 0) &#123; if (nr &lt; g_aes_rounds[mode]) &#123; &#x2F;* do MixColumns *&#x2F; inv_mix_columns(mode, s); &#125; &#x2F;* do ShiftRows *&#x2F; inv_shift_rows(mode, s); &#x2F;* do SubBytes *&#x2F; inv_sub_bytes(mode, s); &#125; &#125; &#x2F;* save state (cypher) to user buffer *&#x2F; for (j &#x3D; 0; j &lt; 4 * g_aes_nb[mode]; j++) &#123; uint8_t p &#x3D; s[j] ^ v[j]; v[j] &#x3D; data[i + j]; data[i + j] &#x3D; p; &#125; &#125; return 0; &#125; int main() &#123; &#x2F;&#x2F;数据 uint8_t buf[] &#x3D; &#123; 0xD1, 0xF7, 0xB4, 0x67, 0x72, 0x1E, 0x25, 0xBA, 0x44, 0x79, 0x2D, 0xC5, 0xFC, 0x9A, 0xCF, 0x00, 0xA9, 0xA8, 0xF9, 0xED, 0x4D, 0x0E, 0x74, 0x61, 0xB8, 0x17, 0x8D, 0x8F, 0xFD, 0x6D, 0x1E, 0x65 &#125;; &#x2F;&#x2F;密钥 uint8_t key[] &#x3D; &#123; 0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x61,0x62,0x63,0x64,0x65,0x66 &#125;; &#x2F;&#x2F;向量 uint8_t iv[] &#x3D; &#123; 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10 &#125;; &#x2F;&#x2F;模式 1-ECB 0-CBC bool ecb_or_cbc &#x3D; 1; &#x2F;&#x2F;加解密 1-加密 0-解密 bool en_or_de &#x3D; 0; &#x2F;&#x2F;ECB 模式加密 if(ecb_or_cbc&amp;&amp;en_or_de) &#123; switch (sizeof(key)) &#123; case 16:aes_encrypt(AES_CYPHER_128, buf, sizeof(buf), key); break; case 24:aes_encrypt(AES_CYPHER_192, buf, sizeof(buf), key); break; case 32:aes_encrypt(AES_CYPHER_256, buf, sizeof(buf), key); break; &#125; &#x2F;&#x2F;打印数据 for (int i &#x3D; 0; i &lt; sizeof(buf); i++) &#123; printf(&quot;0x%02x,&quot;, buf[i] &amp; 0xFF); &#125; &#125; &#x2F;&#x2F;ECB 模式解密 else if(ecb_or_cbc&amp;&amp;(!en_or_de)) &#123; switch (sizeof(key)) &#123; case 16:aes_decrypt(AES_CYPHER_128, buf, sizeof(buf), key); break; case 24:aes_decrypt(AES_CYPHER_192, buf, sizeof(buf), key); break; case 32:aes_decrypt(AES_CYPHER_256, buf, sizeof(buf), key); break; &#125; &#x2F;&#x2F;打印数据 for (int i &#x3D; 0; i &lt; sizeof(buf); i++) &#123; printf(&quot;%c&quot;, (buf[i] &amp; 0xFF)^0x66); &#125; &#125; &#x2F;&#x2F;CBC 模式加密 else if((!ecb_or_cbc)&amp;&amp;en_or_de) &#123; switch (sizeof(key)) &#123; case 16:aes_encrypt_cbc(AES_CYPHER_128, buf, sizeof(buf), key, iv); break; case 24:aes_encrypt_cbc(AES_CYPHER_192, buf, sizeof(buf), key, iv); break; case 32:aes_encrypt_cbc(AES_CYPHER_256, buf, sizeof(buf), key, iv); break; &#125; &#x2F;&#x2F;打印数据 for (int i &#x3D; 0; i &lt; sizeof(buf); i++) &#123; printf(&quot;0x%02x,&quot;, buf[i] &amp; 0xFF); &#125; &#125; &#x2F;&#x2F;CBC 模式解密 else &#123; switch (sizeof(key)) &#123; case 16:aes_decrypt_cbc(AES_CYPHER_128, buf, sizeof(buf), key, iv); break; case 24:aes_decrypt_cbc(AES_CYPHER_192, buf, sizeof(buf), key, iv); break; case 32:aes_decrypt_cbc(AES_CYPHER_256, buf, sizeof(buf), key, iv); break; &#125; &#x2F;&#x2F;打印数据 for (int i &#x3D; 0; i &lt; sizeof(buf); i++) &#123; printf(&quot;%c&quot;, buf[i] &amp; 0xFF); &#125; &#125; printf(&quot;\\n&quot;); return 0; &#125; 以上为ECB和CBC模式的解法.","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"}]},{"title":"TEA算法加密","slug":"TEA算法加密","date":"2023-12-03T11:11:40.834Z","updated":"2023-12-15T11:40:47.743Z","comments":true,"path":"2023/12/03/TEA算法加密/","link":"","permalink":"http://example.com/2023/12/03/TEA%E7%AE%97%E6%B3%95%E5%8A%A0%E5%AF%86/","excerpt":"","text":"TEA” 的全称为”Tiny Encryption Algorithm” 是1994年由英国剑桥大学的David j.wheeler发明的。TEA算法也算是一种微型加密算法的。在安全学领域，TEA（Tiny Encryption Algorithm）是一种分组加密算法.TEA算法使用64位的明文分组和128位的密钥，它使用Feistel分组加密框架，需要进行64轮迭代，但是作者认为32轮已经足够了，所以32轮迭代加密后最后得到的密文就是64位。简单的说就是,TEA加密解密是以原文以8字节（64位bit）为一组，密钥16字节（128位bit）为一组，（char为1字节，int为4字节，double为8字节），该算法加密轮次可变，作者建议为32轮，因为被加密的明文为64位，所以最终加密的结果也是64位.TEA算法的特征是delta值和16字节的密钥（128位）以及32轮迭代以下为tea算法的实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;Windows.h&gt; void Encrypt(long* EntryData, long* Key) &#123; &#x2F;&#x2F;分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组 unsigned long x &#x3D; EntryData[0]; unsigned long y &#x3D; EntryData[1]; unsigned long sum &#x3D; 0; unsigned long delta &#x3D; 0x9E3779B9; &#x2F;&#x2F;总共加密32轮 for (int i &#x3D; 0; i &lt; 32; i++) &#123; sum +&#x3D; delta; x +&#x3D; ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]); y +&#x3D; ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]); &#125; &#x2F;&#x2F;最后加密的结果重新写入到数组中 EntryData[0] &#x3D; x; EntryData[1] &#x3D; y; &#125; void Decrypt(long* EntryData, long* Key) &#123; &#x2F;&#x2F;分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组 unsigned long x &#x3D; EntryData[0]; unsigned long y &#x3D; EntryData[1]; unsigned long sum &#x3D; 0; unsigned long delta &#x3D; 0x9E3779B9; sum &#x3D; delta &lt;&lt; 5; &#x2F;&#x2F;注意这里,sum &#x3D; 32轮之后的黄金分割值. 因为我们要反序解密. &#x2F;&#x2F;总共加密32轮 那么反序也解密32轮 for (int i &#x3D; 0; i &lt; 32; i++) &#123; &#x2F;&#x2F; 先将y解开 然后参与运算在解x y -&#x3D; ((x &lt;&lt; 4) + Key[2]) ^ (x + sum) ^ ((x &gt;&gt; 5) + Key[3]); x -&#x3D; ((y &lt;&lt; 4) + Key[0]) ^ (y + sum) ^ ((y &gt;&gt; 5) + Key[1]); sum -&#x3D; delta; &#125; &#x2F;&#x2F;最后加密的结果重新写入到数组中 EntryData[0] &#x3D; x; EntryData[1] &#x3D; y; &#125; int main() &#123; long Data[3] &#x3D; &#123; 0x44434241,0x48474645,0x0 &#125;; printf(&quot;待加密的数值 &#x3D; %s\\r\\n&quot;, (char*)Data); long key[4] &#x3D; &#123; 0x11223344,0x55667788,0x99AABBCC,0xDDEEFF11 &#125;; &#x2F;&#x2F;Encrypt每次只是加密4字节数组中的两组(也就是每次加密8个字节) 如果你数据多.可以来个for循环来循环加密,但是Entrypt内部还有32次循环,所以速度上还是会有点影响. Encrypt(Data, key); printf(&quot;加密后的数值 &#x3D; %s\\r\\n&quot;, (char*)Data); Decrypt(Data, key); printf(&quot;解密后的数值 &#x3D; %s\\r\\n&quot;, (char*)Data); system(&quot;pause&quot;); &#125; 以上只是普通的tea算法的加密和解密的C语言实现,它采用分组加密,并且使用的是固定的四个128位的密钥,没有更多密钥的生成(轮密钥),只需要知道密文,密钥,delta的值,在仔细观察加密函数的改变即可. xtea这是teapro版 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; &#x2F;* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] *&#x2F; void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0&#x3D;v[0], v1&#x3D;v[1], sum&#x3D;0, delta&#x3D;0x9E3779B9; for (i&#x3D;0; i &lt; num_rounds; i++) &#123; v0 +&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); sum +&#x3D; delta; v1 +&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); &#125; v[0]&#x3D;v0; v[1]&#x3D;v1; &#125; void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0&#x3D;v[0], v1&#x3D;v[1], delta&#x3D;0x9E3779B9, sum&#x3D;delta*num_rounds; for (i&#x3D;0; i &lt; num_rounds; i++) &#123; v1 -&#x3D; (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); sum -&#x3D; delta; v0 -&#x3D; (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0]&#x3D;v0; v[1]&#x3D;v1; &#125; int main() &#123; uint32_t v[2]&#x3D;&#123;1,2&#125;; uint32_t const k[4]&#x3D;&#123;2,2,3,4&#125;; unsigned int r&#x3D;32;&#x2F;&#x2F;num_rounds建议取值为32 &#x2F;&#x2F; v为要加密的数据是两个32位无符号整数 &#x2F;&#x2F; k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); encipher(r, v, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); decipher(r, v, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0; &#125; 相比于普通的tea算法,它增加了轮密钥的生成,即dalta值在加密过程中异或的随机性,在xtea中对delta值的魔改和对于加密函数的位置更改再或者更改以下加密函数,就比如增加一个delta值得异或,但是和tea算法相同的是,都拥有两个加密函数,4个密钥, xxtea这是tea得promax版 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x9e3779b9 #define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) &#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) &#x2F;* Coding Part *&#x2F; &#123; rounds &#x3D; 6 + 52&#x2F;n; sum &#x3D; 0; z &#x3D; v[n-1]; do &#123; sum +&#x3D; DELTA; e &#x3D; (sum &gt;&gt; 2) &amp; 3; for (p&#x3D;0; p&lt;n-1; p++) &#123; y &#x3D; v[p+1]; z &#x3D; v[p] +&#x3D; MX; &#125; y &#x3D; v[0]; z &#x3D; v[n-1] +&#x3D; MX; &#125; while (--rounds); &#125; else if (n &lt; -1) &#x2F;* Decoding Part *&#x2F; &#123; n &#x3D; -n; rounds &#x3D; 6 + 52&#x2F;n; sum &#x3D; rounds*DELTA; y &#x3D; v[0]; do &#123; e &#x3D; (sum &gt;&gt; 2) &amp; 3; for (p&#x3D;n-1; p&gt;0; p--) &#123; z &#x3D; v[p-1]; y &#x3D; v[p] -&#x3D; MX; &#125; z &#x3D; v[n-1]; y &#x3D; v[0] -&#x3D; MX; sum -&#x3D; DELTA; &#125; while (--rounds); &#125; &#125; int main() &#123; uint32_t v[2]&#x3D; &#123;1,2&#125;; uint32_t const k[4]&#x3D; &#123;2,2,3,4&#125;; int n&#x3D; 2; &#x2F;&#x2F;n的绝对值表示v的长度，取正表示加密，取负表示解密 &#x2F;&#x2F; v为要加密的数据是两个32位无符号整数 &#x2F;&#x2F; k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); btea(v, n, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); btea(v, -n, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0; &#125; 这个版本得tea有着更高的保密性,相比于前两种的tea,它改变了主要的加密函数,进行逆向的时候要主要观察加密函数的样子,当加密函数比较乱的时候,可行观察函数的格式,xxtea的加密函数在循环内的格式都是相同,可以使用辨识度搞得字符对内容进行替换,之后再仔细观察.当然,要注意delta值变换的位置,在循环中不受影响的函数(比如轮密钥的生成),还有加密解密时函数的顺序.","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"}]},{"title":"IDA逆向","slug":"IDA逆向","date":"2023-12-03T03:12:14.524Z","updated":"2023-12-03T03:22:38.236Z","comments":true,"path":"2023/12/03/IDA逆向/","link":"","permalink":"http://example.com/2023/12/03/IDA%E9%80%86%E5%90%91/","excerpt":"","text":"哈希{SHA-1(信息摘要不可逆)}import hashlib def sha1_bruteforce(target_hash, password_length=6, charset=\"abcdefghijklmnopqrstuvwxyz0123456789\"): import itertools # 生成所有可能的密码组合 passwords = itertools.product(charset, repeat=password_length) for password in passwords: # 将密码组合连接成字符串 password_str = ''.join(password) # 计算密码的SHA-1哈希值 hashed_password = hashlib.sha1(password_str.encode()).hexdigest() # 检查是否匹配目标哈希值 if hashed_password == target_hash: return password_str # 返回找到的密码 return None # 如果未找到匹配的密码 # 示例用法 target_hash = \"a94a8fe5ccb19ba61c4c0873d391e987982fbbd3\" # 替换为目标SHA-1哈希值 result = sha1_bruteforce(target_hash) if result: print(f\"成功找到密码: &#123;result&#125;\") else: print(\"未找到匹配的密码\") SHA-1的算法输出数据固定长度为20个字节.MD5算法是一种广泛使用的Hash加密算法。它的输出为128位二进制数，通常用32位十六进制数表示。 base64的变表解密import base64 STANDARD_ALPHABET = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' CUSTOM_ALPHABET = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' #变换后的索引表 DECODE_TRANS = bytes.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET) def decode(input): return base64.b64decode(input.translate(DECODE_TRANS)).decode() enstr = \"MkJ5c0J2c3Z\" #输入待解码的值 destr = decode(enstr) print(destr)","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"}]},{"title":"逆向","slug":"逆向","date":"2023-11-26T02:40:22.288Z","updated":"2023-11-30T11:29:56.780Z","comments":true,"path":"2023/11/26/逆向/","link":"","permalink":"http://example.com/2023/11/26/%E9%80%86%E5%90%91/","excerpt":"","text":"ASCII码表 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUL 32 (space) 64 @ 96 、 1 SOH 33 ！ 65 A 97 a 2 STX 34 ” 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 ‘ 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 &#x2F; 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 \\ 124 | 29 GS 61 &#x3D; 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ~ 31 US 63 ? 95 — 127 DEL 寄存器通用寄存器eax寄存器，eax的低16位ax寄存器，ax的高8位ah寄存器和低8位al寄存器。ebx寄存器，bx寄存器,bh寄存器，bl寄存器。ecx寄存器，cx寄存器,ch寄存器，cl寄存器。edx寄存器，dx寄存器,dh寄存器，dl寄存器。esi寄存器，esi的低16位si寄存器。edi寄存器，edi的低16位di寄存器。ebp寄存器，ebp的低16位bp寄存器。esp寄存器，esp的低16位sp寄存器。IA-32处理器中的段寄存器（CS&#x2F;DS&#x2F;ES&#x2F;SS&#x2F;FS&#x2F;GS）用于保存16位宽的段选择符（segment selector）。要访问存储器中的特定段，对应的段选择符必须要加载到正确的段寄存器中。 IOPL称为I&#x2F;O特权标志位（I&#x2F;O Privilege Level）。IOPL用2个bit来表示，也称为I&#x2F;O特权字段，表示要求执行I&#x2F;O指令的特权级。如果当前的特权级在数值上小于等于IOPL的值，那么该I&#x2F;O指令可执行，否则将发生一个保护异常。 NT称为嵌套任务标志位（Nested Task）。用来控制中断返回指令IRET的执行。具体规定如下： 当NT&#x3D;0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断和返回操作；当NT&#x3D;1，通过任务转换实现中断返回； RF称为重启动标志位（Restart Flag）。用来控制是否接受调试故障。规定：RF&#x3D;0时，表示”接受”调试故障，否则拒绝。在成功执行完一条指令后，处理机把RF置为0，当接收到一个非调试故障时，处理机将它置为1。 x64寄存器 寄存器 状态 形式 RAX 易失的 返回值寄存器 RCX 易失的 第一个整型参数 RDX 易失的 第二个整型参数 R8 易失的 第三个整型参数 R9 易失的 第四个整型参数 R10:R11 易失的 必须根据需要由调用方保留；在 syscall&#x2F;sysret 指令中使用 R12:R15 非易失的 必须由被调用方保留 RDI 非易失的 必须由被调用方保留 RSI 非易失的 必须由被调用方保留 RBX 非易失的 必须由被调用方保留 RBP 非易失的 可用作帧指针；必须由被调用方保留 RSP 非易失的 堆栈指针 XMM0 易失的 第一个 FP 参数 XMM1 易失的 第二个 FP 参数 XMM2 易失的 第三个 FP 参数 XMM3 易失的 第四个 FP 参数 XMM4:XMM5 易失的 必须根据需要由调用方保留 XMM6:XMM15 非易失的 必须根据需要由被调用方保留。","categories":[],"tags":[]},{"title":"反汇编","slug":"反汇编","date":"2023-11-13T11:00:50.713Z","updated":"2023-11-30T11:28:58.860Z","comments":true,"path":"2023/11/13/反汇编/","link":"","permalink":"http://example.com/2023/11/13/%E5%8F%8D%E6%B1%87%E7%BC%96/","excerpt":"","text":"void sub_49C3E0(char *arg_0, int arg_4) &#123; char var_20[26] = &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'&#125;; char var_44[26] = &#123;'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'&#125;; int var_50 = 0;//计时器 int var_5C; int var_68; while (arg_0[var_50] != '\\0') &#123; if (arg_0[var_50] >= 'a' &amp;&amp; arg_0[var_50] &lt;= 'z') &#123; var_5C = arg_0[var_50] - 'a'; var_68 = (var_5C + arg_4 + 26) % 26; arg_0[var_50] = var_20[var_68]; &#125; else if (arg_0[var_50] >= 'A' &amp;&amp; arg_0[var_50] &lt;= 'Z') &#123; var_5C = arg_0[var_50] - 'A'; var_68 = (var_5C + arg_4 + 26) % 26; arg_0[var_50] = var_44[var_68]; &#125; else &#123; &#125; var_50++; &#125; return; &#125; int main() &#123; char *str; int ptr; str = (char *)malloc(100 * sizeof(char)); printf(\"please input a string:\\n\"); scanf(\"%s\",str); printf(\"please input a number:\\n\"); scanf(\"%d\",&amp;ptr); sub_49C3E0(str,ptr); printf(\"%s\",str); free(str); return 0; &#125; python逆向Download Python | Python.org这是python的官网,从这里现在最先版本的python.运行安装程序，确保选择了“Add Python x.x to PATH”选项，这会自动将Python添加到系统环境变量。 手动添加Python和pip到环境变量（如果未自动添加）: 右键点击“此电脑”或“我的电脑”，选择“属性”。 点击“高级系统设置”。 在弹出窗口中，点击“环境变量”按钮。 在“系统变量”部分，找到名为“Path”的变量，点击“编辑”。 点击“新建”，然后添加Python和pip的安装路径（通常是 C:\\Users\\YourUsername\\AppData\\Local\\Programs\\Python\\PythonXX 和 C:\\Users\\YourUsername\\AppData\\Local\\Programs\\Python\\PythonXX\\Scripts）。 确认并关闭所有窗口。使用pip安装uncompyle6。运行以下命令： pip install uncompyle6这个可以把.pyc还原为.py","categories":[],"tags":[]},{"title":"汇编语言","slug":"汇编语言","date":"2023-11-04T12:43:19.166Z","updated":"2023-12-02T10:39:03.919Z","comments":true,"path":"2023/11/04/汇编语言/","link":"","permalink":"http://example.com/2023/11/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"汇编语言由以下三类组成:1,汇编指令(机器码的助记符){核心:决定特性}2,伪指令(由编译器执行)3,其他符号(由编译器识别) CPU对储存器的读写:1,地址信息2,控制信息3,数据信息 (1)汇编指令是机器指令的助记符,同机器指令一一对应。(2)每一种CPU都有自己的汇编指令集。(3)CPU可以直接使用的信息在存储器中存放。(4)在存储器中指令和数据没有任何区別,都是二进制信息。 CPU工作原理(寄存器)bim源程序汇编指令不区分大小写. mov 我们前面讲到,8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址,送入地址加法器合成物理地址。这里,需要看一下,是什么部件提供段地址。段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器:CS、DS、SS、ES。当 8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址. 8086CPU的工作过成从CS:IP指向内存单元读取指令,读取的指令进入指令缓冲区.Debug是DOS,WINdows提供的实模式(8086)程序的调试工具.用 Debug 的R 命令查看,改变CPU 寄存器的内容:用 Debug 的 D 命令查看内存中的内容:用 Debug 的E命令改写内存中的内容;用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令:用 Debug 的T命令执行一条机器指令: 汇编语言寄存器(内存访问)内存中文字的储存任何两个地址连续的内存单元,N号 单元和N+1号单元,可以将它们看 成两个内存单元,也可以看成一个 地址为N的字单元中的高位字节单元 和低位字节单元。CPU要读取一个内存单元的时候,必须 先给出这个内存单元的地址;在8086PC中,内存地址由段地址和偏移 地址组成。8086CPU中有一个RS寄存器,通常用来 存放要访问的数据的段地址。mov al,[0]已知的mov指令可完成的两种传送功能:(1)将数据直接送入寄存器:(2)将一个寄存器中的内容送入另一个寄存器中.除此之外,mov 指令还可以将一个内存 单元中的内容送入一个寄存器。 mov bx,1000hmov ds,bxmov al,[0] 从哪个内存单元送到哪个寄存器中呢?mov指令的格式:mov 寄存器名,内存单元地址“[…]”表示一个内存单元,“[…]”中的0表示内存单元的偏移地址。那么内存单元的段地址是多少呢? 想要在段寄存器中存储数据要通过通用寄存器. 字的传送已学Mov指令的几种形式:mou 寄存器,数据mov 寄存器,寄存器mov 寄存器,内存单元mov 内存单元,寄存器mov 段寄存器,寄存器add 寄存器,数据add 寄存器,寄存器add 寄存器,内存单元add 内存单元,寄存器sub 寄存器,数据sub 寄存器,寄存器sub 寄存器,内存单元sub 内存单元,寄存器 数据段和栈基本操作:入栈和出栈.push入栈pop出栈 换个角度看:任意时刻,SS:SP指向栈顶元素,当栈为空的时 候,栈中没有元素,也就不存在栈顶元素所以SS:SP只能指向栈的最底部单元下面的单元, 该单元的偏移地址为栈最底部的字单元的偏移地址+2栈最底部字单元的地址为1000:000E,所以栈空时, SP&#x3D;0010H。 push和pop指令的格式(2)Opush 段寄存器:将一个段寄存器中的数据入栈opop段寄存器:出栈,用一个段寄存器接收出栈的数据例如:push dspop es用栈来暂存以 后需要恢复的寄存器中的内容时,出栈 的顺序要和入栈的顺序相反,因为最后 入栈的寄存器的内容在栈顶,所以在恢 复时,要最先出栈。结论push、pop实质上就是一种内存传送指令, 可以在寄存器和内存之间传送数据,与mov指令不同的是,push和pop指令访问的内存单元的地址不是在指令中给出的,而是由SS:SP指出的. 将一段内存当作栈段,仅仅是我们在编 程时的一种安排,CPU 并不会由于这种 安排,就在执行push、pop等栈操作指令 时就自动地将我们定义的栈段当作栈空 间来访问。 我们可以将一段内存定义为一个段,用 一个段地址指示段,用偏移地址访问段 内的单元。这完全是我们自己的安排。1,我们可以用一个段存放数据,将它定义 为“数据段”;2,我们可以用一个段存放代码,将它定义 为“代码段”;3,我们可以用一个段当作栈,将它定义为 “栈段”; 标号第一个标号指代了一个地址。codesg:放在segment的前面,作为一个段的名称,这个段的名称最终将被编译、连接程序处理为一个段的段地址。 程序的结构任务:编程运算 2^3。定义一个段实现处理任务程序结束段与段寄存器关联 汇编程序assume cs:abcabc segmentmov ax,2add ax,axadd ax,axabc endsend DOS是一个单任务操作系统。如一个程序P2在可执行文件中,则必须有一个正在运行的程序P1,将P2从可执行文件中加载入内存后,将CPU的控制权交给P2,P2才能得以运行。P2开始运行后,P1暂停运行.而当P2运行完毕后,应该将CPU的控制权交还给使它得以运行的程序P1,此后,P1继续运行.我们的程序没有像显示器输出任何信息程序只是做了一些将数据送入寄存器和加法的操作,而这些事情,我们不可能从显示屏上看出来。程序执行完成后,返回,屏幕上再次出现操作系统的提示符。 编译连和接的作用连接的作用有以下几个:当源程序很大时,可以将它分为多个源程序文件来编译,每个源程序编译成为目标文件后,再用连接程序将它们连接到一起,生成一个可执行文件;程序中调用了某个库文件中的子程序,需要将这个库文件和该程序生成的目标文件连接到一起,生成一个可执行文件;一个源程序编译后,得到了存有机器码的目标文件,目标文件中的有些内容还不能直接用来生成可执行文件,连接程序将这此内容处理为最终的可执行信息。所以,在只有一个源程序文件,而又不需要调用某个库中的子程序的情况下,也必须用连接程序对目标文件进行处理,生成可执行文件。注意,对于连接的过程,可执行文件是我们要得到的最终结果。 寄存器段地址和偏移地址是一种用来表示内存单元的物理地址的方法，它们由两个16位的二进制数组合而成，分别存放在段寄存器和通用寄存器中。段寄存器有6个，分别是CS（代码段寄存器），DS（数据段寄存器），ES（附加段寄存器），SS（堆栈段寄存器），FS（附加段寄存器），GS（附加段寄存器）。通用寄存器有8个，分别是AX（累加器），BX（基址寄存器），CX（计数器），DX（数据寄存器），SI（源变址寄存器），DI（目的变址寄存器），BP（基址指针寄存器），SP（堆栈指针寄存器）。段地址和偏移地址的组合方式有以下几种： 段地址:偏移地址，例如CS:IP，表示代码段寄存器中的值作为段地址，指令指针寄存器中的值作为偏移地址，用来指向下一条要执行的指令的物理地址。 段寄存器:[通用寄存器]，例如DS:[BX]，表示数据段寄存器中的值作为段地址，基址寄存器中的值作为偏移地址，用来指向一个数据的物理地址。 段寄存器:[通用寄存器+常数]，例如ES:[DI+10]，表示附加段寄存器中的值作为段地址，目的变址寄存器中的值加上一个常数作为偏移地址，用来指向一个数据的物理地址。 段寄存器:[通用寄存器+通用寄存器]，例如SS:[BP+SI]，表示堆栈段寄存器中的值作为段地址，基址指针寄存器中的值加上源变址寄存器中的值作为偏移地址，用来指向一个数据的物理地址。 源程序操作系统操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统,都要提供一个称shell (外壳)的程序,用戶(操作人员)使用这个程序来操作计算机系统互作。DOS中有一个程序command.com,这个程序在 DOS 中称为命令解释器,也就是DOS系统的shell。程序加载后,ds中存放着程序所在内存区的 段地址,这个内存区的偏移地址为0,则程序所在的内存区的地址为:ds:0;这个内存区的前256个字节中存放的是PSP,dos用来和程序进行通信。从256字节处向后的空间存放的是程序.总结(续)所以,我们从ds中可以得到PSP的段地址SA,PSP的偏移地址为0,则物理地址为SA×16+0。因为PSP占256(100H)字节,所以程序的物理地址是:SAX16+0+256&#x3D;SA×16+16×16&#x3D;(SA+16) ×16+0可用段地址和偏移地址表示为:SA+10:0。 需要注意的是,在DOS中运行程序时,是command将程序加载入内存;所以程序运行结束后返回到command中,而在这里是debug将程序加载入内存,所以程序运行结束后要返回到Debug中。我们在DOS中用“Debug 1.exe”运行Debug对1.exe进行跟踪时,程序加载的顺序是:command加载Debug,Debug加载1.exe。返回的顺序是:从l.exe中的程序返回到Debug,从Debug返回到command。 汇编语言常见指令加汇编语言中的 add 指令用于将两个操作数相加，并将结果存储在目标操作数中。add 指令的语法如下： add 目标, 源 这里，目标 是将存储加法结果的操作数，源 是将与目标操作数相加的操作数。目标 和 源 可以是寄存器或内存位置。 减汇编语言中的 sub 指令用于从目标操作数中减去源操作数，并将结果存储在目标操作数中。sub 指令的语法如下： sub 目标, 源 这里，目标 是将存储减法结果的操作数，源 是将从目标操作数中减去的操作数。目标 和 源 可以是寄存器或内存位置. 乘汇编语言中的 mul 指令用于执行无符号乘法运算。mul 指令的语法如下： mul 源 这里，源 是与累加器（AX，EAX 或 RAX，取决于操作数的大小）一起进行乘法运算的操作数。结果将存储在 DX:AX，EDX:EAX 或 RDX:RAX 中，取决于操作数的大小。例如，以下代码将 eax 寄存器中的值与 ebx 寄存器中的值相乘，并将结果存储在 edx:eax 中： mov eax, ebx mul ecx 在这个例子中，eax 中的值与 ecx 中的值相乘，结果存储在 edx:eax 中。 除汇编语言中的 div 指令用于执行无符号除法运算。div 指令的语法如下： div 源 这里，源 是作为除数的操作数。被除数是累加器（AX，EAX 或 RAX，取决于操作数的大小）或 DX:AX，EDX:EAX 或 RDX:RAX，取决于操作数的大小。商将存储在累加器中，余数将存储在 DX，EDX 或 RDX 中。例如，以下代码将 eax 寄存器中的值除以 ebx 寄存器中的值，并将商存储在 eax 中，余数存储在 edx 中： mov eax, ebx div ecx 在这个例子中，eax 中的值除以 ecx 中的值，商存储在 eax 中，余数存储在 edx 中。 除了 div 指令，汇编语言还有一个用于执行带符号除法的 idiv 指令。idiv 指令的语法如下： idiv 源 这里，源 是作为除数的操作数。被除数是累加器（AX，EAX 或 RAX，取决于操作数的大小）或 DX:AX，EDX:EAX 或 RDX:RAX，取决于操作数的大小。商将存储在累加器中，余数将存储在 DX，EDX 或 RDX 中。例如，以下代码将 eax 寄存器中的值除以 ebx 寄存器中的值，并将商存储在 eax 中，余数存储在 edx 中： mov eax, ebx idiv ecx 在这个例子中，eax 中的值除以 ecx 中的值，商存储在 eax 中，余数存储在 edx 中。idiv 指令与 div 指令的主要区别在于，idiv 执行的是带符号的除法，而 div 执行的是无符号的除法。 跳转指令JMP ;无条件跳转 JE ;&#x2F;&#x2F;等于则跳转 同JZJNE ;&#x2F;&#x2F;不等于则跳转 同JNZJA ;&#x2F;&#x2F;无符号大于则跳转JNA ;&#x2F;&#x2F;无符号不大于则跳转JAE ;&#x2F;&#x2F;无符号大于等于则跳转 同JNBJNAE ;&#x2F;&#x2F;无符号不大于等于则跳转 同JBJB ;&#x2F;&#x2F;无符号小于则跳转JNB ;&#x2F;&#x2F;无符号不小于则跳转JBE ;&#x2F;&#x2F;无符号小于则跳转 同JNAJNBE ;&#x2F;&#x2F;无符号不小于等于则跳转 同JAJG ;&#x2F;&#x2F;有符号大于则跳转JNG ;&#x2F;&#x2F;有符号不大于则跳转JGE ;&#x2F;&#x2F;有符号大于等于则跳转 同JNLJNGE ;&#x2F;&#x2F;有符号不大于等于则跳转 同JLJL ;&#x2F;&#x2F;有符号小于则跳转JNL ;&#x2F;&#x2F;有符号不小于则跳转JLE ;&#x2F;&#x2F;有符号小于等于则跳转 同JNGJNLE ;&#x2F;&#x2F;有符号不小于等于则跳转 同JGJZ ;&#x2F;&#x2F;为零则跳转JNZ ;&#x2F;&#x2F;不为零则跳转JS ;&#x2F;&#x2F;为负则跳转JNS ;&#x2F;&#x2F;不为负则跳转JC ;&#x2F;&#x2F;进位则跳转JNC ;&#x2F;&#x2F;不进位则跳转JO ;&#x2F;&#x2F;溢出则跳转JNO ;&#x2F;&#x2F;不溢出则跳转JP ;&#x2F;&#x2F;为偶则跳转JNP ;&#x2F;&#x2F;不为偶则跳转JPE ;&#x2F;&#x2F;奇偶位置位则跳转 同JPJPO ;&#x2F;&#x2F;奇偶位复位则跳转 同JNP Test指令test指令用于两个操作数的按位AND运算，并根据结果设置标志寄存器，结果本身不会写回到目的操作数。(1) AND 运算结果为0时， ZF(zero flag)置位(2) test可以影响CF，OF，PF，SF，ZF标志位(3) 两个操作数相等,同时为0时,AND 结果为0,此时ZF置位。例如test和je的连用 Test eax,eax je some_address mov系列指令MOVSX说明:带符号扩展传送指令符号扩展的意思是,当计算机存储某一个有符号数时,符号位位于该数的第一位,所以，当扩展一个负数的时候需要将扩展的高位全赋为1.对于正数而言，符号扩展和零扩展MOVZX是一样的，将扩展的高位全赋为0. MOVZX功能:将8位或16位的OPS零扩展为16位或32位,在传给OPD.格式: MOVZX OPD,OPS 说明:所谓零扩展,就是把新扩展的高位字节填0,这可以保证无符号数扩展后还是原来的无符号数.至于什么时候用符号扩展,什么时候用零扩展,视程序中是用带符号数还是无符 号数操作而定.样列： movzx edi,bx ; movzx 扩展高位为0，并把其赋值到edi movsb movsw movsd 指令详解 这三个指令，都是数据传送指令,都是从源地址向目的地址传送数据。 16位模式下: 源地址是`DS:SI`,目的地址是`ES:DI` 32位模式下: 源地址是`DS:ESI`,目的地址是`ES:EDI` 注意:在传送完成之后，`SI`和`DI`(或者`ESI`和`EDI`)会增加或者减小. 当`DF`=0时，表示正向传送，传送之后`SI`和`DI`(或者`ESI`和`EDI`)的值会增加; 当`DF`=1时，表示反向传送，传送之后`SI`和`DI`(或者`ESI`和`EDI`)的值会减小; 区别: `MOVSB`:传送一个字节，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`1`. `MOVSW`:传送一个字，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`2`. `MOVSD`:传送一个双字，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`4`. 单纯的`movsb/ movsw/ movsd`只能执行一次，如果希望处理器自动地反复执行，可以加上指令前缀`rep`;在寄存器`CX`（16位模式）或者`ECX`（32位模式）中设置传送的次数。当`CX`/`ECX`不等于0时，则执行`movsb/ movsw/ movsd`,执行后，`CX`/`ECX`的值减一，直到减为0为止. rep stosd循环从lea edi,EBP+arg_0开始,到rep stosd结束.EDI中存入的是循环操作的起始地址,ECX存入的是循环次数,EAX是循环填入的值.这一段的操作就是从EBP+var_40处开始,循环十次,向下依次填入CCCCCCCC,写入的长度由EAX决定,32位. lea指令lea eax，addr就是将表达式addr的值放入eax寄存器，示例如下：lea eax,401000h; 将值401000h写入eax寄存器中lea指令右边的操作数表示一个精指针，上述指令和mov eax，401000h是等价的2、lea eax，dword ptr ebx;将ebx的值赋值给eax3、lea eax，c；其中c为一个int型的变量，该条语句的意思是把c的地址赋值给eax； 在汇编语言中，db 不是寄存器，而是一种伪操作命令。db是 “define byte” 的缩写，它用于定义一个或多个字节的数据。db 指令后面可以跟一个或多个逗号分隔的数字、字符或符号，每个数字、字符或符号都会被汇编器转化为一个字节的机器码，并存储在指令地址后的内存中。例如，在代码 string db &#39;Hello,World!$&#39; 中，db 定义了一个名为 string 的字符串，其中每个字符都被转化为一个字节的机器码。这是汇编语言中的一种基本操作，用于在内存中存储数据。请注意，尽管 db 可以用于定义数据，但它本身并不是寄存器。寄存器是 CPU 中的一种特殊类型的存储器，用于存储正在处理的数据和指令。在汇编语言中，寄存器通常由特定的名称或代码来表示，如 ax、bx、cx、dx 等。每种寄存器都有其特定的用途和功能。例如，ax 寄存器通常用于存储算术和逻辑操作的结果。总的来说，db 和寄存器是两种不同的概念，各自在汇编语言中扮演着不同的角色. DOS功能的调用以下是一些常用的DOS功能调用:1号功能调用：键盘输入并显示2号功能调用：屏幕显示一个字符5号功能调用：打印输出6号功能调用：直接输入、输出单字符8号功能调用：键盘输入但不显示输入字符9号功能调用：屏幕显示字符串0AH号功能调用：字符串输入4CH号功能调用：返回DOS操作系统 在汇编语言中，我们可以通过软中断（int）指令来调用DOS功能。软中断是一种特殊的指令，它可以触发中断处理程序的执行。在DOS中，我们通常使用int 21h来调用DOS功能。 在调用DOS功能之前，我们需要先将功能号存储到ah寄存器中。例如，如果我们想要调用9号功能（显示字符串），我们可以先将9存储到ah寄存器中。然后，我们可以通过int 21h指令来调用这个功能。 以下是一个示例，展示了如何在汇编语言中调用DOS功能： data segment ;数据段 string db &#39;Hello,World!$&#39; ;定义一个名为string的字符串 data ends code segment ;代码段 assume cs:code,ds:data start: mov ax,data ;获取段基址 mov ds,ax ;将段基址送入寄存器 mov dx,offset string ;获取string的偏移地址 mov ah,9 ;调用9号DOS功能（显示字符串） int 21h ;中断指令，调用用户程序，执行ah中设置的09h号功能 mov ah,4ch ;功能号4ch表示从用户程序返回操作系统，结束程序 int 21h ;中断指令，调用用户程序，执行ah中设置的4ch号功能 code ends end start 在这个示例中，我们首先将数据段的基址和string的偏移地址加载到寄存器中。然后，我们将9（显示字符串的功能号）存储到ah寄存器中，并通过int 21h指令来调用这个功能。最后，我们将4ch（结束程序的功能号）存储到ah寄存器中，并通过int 21h指令来调用这个功能。这就是在汇编语言中调用DOS功能的基本步骤。 int 21h原理 在汇编语言中，INT 21H是一条中断指令，用于调用DOS操作系统的功能。这条指令的作用是将寄存器AH中的值作为参数传递给DOS操作系统的中断服务程序，从而实现对DOS功能的调用。 在DOS中，AH寄存器的不同取值对应不同的功能。例如，AH=01H表示在屏幕上输出一个字符，AH=02H表示在屏幕上输出一个字符串等。 调用DOS功能的过程通常包括以下步骤： 将系统功能号送到寄存器AH中； 将入口参数送到指定的寄存器中； 用INT 21H指令执行功能调用； 根据出口参数分析功能调用执行情况。 例如，如果我们想要在显示器上显示一个字符串，我们可以使用以下指令： MOV AH,09H INT 21H 在这个例子中，我们首先将09（显示字符串的功能号）存储到AH寄存器中，然后通过INT 21H指令来调用这个功能。这就是在汇编语言中调用DOS功能的基本步骤。 在一次INT 21H指令调用中，AH寄存器只能存储一个功能号。这是因为AH寄存器的大小为8位，也就是一个字节。每个功能号都对应一个唯一的8位二进制数，因此AH寄存器一次只能存储一个功能号。如果你想要调用多个DOS功能，你需要分别进行多次INT 21H指令调用。每次调用前，你需要将相应的功能号存储到AH寄存器中，然后执行INT 21H指令。例如，如果你首先想要显示一个字符串（功能号为09H），然后结束程序（功能号为4CH），你可以使用以下指令： MOV AH,09H INT 21H MOV AH,4CH INT 21H 在这个例子中，我们首先将09（显示字符串的功能号）存储到AH寄存器中，然后通过INT 21H指令来调用这个功能。然后，我们将4CH（结束程序的功能号）存储到AH寄存器中，并通过INT 21H指令来调用这个功能。这就是在汇编语言中调用多个DOS功能的基本步骤。 多次调用DOS功能 在汇编语言中，如果你想要多次使用DOS功能，你可以在代码中多次调用INT 21H指令。每次调用前，你需要将相应的功能号存储到AH寄存器中。 以下是一个示例，展示了如何在汇编语言中多次调用DOS功能： data segment ;数据段 string1 db &#39;Hello,World!$&#39; ;定义一个名为string1的字符串 string2 db &#39;Goodbye,World!$&#39; ;定义一个名为string2的字符串 data ends code segment ;代码段 assume cs:code,ds:data start: mov ax,data ;获取段基址 mov ds,ax ;将段基址送入寄存器 mov dx,offset string1 ;获取string1的偏移地址 mov ah,9 ;调用9号DOS功能（显示字符串） int 21h ;中断指令，调用用户程序，执行ah中设置的09h号功能 mov dx,offset string2 ;获取string2的偏移地址 mov ah,9 ;调用9号DOS功能（显示字符串） int 21h ;中断指令，调用用户程序，执行ah中设置的09h号功能 mov ah,4ch ;功能号4ch表示从用户程序返回操作系统，结束程序 int 21h ;中断指令，调用用户程序，执行ah中设置的4ch号功能 code ends end start 在这个示例中，我们首先将数据段的基址加载到寄存器中。然后，我们将string1和string2的偏移地址分别加载到寄存器中，并分别调用9号功能（显示字符串）。最后，我们调用4CH号功能（结束程序）。这就是在汇编语言中多次调用DOS功能的基本步骤。 花指令花指令：目的是干扰ida和od等软件对程序的静态分析。使这些软件无法正常反汇编出原始代码。 常用的两类反汇编算法：1.线性扫描算法:逐行反汇编（无法将数据和内容进行区分）2.递归行进算法:按照代码可能的执行顺序进行反汇编程序。 call指令：将下一条指令地址压入栈，再跳转执行ret指令：将保存的地址取出，跳转执行 寻址方式操作数的地址可以直接给出，也可以通过寄存器或内存中的值计算出来。汇编语言的寻址操作有以下几种： 立即寻址：操作数直接包含在指令中，紧跟在操作码之后的寻址方式称为立即寻址方式，把该操作数称为立即数。例如，mov ax, 1234h就是一个立即寻址的例子，其中1234h是一个立即数。寄存器寻址：操作数直接包含在寄存器中，由指令指定寄存器号的寻址方式。例如，mov ax, bx就是一个寄存器寻址的例子，其中ax和bx都是寄存器。直接寻址：操作数的有效地址直接包含在指令中的寻址方式。有效地址存放在代码段的指令操作码之后，但操作数本身在存储器中，所以必须先求出操作数的物理地址。这种寻址方式常用于存取简单变量。例如，mov ax, [1000h]就是一个直接寻址的例子，其中1000h是一个有效地址。寄存器间接寻址：操作数的有效地址存放在一个寄存器中，由指令指定该寄存器的寻址方式。例如，mov ax, [bx]就是一个寄存器间接寻址的例子，其中bx是一个寄存器，存放了操作数的有效地址。寄存器相对寻址：操作数的有效地址由一个寄存器中的值加上一个偏移量得到的寻址方式。例如，mov ax, [bx+10h]就是一个寄存器相对寻址的例子，其中bx是一个寄存器，10h是一个偏移量，它们相加得到操作数的有效地址。基址变址寻址：操作数的有效地址由两个寄存器中的值相加得到的寻址方式。例如，mov ax, [bx+si]就是一个基址变址寻址的例子，其中bx和si都是寄存器，它们相加得到操作数的有效地址。相对基址变址寻址：操作数的有效地址由两个寄存器中的值相加再加上一个偏移量得到的寻址方式。例如，mov ax, [bx+si+10h]就是一个相对基址变址寻址的例子，其中bx和si都是寄存器，10h是一个偏移量，它们相加得到操作数的有效地址。 自增自减inc自增指令dec自减指令这两个命令只有一个操作位. 逻辑位移shl是逻辑左移指令,将目的操作数的每位左移,使用源操作数决定要位移的数目.最高位复制到进位标志中,最低位以0填充(与sal相同).shr是右移指令,将目的操作数中的每一位右移,使用源操作数决定移位的数目.最高位以0填充,最低位复制到进位标志中.sal是算数左移,将目的操作数中的每一位左移,源操作数决定移位的数目.最高位复制到标志位中,最低位以0填充.sar是算数右移,将目的操作数中的每一位右移,源操作数决定位移数目,最低为复制到进位标志中,最高位保持原值.sar指令通常用于有符号数操作.cdq是双字节扩展到8字节. 汇编语言指令的一些区别复杂指令集计算机（CISC）： CISC架构的主要特点是其指令集的复杂性。这些指令集包含许多不同的指令，每个指令都有不同的长度和复杂的操作。CISC架构的目标是通过减少程序中的指令数量来提高效率。这是通过创建可以执行多个低级操作的复杂指令来实现的。例如，Intel的x86架构就是CISC的一个例子。 精简指令集计算机（RISC）： 与CISC相反，RISC架构的目标是简化指令集。RISC处理器的每个指令通常只执行一个低级操作，如加载存储器，执行算术操作，或者跳转到新的代码位置。这意味着在RISC架构中，执行同样的任务可能需要更多的指令，但每个指令的执行速度更快。ARM和MIPS架构就是RISC的例子。 MOV：这是最常见的传送指令，用于将源操作数的值复制到目标操作数。例如，MOV AX, 10 将值 10 复制到寄存器 AX。PUSH 和 POP：这两个指令用于向堆栈推送和弹出数据。例如，PUSH AX 将 AX 寄存器的内容推送到堆栈，而 POP AX 将堆栈顶部的值弹出到 AX 寄存器。LEA：Load Effective Address 指令用于将有效地址加载到寄存器。例如，LEA AX, [BX+SI] 将 BX 寄存器和 SI 寄存器的和加载到 AX 寄存器。XCHG：Exchange 指令用于交换两个操作数的值。例如，XCHG AX, BX 将 AX 和 BX 寄存器的值交换。正在为你生成答案… 在汇编语言中，标志寄存器用于存储和反映 CPU 的状态信息。以下是一些常见的标志位： **零标志 (ZF)**：当算术或逻辑操作的结果为零时，该标志被设置。 **符号标志 (SF)**：当算术或逻辑操作的结果为负时，该标志被设置。 **进位标志 (CF)**：当算术操作导致进位或借位时，该标志被设置。 **溢出标志 (OF)**：当算术操作导致正溢出或负溢出时，该标志被设置。 **奇偶标志 (PF)**：当算术或逻辑操作的结果中 1 的个数为偶数时，该标志被设置。 **辅助进位标志 (AF)**：当算术操作导致四位二进制码的进位或借位时，该标志被设置。 **方向标志 (DF)**：该标志用于字符串操作。当 DF 为 0 时，字符串操作从低地址向高地址进行；当 DF 为 1 时，字符串操作从高地址向低地址进行。 **中断标志 (IF)**：当该标志被设置时，CPU 将响应外部中断；当该标志被清除时，CPU 将忽略外部中断。 **陷阱标志 (TF)**：当该标志被设置时，CPU 将在执行每条指令后产生一个中断，通常用于调试。 这些标志位通常在特定的操作中使用，例如字符串操作、中断处理和调试等 这些标志位通常在条件跳转或循环指令中使用，例如 JZ（Jump if Zero）、JNZ（Jump if Not Zero）、JC（Jump if Carry）、JNC（Jump if Not Carry）等在x86平台中，标志寄存器被称为EFLAGS寄存器。这是一个32位的寄存器，包含了一些用于反映CPU状态的标志位。以下是一些主要的标志位： **进位标志 (CF)**：位0，当算术操作导致进位或借位时，该标志被设置。 **奇偶标志 (PF)**：位2，当算术或逻辑操作的结果中 1 的个数为偶数时，该标志被设置。 **辅助进位标志 (AF)**：位4，当算术操作导致四位二进制码的进位或借位时，该标志被设置。 **零标志 (ZF)**：位6，当算术或逻辑操作的结果为零时，该标志被设置。 **符号标志 (SF)**：位7，当算术或逻辑操作的结果为负时，该标志被设置。 **陷阱标志 (TF)**：位8，当该标志被设置时，CPU 将在执行每条指令后产生一个中断，通常用于调试。 **中断标志 (IF)**：位9，当该标志被设置时，CPU 将响应外部中断；当该标志被清除时，CPU 将忽略外部中断。 **方向标志 (DF)**：位10，该标志用于字符串操作。当 DF 为 0 时，字符串操作从低地址向高地址进行；当 DF 为 1 时，字符串操作从高地址向低地址进行。 **溢出标志 (OF)**：位11，当算术操作导致正溢出或负溢出时，该标志被设置。 此外，EFLAGS 寄存器还包含一些其他的标志位，如系统标志、I&#x2F;O特权级别等，这些通常用于操作系统或高级语言编程，对于汇编语言编程来说，我们通常只需要关注上述的那些标志位在64位的x86平台中，标志寄存器被称为RFLAGS寄存器。这是一个64位的寄存器，但实际上，只有低32位被使用，高32位保留未用。 RFLAGS寄存器包含了EFLAGS寄存器中的所有标志位，如进位标志（CF）、奇偶标志（PF）、辅助进位标志（AF）、零标志（ZF）、符号标志（SF）、陷阱标志（TF）、中断标志（IF）、方向标志（DF）和溢出标志（OF）等。 此外，RFLAGS寄存器还包含一些其他的标志位，如系统标志、I&#x2F;O特权级别等，这些通常用于操作系统或高级语言编程，对于汇编语言编程来说，我们通常只需要关注上述的那些标志位。 intel和AT&amp;T的区别Intel汇编和AT&amp;T汇编是两种不同的汇编语言格式，它们在语法和表示方式上有一些主要的区别：前缀：在AT&amp;T语法中，寄存器的前缀是“%”，立即数的前缀是“$”。而在Intel语法中，没有寄存器前缀或立即前缀。操作数的位置：在Intel语法中，第一个操作数是目标，第二个操作数是源。而在AT&amp;T语法中，第一个操作数是源，第二个操作数是目标。内存操作数的写法：在Intel语法中，基址寄存器包含在’[‘和’]‘中，而在AT&amp;T语法中，基址寄存器包含在’(‘和’)’中。后缀：AT&amp;T语法的助记符有一个后缀，该后缀的意义在于操作数的大小。“l”代表长，“w”代表字，“b”代表字节。而Intel语法在内存操作数上指定byte ptr, word ptr, dword ptr。需要注意的是，无论采用何种语法，都需要有支持该种语法的汇编器负责将汇编源代码“翻译”成机器指令，而Intel与AT&amp;T风格的汇编语言差异，只存在于汇编源码层面。AT&amp;T汇编是一种汇编语言格式，主要用于UNIX平台1。以下是一些AT&amp;T汇编的基本特性： 前缀：在AT&amp;T汇编中，寄存器前面加一个“%”，立即数前面加一个“$”。 操作数的位置：在AT&amp;T汇编中，源操作数在前，目的操作数在后。 后缀：AT&amp;T汇编的助记符有一个后缀，该后缀的意义在于操作数的大小。“l”代表长，“w”代表字，“b”代表字节。 内存操作数的写法：在AT&amp;T汇编中，基址寄存器包含在’(‘和’)’中。 AT&amp;T汇编文件代码主要分为以下几个部分： .text：存放代码对应的指令。.bss：存放未初始化的全局和静态变量，在运行时该区域初始是全。.rodata：存放只读数据和变量，例如字符串字面量。.data：存放余下的数据和变量，可读可写。希望这个解释对您有所帮助！立即数通常是指在立即寻址方式指令中给出的数。立即数可以是8位、16位或32位，该数值紧跟在操作码之后。如果立即数为16位或32位，那么，它将按“高高低低”的原则进行存储。 立即数是存放在指令中的操作数单元，仅仅跟随着操作码。你可以把它当数据，那就是数据，你把它当地址，然后访问该地址的内存单元，那就是地址了。立即数都是存放在指令中的操作数单元，仅仅跟随着操作码。 汇编数据处理我们定义的描述性符号: reg 和 sreg。为了描述上的简洁,在以后的课程中,我们将使用描述性的符号 reg来表示一个寄存器,用 sreg 表示一个段寄存器。reg的集合包括:ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di;sreg 的集合包括:ds,ss,cs,es. 我们用 db 和 dw 定义字节型数据和字型数据。dd 是用来定义 dword(double word,双字)型数据的。(占32位) dup 是一个操作符,在汇编语言中同db,dw,dd等一样,也是由编译器识别处理的符号。它是和db,dw,dd等数据定义指令配合使用的,用来进行数据的重复。比如:db 3 dup(0)定义了3个字节,它们的值都是0,相当于db 0,0,0。db 3 dup(0,1,2)定义了9个字节,它们是0,1,2,0,1,2,0,1,2,相当于db 0,1,2,0,1,2,0,1,2。 db 重复的次数 dup (重复的字节型数据)dw 重复的次数 dup (重复的字型数据)dd 重复的次数 dup (重复的双字型数据) 转移指令的原理JMP ;无条件跳转 JE ;&#x2F;&#x2F;等于则跳转 同JZJNE ;&#x2F;&#x2F;不等于则跳转 同JNZJA ;&#x2F;&#x2F;无符号大于则跳转JNA ;&#x2F;&#x2F;无符号不大于则跳转JAE ;&#x2F;&#x2F;无符号大于等于则跳转 同JNBJNAE ;&#x2F;&#x2F;无符号不大于等于则跳转 同JBJB ;&#x2F;&#x2F;无符号小于则跳转JNB ;&#x2F;&#x2F;无符号不小于则跳转JBE ;&#x2F;&#x2F;无符号小于等于则跳转 同JNAJNBE ;&#x2F;&#x2F;无符号不小于等于则跳转 同JAJG ;&#x2F;&#x2F;有符号大于则跳转JNG ;&#x2F;&#x2F;有符号不大于则跳转JGE ;&#x2F;&#x2F;有符号大于等于则跳转 同JNLJNGE ;&#x2F;&#x2F;有符号不大于等于则跳转 同JLJL ;&#x2F;&#x2F;有符号小于则跳转JNL ;&#x2F;&#x2F;有符号不小于则跳转JLE ;&#x2F;&#x2F;有符号小于等于则跳转 同JNGJNLE ;&#x2F;&#x2F;有符号不小于等于则跳转 同JGJZ ;&#x2F;&#x2F;为零则跳转JNZ ;&#x2F;&#x2F;不为零则跳转JS ;&#x2F;&#x2F;为负则跳转JNS ;&#x2F;&#x2F;不为负则跳转JC ;&#x2F;&#x2F;进位则跳转JNC ;&#x2F;&#x2F;不进位则跳转JO ;&#x2F;&#x2F;溢出则跳转JNO ;&#x2F;&#x2F;不溢出则跳转JP ;&#x2F;&#x2F;为偶则跳转JNP ;&#x2F;&#x2F;不为偶则跳转JPE ;&#x2F;&#x2F;奇偶位置位则跳转 同JPJPO ;&#x2F;&#x2F;奇偶位复位则跳转 同JNP 可以修改IP,或同时修改 CS 和IP的指令统称为转移指令。概括地讲,转移指令就是可以控制 CPU 执行内存中某处代码的指令。 由于转移指令对 IP的修改范围不同,段内转移又分为:短转移和近转移。短转移 IP 的修改范围为-128127。近转移IP的修改范围为-3276832767。 操作符 offset 在汇编语言中是由编译器处理的符号,它的功能是取得标号的偏移地址。比如下面的程序: CPU 执行指令的过程(1) 从CS:IP 指向内存单元读取指令,读取的指令进入指令缓冲器;(2)(IP)&#x3D;(IP)+所读取指令的长度,从而指向下一条指令;(3) 执行指令。转到1,重复这个过程。CPU 在执行 jmp 指令的时候并不需要转移的目的地址。 jmp far ptr 标号 实现的是段间转移,又称为远转移。 jmp word ptr内存单元地址(段内转移)功能:从内存单元地址处开始存放着一个字,是转移的目的偏移地址。内存单元地址可用寻址方式的任一格式给出。 jmp dword ptr 内存单元地址(段间转移)功能:从内存单元地址处开始存放着两个字,高地址处的字是转移的目的段地址,低地址处是转移的目的偏移地址。 jcxz 指令为有条件转移指令,所有的有条件转移指令都是短转移, loop 指令为循环指令,所有的循环指令都是短转移,在对应的机器码中包含转移的位移,而不是目的地址。对 IP 的修改范围都为:-128~127。 call和ret的组合使用汇编语言关于函数内存半导体储存器|–&gt;随机读写存储器RAM|–&gt;静态RAM(SRAM) | |–&gt;动态RAM(DRAM) | | |–&gt;只读存储器ROM|–&gt;可编程ROM(PROM) |–&gt;可擦除ROM(EPPROM) |–&gt;电擦除ROM(F2PROM) |–&gt;掩膜ROM计算机内存是计算机中最重要的部件之一，它是程序与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存对计算机的影响非常大，内存又被称为主存，其作用是存放CPU中的运算数据，以及与硬盘等外部存储设备交换的数据 内存的物理结构包括电路板、内存芯片（内存颗粒）、金手指和存储芯片（EEPROM）等构成，部分还有散热马甲、灯带等。电路板包括其上的电容等，作用就是连接各零件，供电。内存颗粒就是内存最为重要的东西，内存基本所有的参数都是围绕着它而描述。金手指是内存和主板连接的地方，一方面是数据交换，一方面是供电。而最后的这个存储芯片，就是存储内存的各种信息，交给主板识别. 内存的读写过程是这样的：首先给VCC接通+5V的电源，给GND接通0V的电源，使用AO-A9来指定数据的存储场所。然后再把数据的值输入给DO-D7的数据信号，并把WR (write)的值置为1，执行完这些操作后，就可以向内存IC写入数据了。读出数据时，只需要通过AO-A9的地址信号指定数据的存储场所，然后再将RD的值置为1即可. 内存的使用方式有很多，例如指针、数组、栈和队列等。指针是一种变量，只不过它所表示的不是数据的值，而是内存的地址。通过使用指针，可以对任意内存地址的数据进行读写。数组是指多个相同的数据类型在内存中连续排列的一种形式。作为数组元素的各个数据会通过下标编号来区分，这个编号也叫做索引，如此一来，就可以对指定索引的元素进行读写操作。 特殊运算符位运算位运算是一种基于二进制数的计算方式，主要包括以下几种类型： 按位与（AND）：对应位都为1时结果才为1，否则为0。例如，1010 &amp; 1100 的结果是 1000。 按位或（OR）：对应位只要有一个为1时结果就为1，否则为0。例如，1010 | 1100 的结果是 1110。 按位异或（XOR）：对应位相同为0，不同为1。例如，1010 ^ 1100 的结果是 0110。 按位取反（NOT）：0变1，1变0。例如，~1010 的结果是 0101。 左移（&lt;&lt;）：将二进制数的所有位向左移动指定的位数，右边用0填充。例如，1010 &lt;&lt; 2 的结果是 101000。 右移（&gt;&gt;）：将二进制数的所有位向右移动指定的位数，左边用0填充。例如，1010 &gt;&gt; 2 的结果是 10。这些运算在编程中非常常见，可以用于进行高效的数学运算，如乘法、除法和模运算等。同时，位运算也常用于处理二进制数据，如图像和音频数据。 #define SETFLAG(a,n) ((a)|&#x3D;(1&lt;&lt;(n)))&#x2F;&#x2F;把整数a中的第n位置为1#define CLEARFLAG(a,n) ((a)&amp;&#x3D;~(1&lt;&lt;(n)))&#x2F;&#x2F;把整数a中第n位置为0#define FLAGON(a,n) ((a)&amp;(1&lt;&lt;(n)))&#x2F;&#x2F;判断整数a中第n位是否为1 #define offserof(s,m) (size_t)&amp;(((s*)0)-&gt;m)计算m在结构体s中的偏移 宏的注意事项(1)宏名一般用大写(2)使用宏可提高程序的通用性和易读性,便于修改.例如:数组的大小常用宏定义(3)预处理是在编译之前的处理,而编译工作的任务之一就是语法检查,预处理不做语法检查.(4)宏定义末尾不加分号.(5)宏定义通常在文件的最开头,写在函数的花括号外边,作用域为其后边的程序.(6)宏定义允许被嵌套(宏定义中包括其他宏定义)(7)字符串””中永远不包含宏.(8)宏定义不分配内存,变量定义分配内存.(9)宏定义不存在类型问题,他的参数也是无类型的. 宏定义中一个井号和两个井号对于一个井号来说,宏会把#的内容当作一个字符串来替换. #define CAT(c) “123”#c于是:CAT(abc)就会被替换为:”123””abc”-&gt;”123abc”#define STR(c) #c于是:STR(a)就会被替换为:”a”. 对于连个井号来说,用于把两侧的参数合并为一个符号.比如: #define combine(a,b,c) a##b##c于是:combine(1,2,3)就会被替换为;123;而combine(“1”,”2”,”3”)就会被替换为”123”.#define WIDE(str) L##str则会将形参str的前面加上L比如:WIDE(“abc”)就会被替换为L”abc”. 宏的二义性只是在预处理的地方把代码展开,不需要额外的空间和时间方面的开销,所以调用一个宏比调用一个函数更有效率.但是宏容易产生二义性,也不能访问对象的私有成员,这是宏的局限.","categories":[],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"Html","slug":"Html","date":"2023-11-04T02:21:49.956Z","updated":"2023-11-14T13:38:43.499Z","comments":true,"path":"2023/11/04/Html/","link":"","permalink":"http://example.com/2023/11/04/Html/","excerpt":"","text":"在HTML中，href是一个属性，全称为Hypertext Reference。它用于指定超链接目标的URL。当用户点击一个带有href属性的元素（通常是&lt;a&gt;标签）时，他们将被导航到href属性中指定的URL。例如，&lt;a href=&quot;https://www.bing.com&quot;&gt;访问Bing&lt;/a&gt;会创建一个链接，点击这个链接会导航到Bing的主页。href也可以用于其他元素，如&lt;link&gt;和&lt;base&gt;，但最常见的用途是在&lt;a&gt;标签中创建超链接。希望这个解释对您有所帮助！ 在HTML中，您可以使用 &lt;br&gt; 标签来创建新的一行。例如： &lt;p>这是第一行。&lt;br>这是第二行。&lt;/p> 在这个例子中，&lt;br&gt; 标签在 “这是第一行。” 和 “这是第二行。” 之间创建了一个换行，所以这两句话会被显示在不同的行上。 在HTML中，您可以使用 &lt;h1&gt; 到 &lt;h6&gt; 这六个标签来创建标题。&lt;h1&gt; 是最大的标题，而 &lt;h6&gt; 是最小的标题。例如： &lt;h1>这是一个H1标题&lt;/h1> &lt;h2>这是一个H2标题&lt;/h2> &lt;h3>这是一个H3标题&lt;/h3> &lt;h4>这是一个H4标题&lt;/h4> &lt;h5>这是一个H5标题&lt;/h5> &lt;h6>这是一个H6标题&lt;/h6> 在这个例子中，每个 &lt;h&gt; 标签都创建了一个不同大小的标题。 在HTML中，id是一个全局属性，可以用于标识文档中的唯一元素。id属性的值应该是唯一的，这样它就可以用于定位文档中的特定元素。例如，如果您有一个标题元素如下： &lt;h1 id=\"myTitle\">这是一个标题&lt;/h1> 在HTML中，class是一个全局属性，它提供了一种方式来分类和选择相似的元素。class属性的值可以是一个或多个类名，类名之间用空格分隔。例如： &lt;p class=\"important\">这是一个重要的段落。&lt;/p> &lt;p class=\"highlight important\">这是一个既重要又需要高亮的段落。&lt;/p> 在HTML中，&lt;figure&gt;标签用于对插入到文档中的图像、图表、照片、代码等进行分组，通常与&lt;figcaption&gt;标签一起使用，后者用于为&lt;figure&gt;元素提供标题。 例如： &lt;figure> &lt;img src=\"image.jpg\" alt=\"我的图片\"> &lt;figcaption>这是我的图片的描述&lt;/figcaption> &lt;/figure> 在这个例子中，&lt;figure&gt;标签包含了一个&lt;img&gt;元素和一个&lt;figcaption&gt;元素。&lt;img&gt;元素用于显示图片，&lt;figcaption&gt;元素则提供了图片的描述。这样，图片和它的描述就被组织在了一起。 在HTML中，&lt;table&gt;标签用于创建表格。一个基本的表格包含&lt;table&gt;元素，以及一个或多个&lt;tr&gt;（行）、&lt;td&gt;（数据单元格）和可选的&lt;th&gt;（表头单元格）元素。例如： &lt;table> &lt;tr> &lt;th>姓名&lt;/th> &lt;th>邮箱&lt;/th> &lt;/tr> &lt;tr> &lt;td>张三&lt;/td> &lt;td>zhangsan@example.com&lt;/td> &lt;/tr> &lt;tr> &lt;td>李四&lt;/td> &lt;td>lisi@example.com&lt;/td> &lt;/tr> &lt;/table> 在这个例子中，&lt;table&gt;标签定义了一个表格。每个&lt;tr&gt;标签定义了一行，每个&lt;td&gt;标签定义了一个单元格，&lt;th&gt;标签定义了一个表头单元格。这个表格有两列和三行（包括表头行）。 在HTML中，&lt;span&gt;标签用于对文档中的行内元素进行组合。它没有任何特定的含义，但对于通过CSS和JavaScript应用样式和行为非常有用。&lt;span&gt;元素是一个行内元素，这意味着它不会引起文本换行或创建新的块。 例如： &lt;p>我是&lt;span class=\"highlight\">重要&lt;/span>的文本。&lt;/p> 在这个例子中，&lt;span&gt;标签被用来标记”重要”这个词， 在HTML中，&lt;pre&gt;标签用于表示预格式化的文本。被包含在&lt;pre&gt;标签中的文本通常会保留其原始的行距和空格。此标签在需要展示代码或者其他需要按照原样展示的文本时非常有用。 例如： &lt;pre> function helloWorld() &#123; console.log(\"Hello, world!\"); &#125; &lt;/pre> 在这个例子中，&lt;pre&gt;标签包含了一段JavaScript代码。由于使用了&lt;pre&gt;标签，代码中的缩进和换行都会被保留。如果没有使用&lt;pre&gt;标签，这些格式就会丢失。 在HTML中，&lt;和&gt;是特殊字符，它们用于标记HTML标签的开始和结束。如果您直接在HTML中写入&lt;stdio.h&gt;，浏览器会将其误认为一个HTML标签，而不是您想要显示的文本。 如果您想在HTML中显示&lt;stdio.h&gt;，您需要使用HTML实体来替换&lt;和&gt;。HTML实体&amp;lt;代表小于符号&lt;，&amp;gt;代表大于符号&gt;。所以，您应该这样写： &amp;lt;stdio.h&amp;gt; 这样，浏览器就会正确地显示&lt;stdio.h&gt;了。 在md文件能用到的html格式 &lt;figure class=\"highlight c\">&lt;table>&lt;tr>&lt;td class=\"gutter\">&lt;pre>&lt;span class=\"line\">15&lt;/span>&lt;br>&lt;/pre>&lt;/td>&lt;td class=\"code\">&lt;pre>&lt;code class=\"hljs c\">&lt;span class=\"line\">2&lt;/span>&lt;br>&lt;span &lt;br>&lt;span class=\"hljs-comment\">&lt;/span> &lt;br>&lt;br>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>&lt;/figure> 单击按钮，可使用JavaScript生成链接 点击这里 var el_down = document.getElementById(\"DOWN\"); function Fun() { var a = document.createElement('a'); //为锚a元素创建文本节点 var link = document.createTextNode(\"https://redclaykxl.github.io\"); // 将文本节点追加到锚a元素 a.appendChild(link); // 设置title. a.title = \"https://redclaykxl.github.io\"; // 设置href属性 a.href = \"https://redclaykxl.github.io\"; // 将锚元素附加到body document.body.appendChild(a); }","categories":[],"tags":[]},{"title":"C语言程序编写","slug":"C语言程序编写","date":"2023-11-03T11:41:37.202Z","updated":"2023-11-30T11:25:53.196Z","comments":true,"path":"2023/11/03/C语言程序编写/","link":"","permalink":"http://example.com/2023/11/03/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99/","excerpt":"","text":"输出大于所输入数的素数#include &lt;stdio.h> #include &lt;stdlib.h> int is_prime(int n) &#123; if (n &lt;= 1) &#123; return 0; &#125; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; return 0; &#125; &#125; return 1; &#125; int main() &#123; int n, count = 0; printf(\"请输入一个整数：\"); scanf(\"%d\", &amp;n); for (int i = n + 1; count &lt; 3; i++) &#123; if (is_prime(i)) &#123; printf(\"%d \", i); count++; &#125; &#125; return 0; &#125; 输出公式中s&#x3D;1+1&#x2F;(1+2)…1&#x2F;(1+2+…+n)的n的值#include &lt;stdio.h #include &lt;stdlib.h> float fun(int n) &#123; int i; float s=1.0,h=1; for (i=2;i&lt;=n;i++)&#123; h=h+ i ; s=s+1.0/h; &#125; return s; &#125; int main() &#123; int n; float s; printf(\"Please enter N:\\n\"); scanf(\"%d\",&amp;n); s=fun(n); printf(\"the result is:%f\",s); return 0; &#125; 星号金字塔#include &lt;stdio.h> int main() &#123; int rows; printf(\"请输入金字塔的行数：\"); scanf(\"%d\", &amp;rows); for (int i = 1; i &lt;= rows; i++) &#123; for (int j = 1; j &lt;= rows - i; j++) &#123; printf(\" \"); &#125; for (int j = 1; j &lt;= 2 * i - 1; j++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0; &#125; 99乘法表#include &lt;stdio.h> int main() &#123; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; printf(\"%d * %d = %d\\t\", j, i, i * j); &#125; printf(\"\\n\"); &#125; return 0; &#125; 用C语言实现整数的大小排序#include &lt;stdio.h> int main() &#123; int a, b, c, t; printf(\"请输入三个整数，用逗号隔开：\"); scanf(\"%d,%d,%d\", &amp;a, &amp;b, &amp;c); if (a > b) &#123; t = a; a = b; b = t; &#125; if (a > c) &#123; t = a; a = c; c = t; &#125; if (b > c) &#123; t = b; b = c; c = t; &#125; printf(\"排序后的结果为：%d, %d, %d\\n\", a, b, c); return 0; &#125; 判断三角形#include &lt;stdio.h> #include &lt;math.h> int main() &#123; float a, b, c; printf(\"请输入三角形的三条边，用逗号隔开：\"); scanf(\"%f,%f,%f\", &amp;a, &amp;b, &amp;c); if (a + b > c &amp;&amp; b + c > a &amp;&amp; a + c > b) &#123; printf(\"这是一个\"); if (a == b &amp;&amp; b == c) &#123; printf(\"等边三角形\"); &#125; else if (a == b || b == c || a == c) &#123; printf(\"等腰三角形\"); &#125; else if (pow(a, 2) + pow(b, 2) == pow(c, 2) || pow(a, 2) + pow(c, 2) == pow(b, 2) || pow(b, 2) + pow(c, 2) == pow(a, 2)) &#123; printf(\"直角三角形\"); &#125; else &#123; printf(\"普通三角形\"); &#125; printf(\"\\n\"); &#125; else &#123; printf(\"这不是一个三角形\\n\"); &#125; return 0; &#125; 输出星号组成的菱形#include &lt;stdio.h> int main() &#123; int n, i, j, k; printf(\"请输入菱形边长（奇数）：\"); scanf(\"%d\", &amp;n); for (i = 1; i &lt;= n; ++i) &#123; for (j = 1; j &lt;= n - i; ++j) &#123; printf(\" \"); &#125; for (k = 1; k &lt;= 2 * i - 1; ++k) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; for (i = n - 1; i >= 1; --i) &#123; for (j = 1; j &lt;= n - i; ++j) &#123; printf(\" \"); &#125; for (k = 1; k &lt;= 2 * i - 1; ++k) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0; &#125; 递归方式的斐波那契数列#include &lt;stdio.h> int fibonacci(int n) &#123; if (n == 0 || n == 1) &#123; return n; &#125; else &#123; return fibonacci(n - 1) + fibonacci(n - 2); &#125; &#125; int main() &#123; int n, i; printf(\"请输入要计算的斐波那契数列的项数：\"); scanf(\"%d\", &amp;n); printf(\"斐波那契数列的前 %d 项为：\", n); for (i = 0; i &lt; n; ++i) &#123; printf(\"%d \", fibonacci(i)); &#125; printf(\"\\n\"); return 0; &#125; 计算公式p&#x3D;m!&#x2F;n!(m-n)!#include &lt;stdio.h> int main() &#123; int m, n, i; double p = 1; printf(\"请输入m和n的值，用逗号隔开：\"); scanf(\"%d,%d\", &amp;m, &amp;n); if (m &lt; n) &#123; printf(\"m必须大于等于n！\\n\"); return 0; &#125; for (i = 1; i &lt;= n; ++i) &#123; p *= (m - i + 1) * 1.0 / i; &#125; printf(\"p的值为：%lf\\n\", p); return 0; &#125; 使用递归的方式逆转字符#include &lt;stdio.h> #include &lt;string.h> void reverse_printf(const char *str) &#123; if(str==NULL || *str=='\\0') &#123; return; &#125; reverse_printf(str+1); printf(\"%c\",*str); &#125; int main() &#123; char *a=\"hello,world!\"; reverse_printf(a); printf(\"\\n\"); return 0; &#125; 转换字符大小写#include &lt;stdio.h> #include &lt;string.h> int main() &#123; char str[100]; int i; printf(\"请输入一个字符串：\"); scanf(\"%s\", str); for (i = 0; str[i] != '\\0'; ++i) &#123; if (str[i] >= 'a' &amp;&amp; str[i] &lt;= 'z') &#123; str[i] = str[i] &amp; 0xDF; &#125; else if (str[i] >= 'A' &amp;&amp; str[i] &lt;= 'Z') &#123; str[i] = str[i] | 0x20; &#125; &#125; printf(\"转换后的字符串为：%s\\n\", str); return 0; &#125; 冒泡法排序#include &lt;stdio.h> int main() &#123; int a[] = &#123;900, 2, 3, -58, 34, 76, 32, 43, 56, -70, 35, -234, 532, 543, 2500&#125;; int n = sizeof(a) / sizeof(int); int i, j, buf; for (i = 0; i &lt; n - 1; ++i) &#123; for (j = 0; j &lt; n - 1 - i; ++j) &#123; if (a[j] &lt; a[j + 1]) &#123; buf = a[j]; a[j] = a[j + 1]; a[j + 1] = buf; &#125; &#125; &#125; printf(\"排序后的结果为：\"); for (i = 0; i &lt; n; ++i) &#123; printf(\"%d \", a[i]); &#125; printf(\"\\n\"); return 0; &#125; 我们把函数提取出来为 #include &lt;stdio.h> void bubble_sort(int arr[], int n) &#123; for(int i = 0; i &lt; n-1; i++); &#123; for(int j = 0; j &lt; n-i-1; j++) &#123; if(arr[j] > arr[j+1]) &#123; // 交换 arr[j] 和 arr[j+1] int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125; 打印杨辉三角#include &lt;stdio.h> int main() &#123; int n, i, j; printf(\"请输入要打印的行数：\"); scanf(\"%d\", &amp;n); int a[n][n]; for (i = 0; i &lt; n; ++i) &#123; for (j = 0; j &lt;= i; ++j) &#123; if (j == 0 || j == i) &#123; a[i][j] = 1; &#125; else &#123; a[i][j] = a[i - 1][j - 1] + a[i - 1][j]; &#125; printf(\"%d \", a[i][j]); &#125; printf(\"\\n\"); &#125; return 0; &#125;","categories":[],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"关于我使用VScode那些事","slug":"关于我使用VScode那些事","date":"2023-10-30T13:04:24.870Z","updated":"2023-11-30T11:30:54.443Z","comments":true,"path":"2023/10/30/关于我使用VScode那些事/","link":"","permalink":"http://example.com/2023/10/30/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8VScode%E9%82%A3%E4%BA%9B%E4%BA%8B/","excerpt":"","text":"文件带空格无法运行在code running这个插件中,如果遇到文件名带空格无法运行调试时,我们可以打开code running的拓展设置找到Executor Map,之后在settings.js中打开把cpp: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, 改为&quot;cd $dir &amp;&amp; g++ \\&quot;$fileName\\&quot; -o \\&quot;$fileNameWithoutExt.exe\\&quot; &amp;&amp; &amp; \\&quot;.\\\\$fileNameWithoutExt.exe\\&quot;&quot;, . 文件名是中文无法调试我们可以通过电脑的设置找到更改地区和时间,再找到管理语言设置,之后选择更改系统设置,勾选beta版使用unicode UTF-8提供全球语言支持. 关于使用字体用Ctrl+逗号进入设置输入font在这里能找到字体大小和字体个性化设置(推荐用Hack). 关于调试VScode需要在内部下载微软C&#x2F;C++三件套,再配合MinGW配置语言环境进行调试.在MinGW中,点击Basic Setup需要勾选mingw-developer-yoolkit,mingw32-base,mingw32-gcc-g++,mingw32-gcc-objc,msys-base.之后点击左上角的Installation之后点击Updata Catalogue下载. 实用软件集合黑曜石文档Z-library电脑阅读exe硬盘检测C语言环境下载MinGW7z解压阅读appONLYOFFICE开源办公VM虚拟机的一个许可证MC60H-DWHD5-H80U9-6V85M-8280D(网上都能找到). GitHub项目： 【键盘预测】https://github.com/ggerganov/kbd-audio【回溯机】 https://github.com/internetarchive/wayback-machine-webextension【亲戚计算器】https://github.com/mumuy/relationship【电子包浆】https://github.com/itorr/patina【今天吃什么】https://github.com/YunYouJun/cook[CursorWorkshop](Axialis Software - CursorWorkshop)鼠标指针修改. 汇编语言编辑器Radasm汇编IDEC51 v5版本更新说明c51v959下载地址:http://www.keil.com/files/uc51/c51v959.EXEc51v957下载地址:http://www.keil.com/files/uc51/c51v957.EXEc51v900下载地址:http://www.keil.com/files/uc51/c51v900.EXE更多版本请访问keil-C51产品列表(C51 Version 7.01—C51 Version 9.59)","categories":[],"tags":[]},{"title":"C语言输入格式汇总","slug":"C语言输入格式汇总","date":"2023-10-16T13:24:09.473Z","updated":"2023-11-30T11:33:18.718Z","comments":true,"path":"2023/10/16/C语言输入格式汇总/","link":"","permalink":"http://example.com/2023/10/16/C%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F%E6%B1%87%E6%80%BB/","excerpt":"","text":"输出1. %d格式：用来输出十进制整数，有以下几种用法：1、%d 按整型数据的实际长度输出。2、%md m为指定的输出值的宽度。如果数据的位数小于m，则左端补以空格，若大于m，则按实际位数输出。3、%0md 用这种格式时，左端用0来代替空格4、%-md m为指定的输出值的宽度。如果数据的位数小于m，则右端补以空格，若大于m，则按实际位数输出5、%ld 输出长整型数据。 2. f格式：用来输出实数（包括单、双精度），以小数形式输出。有以下几种用法：1、%f 不指定宽度，整数部分全部输出并输出6位小数。2、%m.nf 输出共占m列，其中有n位小数，如数值宽度小于m左端补空格。3、%-m.nf 输出共占m列，其中有n位小数，如数值宽度小于m右端补空格。 3. e格式：以指数形式输出实数。有以下用法：1、%e 数字部分（又称尾数）输出6位小数，指数部分占5位或4位。2、%m.ne和%-m.ne m、n和”-”字符含义与前相同。此处n指数据的数字部分的小数位数，m表示整个输出数据所占的宽度 4. g格式：自动选f格式或e格式中较短的一种输出，且不输出无意义的零5. %s格式：用来输出一个串。用法如下：1、%s：例如:printf(“%s”, “CHINA”)输出”CHINA”字符串（不包括双引号）。2、%ms：输出的字符串占m列，如字符串本身长度大于m，则突破获m的限制,将字符串全部输出。若串长小于m，则左补空格。3、%-ms：如果串长小于m，则在m列范围内，字符串向左靠，右补空格。4、%m.ns：输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。5、%-m.ns：其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果n&gt;m，则自动取n值，即保证n个字符正常输出。 输入scanf函数 %d：读取一个十进制整数。 %i：读取一个十进制、八进制或十六进制整数。 %o：读取一个八进制整数。 %u：读取一个无符号十进制整数。 %x：读取一个十六进制整数。 %f：读取一个浮点数。 %e：读取一个科学计数法表示的浮点数。 %g：根据数值的大小自动选择%f或%e。 %c：读取一个字符。 %s：读取一个字符串。 %p：读取一个指针。 %n：读取到目前为止已经读取的字符数。 %%：读取一个百分号。 转换说明 输出 %a 浮点数、十六进制数和p 记数法（C99&#x2F;C11） %A 浮点数、十六进制数和p 记数法（C99&#x2F;C11） %c 单个字符 %d 有符号十进制整数 %e 浮点数，e 记数法 %E 浮点数，e 记数法 %f 浮点数，十进制记数法 %g 根据值的不同，自动选择%f 或%e 。%e 格式用于指数小于-4 或者大于或等于精度时 %G 根据值的不同，自动选择%f 或%E 。%E 格式用于指数小于-4 或者大于或等于精度时 %i 有符号十进制整数（与%d 相同） %o 无符号八进制整数 %p 指针 %s 字符串 %u 无符号十进制整数 %x 无符号十六进制整数，使用十六进制数0f %X 无符号十六进制整数，使用十六进制数0F %% 打印一个百分号 好用的声明函数转换2进制#include &lt;stdio.h&gt;void intToBinary(int x, char* y) &#123; for (int i &#x3D; 31; i &gt;&#x3D; 0; --i) &#123; y[i] &#x3D; (x &amp; 1) + &#39;0&#39;; x &gt;&gt;&#x3D; 1; &#125; y[32] &#x3D; &#39;\\0&#39;; &#125; 数组的转换#include &lt;stdio.h&gt; void bubble_sort(int arr[], int n) &#123; for(int i &#x3D; 0; i &lt; n-1; i++); &#123; for(int j &#x3D; 0; j &lt; n-i-1; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; &#x2F;&#x2F; 交换 arr[j] 和 arr[j+1] int temp &#x3D; arr[j]; arr[j] &#x3D; arr[j+1]; arr[j+1] &#x3D; temp; &#125; &#125; &#125; &#125; 数组的打印void print_array(int arr[], int n) &#123; for(int i &#x3D; 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;); &#125;","categories":[],"tags":[{"name":"C语言code","slug":"C语言code","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80code/"}]},{"title":"C语言","slug":"C语言","date":"2023-10-12T14:05:24.147Z","updated":"2023-11-30T11:13:41.863Z","comments":true,"path":"2023/10/12/C语言/","link":"","permalink":"http://example.com/2023/10/12/C%E8%AF%AD%E8%A8%80/","excerpt":"","text":"一个X进制的整数（从an到a1），转化为十进制的公式： a(n)a(n-1)...a(1)=a(n)*x(n-1)+...+a(2)*x+a(1) 一个10进制的整数a，转化为x进制的公式为: a除以x取余，商继续除以x取余，直到商为0，所有的余数逆序就是x的进制数。 10进制转化为2进制可以用表格法及以1开始向左&#x2F;右除2所形成的表格用10进制的数字进行比较大于取1，小于取0，位数不足补上0。 2进制和16进制的互相转换可以用以下方法: 我们需要把2进制的数字每四个分为一组，从左向右所对应的数为8421，如果2进制的数字是1，就可以取到值，反之就是取不到。 例如: 01101011变成16进制，分为两组0110和1011，分别取值为0+4+2+0和8+0+2+1，可知16进制的数字为6b。 而从16进制转换成2进制就是把16进制的每一位数字拆成由8+4+2+1所得到的形式。 例如: 一个8进制的数字256，它转换为10进制的数字为2x8^2+5x8^1+6=128+40+6=174。之后转换为7进制就是336。 比如设计一个可以把10进制的数字转换为n进制的C语言如下。 P7Bit:位，小b，最小单位。 Byte:字节，大B，1Byte&#x3D;8bit 1个bit只能储存2个信息：0，1 1个Byte能储存：2^8个信息：[-128，127]，[0，255] 有2，4，8个Byte，没有3Byte 数据储存位置：寄存器，内存，磁盘等。 整数的符号表示： 有符号和没有符号， 有符号的用最高位表示正负，因此它们有符号之分，1表示负数，0表示正数。 如：10110110为负，01001011为正。 无符号的数表示0和正整数，无需表示正负，参与数值计算。 对于一个字节的整数有符号的在[-128,127]之间，没有符号的整数在[0，255]之间。 整数的编码分为：源码，反码和补码。 原码：在数值前面增加了一位符号位（即最高位为符号位），该位为0表示正数，1则表示负数，其余的位置是数值大小。 反码：正整数的反码就是其自身，而负整数的反码可以通过对其绝对值逐位求反来求得。 补码：正数的补码为它本身，负数的补码就是它的绝对值求反加1，0的补码是0。 表格法：512，256，128，64，32，16，8，4，2，1 47用表格法转换为2进制为00101111，则-47的补码为11010001. -1的补码为11111111。 128用表格法可知其2进制为10000000-128的补码为10000000。 127的补码为01111111。 int i&#x3D;-1在内存中存在的形式是补码，因为1的int形式为00000001，则-1为11111111。 P8整数的储存方式分为：低位优先(little-endian)和高位优先(big-endian)。 低位优先从低位到高位排序，高位优先从高到低排序。 我们的32位系统也就是x86系统所用的方式是低位优先，64位是高位优先。对于一个整数0x00 00 00 01，靠近0x的是高位，右侧为低位。例如一个32位的整数的值为0x12345678，则在32位的系统中储存方式为78 56 34 12，如果换成64位系统就是12 34 56 78。 htons() (htons to net short)主机字节序到网络字节序转换。 ntons() (net to host short)网络字节序到主机字节序的转换。 我们可以通过以下两种方式了解主机的字节序优先。 ip数据的报头是高位优先的，我们可以编写以下程序来识别。 之后把数值改为1234. P9C语言中浮点数的定义： 单精度浮点数：float,占4个字节 双精度浮点数：double,占8个字节 例如： float x&#x3D;1.732f； double y&#x3D;3.1415926； 在IEEE标准中，浮点数是将特定长度的连续字节（4个字节或8个字节）的所有2进制位（32或64）分割为特定的三个区域。 符号域：S，占1位，正0，负1. 阶码域：E,占8位或11位，E&#x3D;e+127（float） or e+1023(double),指数e右正负即为符号数，但阶码为正是无符号数，所以把e加127或1023作为偏移，方便指数的比较。 尾数域：M，占23位和52位因为整数部分的1是默认的可以不存储。 公式 精度实数的存储结构： 例如： -99.75的float：1 10000101 10001111000000000000000 double：1 10000000101 1000111100000000000000000000000000000000000000000000 1.5625的二进制表示用x2取整的方法，第一次x2整数部分为1，小数部分是0.125，第二次x2的整数为0，小数为0.25，第三次的x2，整数是0，小数是0.5，第四次x2，整数是1，小数为0。所以1.5625的2进制是1.1001. P12P12字符类型：char（1）&#x2F;wchar_t（2或4）整型：short（2）&#x2F;int（4）&#x2F;long(4或8)&#x2F;long long(8)&#x2F;_int64(8)实数单精度：float（4）实数双精度：double（8）有符号和无符号：signed&#x2F;unsdigned,(signed)int&#x2F;unsigned int布尔类型：bool，0&#x2F;1（true&#x2F;false）C99&lt;stdbool.h&gt;typedef int bool#define true 1#define false 0 字符编码有Ascll，utf系列，unicode。·a·是ascll的L·a·是unicode的NULL，0，’\\0’都是一样的，都是值0NULL虽然值是0，但是它的含义不一样，或者说它的类型不一样。NULL是指针类型，不过它是空指针，即值为0‘\\0’我们都知道\\是转义符，用单引号包起来，再加转义，实际上就是0，只不过它表示的是字符“0”用双引号包裹的0是字符串 #include &lt;stdio.h&gt;#include &lt;math.h&gt; void main(){ float a &#x3D; 0; if (fabs(a)&lt; 1e-6) &#123; printf(&quot;a 等于 0\\n&quot;); &#125; else &#123; printf(&quot;a 不等于 0\\n&quot;); &#125; return; } #include &lt;stdio.h&gt;#include &lt;math.h&gt; void main(){ double a &#x3D; 0; if (fabs(a)&lt; 1e-15) &#123; printf(&quot;a 等于 0\\n&quot;); &#125; else &#123; printf(&quot;a 不等于 0\\n&quot;); &#125; return; } P13P13类型长度-sizeof（是一个操作符，在编译阶段就确定）char[-128,127][0,255]short[-32768,32767][0,65535]int&#x2F;long[-2147483648,2147483647][0,4294967295]float[-3.410^38,3.410^38]double[-1.710^308,1.710^308]无符号的int最小为0，最大为-1（2进制的位全是1）有符号的intint max &#x3D; 0x7fffffff除符号位全是1int min &#x3D; 0x80000000除符号位全是0在整数上溢出1是最小值，整数下溢出1是最大值。 (char)(-128*-1)&#x3D;-12816位系统中，int有符号的取值范围是[-216&#x2F;2,216&#x2F;2-1]无符号是[0,65536]所以当i&#x3D;65536是溢出1位则是-32768，i&#x3D;65535时为-32767. P15强制转换格式（新类型）变量丢失字节从高位开始丢失。从小到大转换要用符号位填充，整数用0填充，负数用1填充。自动（隐式）转换1，若参与的运算量的类型不同，则先转换成同一类型，然后进行运算。2，转换按数据长度的增加方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后在进行运算。字节数不同的转换为高字节进行运算，字节相同的如果一种有符号另一种没有符号，则转换为无符号类型。 自动转换2 进行算数运算（加减乘除取余及符号运算）时，不同类型数据必须转换成同一类型的数据才能运算，算数转换原则为： 进行运算时，以表达式中最长的类型为主，将其他类型数据均转换成该类型， a，若运算数中有double型或float型，则其他类型的数据均转换成double类型进行运算。 b，若运算中最长的类型为long型，则其他类型数均转换成long型数。 c，若运算中最长型为int型，则char型也转换成int型进行运算。算数转换是在运算过程中自动完成的。 d，函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。char和short会被转换成int，float会被转换成double。 f，printf函数会将char和short转换成int；float会被转换成double传递。 g，函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。 注意事项： 作业： 1从int转换为char时字节是减少的512的2进制是0000 0001 0000 0000变为16进制是0x01 00，进行转换从大到小是舍弃高位变成0x00，之后输出的printf会把输出的char再转换成int就是0x00 00也就是0. 首先我们能知道在int类型中0x000000ff是255转换为char从高位舍弃是0x00ff还是255但255是无符号的char类型的最大值但有符号时是-1而有符号转无符号时内部储存方式不变但是外部是无符号的%lu所表示的是long unsigned即4字节int也是4字节从char转long要填充，我们知道最小值向下溢出是最大数值就是2*32-1。 3 短整型变长整型要在符号位填充0，长整形变短整型要舍弃高位。 4 有符号变无符号时内部储存方式不变但是外部要表示无符号。 看有符号数的最高位是否为1，如果不为1（即为0），则无符号数就直接等于有符号数；如果有符号数的最高位为1，则将有符号数取补码，得到的数就是无符号数。 及无符号变有符号时，原值照赋，存储方式不变但是外部值可能改变。 P16变量 变量是内存或寄存器中用一个标识符命名的存储单元，可以用来存储一个特定类型的数据，并且数据的值在程序运行过程中可以进行修复。 变量就至少可以给我们提供两个信息：一是变量的地址，即就是，操作系统为变量在内存中分配的若干内存首地址；二是变量的值，也就是，变量在内存中所分配的那些内存单元中所存放的数据。 常量没有地址。 变量的命名 必须由字母，下划线和数字组成，但是第一个字符必须是字母，下划线也被看作是字母。 大写字母和小写字母是不同的字符。 局部变量建议用比较短的名，全局变量使用比较长的名字（命名变量不用拼音尽量符合英语逻辑）。 1 要获取变量的地址，可以用取地址符 (&amp;)来操作变量 2 操作系统为变量在内存中分配的若干内存首地址，变量在内存中所分配的那些内存单元中所存放的数据 3 3.14f中f代表这是一个单精度的数 4 3value，_value,value,v1 第一个不和法。 P17 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。 它主要存放静态数据、全局数据和常量。 栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区：亦称动态内存分配 11.0属于没有被定义的状态，此时只能打印出0 or 1. P18以 int buf[100]&#x3D;{0} 为例，集中讨论 buf、buf[0]、&amp;buf[0]、&amp;buf 四个字符含义的内涵。 1、buf：有两层含义，一是数组名，sizeof(buf) 时就是数组名的含义；二是等价于 &amp;buf[0]，表示数组的第一个元素的首字节地址，是一个常量值。因此，既然是一个常量值，无论从哪层含义来使用，buf 都不能作为左值来使用，但是，buf 可以用来作为右值来使用，作为右值使用时，应理解为地址。 2、buf[0]：表示存储第一个元素的空间，可对其进行读写操作，所以可以作为左值来使用。 3、&amp;buf[0]：等价于 buf，是一个地址常量，只能作为右值使用。 4、&amp;buf：表示地址的首地址，是一个地址常量，只能作为右值使用。 buf 与 &amp;buf 的值相等，但是含义完全不同。printf(“%p\\n”,buf) 与 printf(“%p\\n”,&amp;buf) 这两条代码的打印结果是相同的，表明它们的值是相同的，但是 printf(“%p\\n”,buf+1) 与 printf(“%p\\n”,&amp;buf+1) 的结果完全不同，因为它们的含义不同，buf 表示数组的第一个元素的首字节地址，加 1 加的时一个元素空间的大小；&amp;buf 表示的是整个数组的首地址，加 1 加的是整个数组空间大小，数组首地址主要用于构建多维数组，对于一堆数组来说，数组首地址没有太大的实用意义。 fflush(sidin)使用回车键删掉上一个输入的数值。 char c1&#x3D;getch();直接输出值{不会在屏幕上直接显示} char c2&#x3D;getchar();需要回车键输出值 使用上述两个需要有#include &lt;conio.h&gt; getch()可以间隔分段使用。 scanf_s可以用来限制输入的字符防止数值溢出。（只有微软有） gets,puts平替scanf。 输入一个字符串时不用&amp;，而变量需要在前面加&amp; 使用_wchart定义，在scanf中使用%lc或%C输入 scanf后加入_s可以限制字符的输入防止溢出。 get同理 4996警告是一种数据溢出警告当输入的数值过大时溢出的数值可能会损坏其他数据造成破坏。 P19i++和++i的区别： 一，C语言内建型别： i++; ++i; C++里，i是一个对象，++i比i++效率高。 二，在复合表达式或赋值语句中： int i&#x3D;0； int a&#x3D; i++;a&#x3D;i;i&#x3D;i+1 int i&#x3D;0; int b&#x3D; ++i;i&#x3D;i+1;b&#x3D;i-&gt;b&#x3D;1,i&#x3D;1 三，函数中 i++ ++i I++,++i属于不确定（由编译器决定） 对于i&#x3D;&#x3D;0和0&#x3D;&#x3D;i来说，在if（）{}时是没错的但是，如果输入少&#x3D;时i&#x3D;&#x3D;0不会报错，产生的错误不易被发现，但是0&#x3D;&#x3D;i就会报错使错误更容易被发现改正。 a%&#x3D;5是指a&#x3D;a%5取余，a*&#x3D;5是指a×5. P20 循环switch语句是一种多路段判定语句，它测试表达语句是否为一些常量整数值中的某一个值匹配，并执行相应的分支动作。所以switch语句也是一种分支语句，可以和if语句互相转换。 switch(a)&#x2F;&#x2F;a只能为整数(char,short,int,long等),不能为指针，浮点数。 控制语句之循环语句：for,while,do-while. for(表达式1;条件表达式2;表达式3) { 循环体 } for循环中的“参数初始化表达式”，“条件表达式”和“更新循环变量表达式”都是选择项，即可以缺省，但是“;”不能缺。省略了初始化，表示不对循环控制变量赋初值，省略了条件表达式，则不做其他处理时便成为死循环。省略了增量，则不对循环控制变量进行操作，这时可在语句中加入修改循环控制变量的语句。 1，简单的for循环 for(int i&#x3D;0; i&lt;10;i++) { printf(“i:%d\\n”,i); } return 0; 2，while的循环 int i&#x3D;0; while(i&lt;10) { printf(“i:%d\\n”,i); i++; } return 0; 3，do_while语句的用法 int i&#x3D;0; do { printf(“i:%d\\n”,i);&#x2F;&#x2F;先执行在打印。 i++; } while (i&lt;10);&#x2F;&#x2F;while的循环写在花括号后边。 return 0; 控制语句之转向语句 goto 循环中的转向语句 break continue return: return 0 or return. 慎用goto语句，使用方式： 语句1 语句2 goto Lable1; . . . . Lable1: 语句7； 语句8； 语句9； 数组数组一维数组的定义：数据类型 数组名[常量表达式]数组元素的类型 合法标识符 数组元素个数。数组是连续的可以随机访问。但是链表就不能。 字符数组char str1[]&#x3D;{‘h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’};char str2[]&#x3D;”hello world”;第一个是字符数组，第二个即是字符数组还是字符串。&#x2F;&#x2F;sizeof是用来计算类型和数据的长度，strlen是用来计算字符串中非‘\\0’的字符个数。每当重新定义变量的时候所对应的a[i]就会改变。数组的赋值要在初始化阶段完成，初始化结束后不能直接赋值必须拷贝或单个元素赋值。数组名是常量指针一旦定义就不能修改。 #define hansu(a) sizeof(a)&#x2F;sizeof(a[0]) 如果输入的数组过多就会导致产生一些垃圾数值，C语言不会检测数组溢出。 二维数组初始化数组a[5]&#x3D;{1,2,3,4,5};二维数组和一维数组的储存方式相同数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。 下面将深入介绍数组在内存中的运行机制。 数组引用变量只是一个引用，这个引用变量可以指向任何有效的内存，只有当该引用指向有效内存后，才可通过该数组变量来访问数组元素。 与所有引用变量相同的是，引用变量是访问真实对象的根本方式。 也就是说，如果我们希望在程序中访问数组，则只能通过这个数组的引用变量来访问它。 实际的数组元素被存储在堆（heap）内存中；数组引用变量是一个引用类型的变量，被存储在栈（stack）内存中。采用按行列出的效率高因为这样的数组是连续的可以随机访问而按列排序在储存中是跳跃的。 \\#include &lt;stdio.h&gt; void func(int a\\[],int len) &#123; printf(&quot;sizeof(a) in func&#x3D;%d\\n&quot;,sizeof(a)); &#125; int main() &#123; int a\\[10]&#x3D;&#123;0&#125;; printf(&quot;sizeof(a)&#x3D;%d\\n&quot;,sizeof(a)); func(a,10); return 0; &#125; 输出40，4 \\#include &lt;stdio.h&gt; int main() &#123; int a\\[5]&#x3D;&#123;1,2,3,4,5&#125;; int *ptr1&#x3D;(int*)(&amp;a+1); int *ptr2&#x3D;(int*)((int)a+1); printf(&quot;%x,%x&quot;,ptr1\\[-1],*ptr2); return 0; &#125; 输出5，200000 字符串数组是由零个或多个字符组成的有限序列。C语言的字符串可以定义为：”c1c2c3c4……cn\\0”。从定义的形式可以看出，C语言的字符串是以’\\0’结尾的。程序在存放字符后会自动加上’\\0’。当字符串中的字符有符号时可以用&quot;real&quot;来防止产生的语法错误。（即在普通字符前加上反斜线。） 多字节字符串和宽字节字符串在C语言中，多字节字符串每个字符的编码宽度都不等，可以是一个字节还可以是多个字节。例如：char *str &#x3D; “Hello World!你好，世界!”。就是一个多字节的字符串(英文一个字节，中文两个字节)宽字节符的每个字节都是一样的。比如：wchar_t *wstr&#x3D;L”Hello World!你好，世界！”。上面的字符串都是两个字节。我们可以利用wctomb()进行宽字节和多字节的转。 \\#include &lt;stdio.h&gt; int g_sl\\[]&#x3D;&quot;hello world 1&quot;; int main() &#123; char \\*s2&#x3D;&quot;hello world 2&quot;;*不能在指针上修改数据，即不能修改存在静态常量值的字符串* char s3\\[]&#x3D;&quot;hello world 3&quot;; char \\*ps4&#x3D;(char\\*)malloc(128); if(ps4\\&#x3D;&#x3D;NULL) &#123; return -1; &#125; memset(ps4,1,128); strcpy(ps4,128,&quot;hello world 4&quot;); printf(&quot;%s\\\\n&quot;,g_sl);*静态区* printf(&quot;%s\\\\n&quot;,s2);*静态常量区* printf(&quot;%s\\\\n&quot;,s3);*栈* printf(&quot;%s\\\\n&quot;,ps4);*堆* free(ps4); return 0; &#125; 字符串遍历的三种方法：char *str &#x3D; “hello world!”;while(*str !&#x3D; ‘\\0’){ printf(“%c”,*str); str++;} for(;*str !&#x3D; ‘\\0’;str++){ printf(“%c”,str);} for(int i&#x3D;0;str[i] !&#x3D; ‘\\0’;i++){ printf(“%c”,str[i]);} 字符串库函数的应用：#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;tchar.h&gt;&#x2F;&#x2F;定义三种类型的字符串，缓存 printf &#x2F; printf(“%ws”) &#x2F; _tprintf(_T(“%s”),xx)strlen(取得多字节字符串中字符长度，不包含 ‘&#x2F;0’。) &#x2F; wsclen(取得宽字节字符串中字符长度，不包含 ‘&#x2F;0’。) &#x2F; _tcslen(取得宽字节&#x2F;多字节字符串中字符长度，不包含 ‘&#x2F;0’。) strcpy &#x2F; stecpy_s &#x2F; _tcslen1,例如:char *strcpy(char* dest, const char *src);功能:把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间,说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的指针。 wcscpy &#x2F; wcscpy_s &#x2F; wcsncpy_tcscpy &#x2F; _tcscpy_s &#x2F; _tcsncpystrcmp &#x2F; strncmp &#x2F; stricmp &#x2F; strnicmp比较字符串s1和s2 strcat &#x2F; strcat_s &#x2F;&#x2F;hello+world，文件路径字符串追加&#x2F;连接函数，它的功能就是在一个字符串后面追加上另外一个字符串。 strchr &#x2F; strrchr &#x2F;&#x2F;返回位置地址，str，求文件名，扩展名。查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置. strstr函数搜索一个字符串在另一个字符串中的第一次出现找到所搜索的字符串，则该函数返回第一次匹配的字符串的地址如果未找到所搜索的字符串，则返回NULL strtok &#x2F; strtok_s &#x2F;&#x2F;ip地址 strtok(st_ip,st_ip_delim); strtok_s(NULL,st_s1_deilm,&amp;next); 用于分解字符串，返回分解得到的字符串指针.atof &#x2F; atoi &#x2F; atol &#x2F; atoll &#x2F; _ttol() 指针指针是个变量里面存放内存地址。指针的初始化，可以让指针指向某一个变量的地址，也可以让指针指向一个分配的内存或者字符串常量，当然也可以指向NULL。例如：一，int i，*p \\\\声明了一个整形变量i，一个指针p，这里的*与int一起。p&#x3D;&i;二，int i;int *p&#x3D;NULL;&#x2F;&#x2F;声明了一个指针p，并初始化为NULL。p&#x3D;&i;&#x2F;&#x2F;将指针p指向变量i.三，int i;int *p&#x3D;&i;&#x2F;&#x2F;声明了一个指针p，并直接初始化为变量i的地址。四，char *p (char*)malloc(100);&#x2F;&#x2F;声明一个字符指针p，并初始化为堆上的一个地址。char *str&#x3D;”hello world”;&#x2F;&#x2F;声明了一个字符指针str，并初始化为字符串的首地址。char c&#x3D;’A’;char *str&#x3D;&c;&#x2F;&#x2F;声明了一个指针并直接初始化围为变量C的地址。char *pch &#x3D;&c; 地址：有效地址，NULL地址，野地址，信封地址。#define NULL ((void*)0) *p 解引用运算符（dereferrnce）*解引用：通过指针（存放的内存地址），找到对应的内存和里面存放的数据，（类似于邮递员根据信封地址，找到地点）。 &amp;和*互为逆运算：*&amp;与&amp;*&amp;:取址，取变量的地址（reference）*:取内存，是取地址对应的内存（dereference），*p代表该内存，内存的长度就是p类型的长度，如果为void类型，那么长度不确定，GCC中默认为1字节。 *在指针定义的时候，是和类型结合的.*在指针使用的时候，是取内存（解引用）char *s&#x3D;”hello world”;&#x2F;&#x2F;此处的*s是用于定义指针s.char c&#x3D;’a’;char *p&#x3D;&c;&#x2F;&#x2F;此处的*p是用于定义指针p,实际上是（char*）p&#x3D;&c;int x&#x3D;10,*p;&#x2F;&#x2F;此处的*p一样是用于定义指针p，此处的*与int结合：int *.*p+&#x3D;1;&#x2F;&#x2F;此处的*p是解引用(即C).printf(“%c\\n”,*p);&#x2F;&#x2F;此处的*p是解引用.void func(char *p){ printf(“%c\\n”,*p);&#x2F;&#x2F;取值} 指针类型和相互转换char *p;&#x2F;&#x2F;指向内存单元的1个字节.short *p;&#x2F;&#x2F;指向内存单元的2个字节.int *p;&#x2F;&#x2F;指向内存单元的4个字节.float *p;&#x2F;&#x2F;指向内存单元的4个字节.double *p;&#x2F;&#x2F;指向内存单元的8个字节. sizeof(p)&#x3D;4 or 8 &#x2F; x86 or x64sizeof(*p)&#x3D;所知类型的长度 char c;int *p &#x3D; (int *)&c; int a;int *p1 &#x3D; &a;char *p2 &#x3D; (char*)p1; void *pvoid *p;&#x2F;&#x2F;这个类型来说,其他类型指针隐式转换成该类型,不能*p来取值,先转换特定类型再取值.可以接受任何类型的指针赋值给其他类型的指针,需要强转.不能进行解引用*运算,必须先转换.int i&#x3D;10;char ch&#x3D;’a’;int *p&#x3D;&i;char *p2&#x3D;&ch; void *pv1&#x3D;p1;&#x2F;&#x2F;不能*pv1 errorvoid *pv2&#x3D;p2;&#x2F;&#x2F;不能*pv2 error int *p3&#x3D;(int*)pv1;&#x2F;&#x2F;*p3char *p4&#x3D;(char*)pv2;&#x2F;&#x2F;*p4void *memcpy(void *dst,void *src,size_t len)sizeof(pv1)=&#x3D;4 or 8sizeof(*pv1)=&#x3D;error,gcc=&#x3D;1. 字符指针既可以指向字符,也可以指向字符(其实也是指向的字符,即字符串的地址).判断指向字符还是字符串,在代码中可以自己确定.将字符或者字符串传给函数做参数,也可以通过字符指针完成.(二者需要自己确定)char ch&#x3D;’a’;char *p&#x3D;ch; char p&#x3D;”hello world”;while(*p&#x3D;’\\0’){ printf(“%c”,*p); p++;} sizeof(p),sizeof(*p)第一个指的是指针的长度第二个指的是指针对应类型的长度 用指针的方法判断低位优先还是高位优先 \\#include &lt;stdio.h&gt; int main(void) &#123; int num &#x3D; 0x000000ff; char\\* p1 &#x3D; (char\\*)&amp;num; unsigned char\\* p2 &#x3D; (unsigned char\\*)&amp;num; printf(&quot;%lu\\\\n&quot;,\\*p1); printf(&quot;%lu\\\\n&quot;,\\*p2); return 0; &#125; 输出是4294967295,255 二级指针二级指针:存放一级指针的地址一级指针存放的是普通变量的内存地址.二级指针存放的是一级指针的地址.int a&#x3D;10;int *p&#x3D;&a;int **pp&#x3D;&p;*p为a &amp;a为p*pp为p &amp;p为pp**pp为a**pp–&gt;*(*pp)–&gt;*(p)–&gt;*p–&gt;a \\#include &lt;stdio.h&gt; int main() &#123; int a &#x3D; 10; int\\* p &#x3D; &amp;a; int\\*\\* pp &#x3D; &amp;p; &#x2F;&#x2F;a,&amp;a,p,&amp;p,pp,\\*pp,\\*\\*pp printf(&quot;a:%d\\\\n&quot;,a);&#x2F;&#x2F;10 printf(&quot;&amp;a:%p\\\\n&quot;,&amp;a);&#x2F;&#x2F;addr of a printf(&quot;p%p\\\\n&quot;,p);&#x2F;&#x2F;addr of a printf(&quot;&amp;p:%p\\\\n&quot;,&amp;p);&#x2F;&#x2F;adde of p printf(&quot;pp:%p\\\\n&quot;,pp);&#x2F;&#x2F;addr of p printf(&quot;\\*p:%p\\\\n&quot;,\\*p);&#x2F;&#x2F;10 printf(&quot;\\*pp:%p\\\\n&quot;, \\*pp);&#x2F;&#x2F;p.addr of a printf(&quot;\\*\\*pp:%p\\\\n&quot;,\\*\\*pp);&#x2F;&#x2F;a,10 return 0; &#125; 二级指针的应用如果指针做实参,那么传实参的指针(地址),就必须使用二级指针.要改变指针的值,就必须传指针的指针(地址)(二级指针) 二级指针的作用:传参时改变一级指针的值. 传参int func(int x);传实参值,不能改变实参int func(int *x);传实参指针,修改实参int func(int &amp;x);传实参引用,修改实参int func(int **x);实参是指针,传指针的指针,修改指针int func(int *&amp;x);实参是指针,传指针的引用,修改指针 \\#include &lt;stdio.h&gt; void f(int\\*\\* ptr1, int\\* ptr2) &#123; int\\* tmp &#x3D; ptr2; \\*\\*ptr1 \\*&#x3D; 10; \\*ptr2 \\*&#x3D; 10; ptr2 &#x3D; \\*ptr1; \\*ptr1 &#x3D; tmp; &#125; int main(void) &#123; int i &#x3D; 0, j &#x3D; 20, \\* p1 &#x3D; &amp;i, \\* p2 &#x3D; &amp;j; f(&amp;p1, p2); printf(&quot;i:%d,j:%d,p1:%p,p2:%p\\\\n&quot;, i, j, \\*p1, \\*p2); return 0; &#125; 输出为0,200. \\#include &lt;stdio.h&gt; void GetMemory(char\\* p) &#123; p &#x3D; (char\\*)malloc(100); &#125; void Test(char \\*s) &#123; char\\* str &#x3D; NULL; GetMemory(str);&#x2F;&#x2F;这里应该传二级指针 strcpy(str,s); printf(str); &#125; 正确做法 \\#include &lt;stdio.h&gt; \\#include &lt;string.h&gt; void get_memory2(char \\*\\*p) &#123; \\*p &#x3D; (char \\*)malloc(100); &#125; int main() &#123; char\\* str &#x3D; NULL; get_memory2(&amp;str);&#x2F;&#x2F;这里应该传二级指针 strcpy_s(str,100,&quot;hello world&quot;); printf(&quot;%s\\\\n&quot;,str); free(str); str &#x3D; NULL; return 0; &#125; 结构体结构体定义:struct(结构体)每一个构成成员可以是一个基本数据类型或者又是一个构造类型.四种定义结构体的方法一,struct 结构名{ 成员列表}struct 结构名 变量名;二,struct 结构名{ 成员列表}变量名1,变量名2;三,struct{ 成员列表}变量名1,变量名2;四,typedef struct_结构名{ 成员列表}结构名,*p结构名;结构名 变量名; 结构体的定义,初始化与成员的访问\\#include &lt;stdio.h> \\#include &lt;string.h> typedef struct \\_student &#123; int id; int age; char name\\[20\\]; char sex; float score; &#125;student,\\*pstudent; int main() &#123; student s1 = &#123;17,22,\"Tom\",'M',99.5f&#125;; student s2 = &#123;0&#125;; s2.id = 19; s2.age = 23; strcpy_s(s2.name,20, \"lily\"); s2.sex = 'F'; s2.score = 87.5f; printf(\"id:%d,age:%d,name:%s,sex=%c,%f\\\\n\", s1.id,s1.age,s1.name,s1.sex,s1.score); printf(\"id:%d,age:%d,name:%s,sex=%c,%f\\\\n\", s2.id, s2.age, s2.name,s2.sex,s2.score); return 0; &#125; 结构体指针访问\\#include &lt;stdio.h&gt; \\#include &lt;string.h&gt; \\#include &lt;stdlib.h&gt; typedef struct \\_student &#123; int id; int age; char name\\[20\\]; char sex; float score; &#125;student, \\* pstudent; int main() &#123; student s1 &#x3D; &#123; 17,22,&quot;Tom&quot;,&#39;M&#39;,99.5f &#125;; student s2 &#x3D; &#123; 0 &#125;; s2.id &#x3D; 19; s2.age &#x3D; 23; strcpy_s(s2.name, 20, &quot;lily&quot;); s2.sex &#x3D; &#39;F&#39;; s2.score &#x3D; 87.5f; printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;, s1.id, s1.age, s1.name, s1.sex, s1.score); printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;, s2.id, s2.age, s2.name, s2.sex, s2.score); student* ps1 &#x3D; &amp;s1; pstudent ps2 &#x3D; &amp;s2;&#x2F;&#x2F;pstudent &#x3D;&#x3D; student \\* printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;, ps1-&gt;id,ps1-&gt;age,ps1-&gt;name,ps1-&gt;sex,ps1-&gt;score); printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;, ps2-&gt;id, ps2-&gt;age, ps2-&gt;name, ps2-&gt;sex, ps2-&gt;score); &#x2F;&#x2F;ps1+1 &#x2F;&#x2F;sizeof(ps1),sizeof(\\*ps1)\\&#x3D;\\&#x3D;sizeof(student) printf(&quot;sizeof(ps1)&#x3D;%d,sizeof(*ps1)&#x3D;%d,sizepf(student)&#x3D;%d\\\\n&quot;, sizeof(ps1),sizeof(*ps1),sizeof(student)); printf(&quot;sizeof(student*):%d\\\\n&quot;,sizeof(student\\*)); printf(&quot;ps1:%p,ps1+1:%p\\\\n&quot;,ps1,ps1+1); student* ps3 &#x3D; (student*)malloc(sizeof(student)); if (ps3 &#x3D;&#x3D; NULL) &#123; return -1; &#125; memset(ps3, 0, sizeof(student)); ps3-&gt;id &#x3D; 25; ps3-&gt;age &#x3D; 24; strcpy_s(ps3-&gt;name, 20, &quot;lilei&quot;); ps3-&gt;sex &#x3D; &#39;M&#39;; ps3-&gt;score &#x3D; 86.5f; printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;, ps3-&gt;id, ps3-&gt;age, ps3-&gt;name, ps3-&gt;sex, ps3-&gt;score); free(ps3); ps3 &#x3D; NULL; return 0; &#125; *与-&gt;,.运算符首先-&gt;与.运算符比*优先级高 typedef struct \\_student &#123; int id; int age; char name\\[20\\]; char sex; float score; &#125;student, \\* pstudent; student stdt&#x3D;&#123;...&#125;; pstdt&#x3D;&amp;stdt; \\*pstdt-&gt;sex--&gt;\\*(pstdt-&gt;sex)&#x2F;&#x2F;错误,因为sex不是一个指针. \\*pstdt-&gt;name--&gt;\\*(pstdt-&gt;name)&#x2F;&#x2F;正确的,因为name是一个指针,name是一个字符. \\*pstdt.sex--&gt;\\*(pstdt.sex)&#x2F;&#x2F;错误,pstdt是指针,不支持.运算符,没有.这个运算符. (\\*pstdt).sex--&gt;stdt.sex\\&#x2F;&#x2F;正确,\\*pstdt就是stdt. 结构体中的结构体\\#include &lt;stdio.h&gt; \\#include &lt;string.h&gt; \\#include &lt;stdlib.h&gt; typedef struct _date &#123; int year; int month; int day; &#125;date; typedef struct _student &#123; int id; int age; char name[20]; char sex; float score; date birthday; &#125;student, * pstudent; int main() &#123; student s1 &#x3D; &#123; 17,22,&quot;Tom&quot;,&#39;M&#39;,99.5f,&#123;1995,2,5&#125;&#125;; student s2 &#x3D; &#123; 0 &#125;; s2.id &#x3D; 19; s2.age &#x3D; 23; strcpy_s(s2.name, 20, &quot;lily&quot;); s2.sex &#x3D; &#39;F&#39;; s2.score &#x3D; 87.5f; s2.birthday.year &#x3D; 1997; s2.birthday.month &#x3D; 6; s2.birthday.day &#x3D; 21; printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f,&quot; &quot;year:%d,month:%d,day:%d\\n&quot;, s1.id, s1.age, s1.name, s1.sex, s1.score, s1.birthday.year,s1.birthday.month,s1.birthday.day); printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f,&quot; &quot;year:%d,month:%d,day:%d\\n&quot;, s2.id, s2.age, s2.name, s2.sex, s2.score, s2.birthday.year,s2.birthday.month,s2.birthday.day); student* ps1 &#x3D; &amp;s1; pstudent ps2 &#x3D; &amp;s2;&#x2F;&#x2F;pstudent &#x3D;&#x3D; student * printf(&quot;*ps2-&gt;name:%c\\n&quot;, *ps2-&gt;name); printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\n&quot;, ps1-&gt;id,ps1-&gt;age,ps1-&gt;name,ps1-&gt;sex,ps1-&gt;score); printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\n&quot;, ps2-&gt;id, ps2-&gt;age, ps2-&gt;name, ps2-&gt;sex, ps2-&gt;score); &#x2F;&#x2F;ps1+1 &#x2F;&#x2F;sizeof(ps1),sizeof(*ps1)&#x3D;&#x3D;sizeof(student) printf(&quot;sizeof(ps1)&#x3D;%d,sizeof(*ps1)&#x3D;%d,sizepf(student)&#x3D;%d\\n&quot;, sizeof(ps1),sizeof(*ps1),sizeof(student)); printf(&quot;sizeof(student*):%d\\n&quot;,sizeof(student*)); printf(&quot;ps1:%p,ps1+1:%p\\n&quot;,ps1,ps1+1); student* ps3 &#x3D; (student*)malloc(sizeof(student)); if (ps3 &#x3D;&#x3D; NULL) &#123; return -1; &#125; memset(ps3, 0, sizeof(student)); ps3-&gt;id &#x3D; 25; ps3-&gt;age &#x3D; 24; strcpy_s(ps3-&gt;name, 20, &quot;lilei&quot;); ps3-&gt;sex &#x3D; &#39;M&#39;; ps3-&gt;score &#x3D; 86.5f; ps3-&gt;birthday.year &#x3D; 1996; ps3-&gt;birthday.month &#x3D; 6; ps3-&gt;birthday.day &#x3D; 7; printf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f,&quot; &quot;year:%d,month:%d,day:%d\\n&quot;, ps3-&gt;id, ps3-&gt;age, ps3-&gt;name, ps3-&gt;sex, ps3-&gt;score, ps3-&gt;birthday.year,ps3-&gt;birthday.month, ps3-&gt;birthday.day); free(ps3); ps3 &#x3D; NULL; return 0; &#125; 结构体中的指针-1\\#include &lt;stdio.h&gt; \\#include &lt;string.h&gt; \\#include &lt;stdlib.h&gt; typedef struct _student &#123; int id; int age; char *name; char sex; float score; &#125;student,*pstudent; int main() &#123; &#x2F;&#x2F;student s1 &#x3D; &#123; 11,21,&quot;Tom&quot;,&#39;M&#39;,97.5f&#125;; student s2 &#x3D; &#123; 0 &#125;; s2.id &#x3D; 15; s2.age &#x3D; 22; s2.name &#x3D; (char*)malloc(20); if (s2.name &#x3D;&#x3D; NULL) &#123; return -1; &#125; strcpy_s(s2.name,20,&quot;lily&quot;); s2.sex &#x3D; &#39;M&#39;; s2.score &#x3D; 94.5f; student* s3 &#x3D; (student*)malloc(sizeof(student)); if (s3 &#x3D;&#x3D; NULL) &#123; return -1; &#125; memset(s3, 0, sizeof(student)); s3-&gt;id &#x3D; 18; s3-&gt;age &#x3D; 23; s3-&gt;name &#x3D; (char*)malloc(20); if (s3-&gt;name &#x3D;&#x3D; NULL) &#123; free(s3); return -1; &#125; memset(s3-&gt;name, 0, 20); strcpy_s(s3-&gt;name, 20, &quot;david&quot;); s3-&gt;sex &#x3D; &#39;M&#39;; s3-&gt;score &#x3D; 92.5f; &#x2F;&#x2F;printf(&quot;s1:name:%s\\n&quot;,s1.name); printf(&quot;s2:name:%s\\n&quot;, s2.name); printf(&quot;s3.name:%s\\n&quot;, s3-&gt;name); free(s2.name); s2.name &#x3D; NULL; free(s3-&gt;name); s3-&gt;name &#x3D; NULL; return 0; &#125; 结构体中的指针-2:链表和树typedef struct _node{int value;struct _node *next;}node,*pnode; typedef struct _btree{int data;struct _btree *left;struct _btree *right;}btree,*pbtree; 结构体中的指针和数组结构体赋值时的拷贝typedef struct _struct1{ … …}struct1;struct1 s1&#x3D;{1,’a’};struct1 s2&#x3D;s1;&#x2F;&#x2F;?struct1 s3;s3&#x3D;s1;&#x2F;&#x2F;? 浅拷贝和深拷贝拷贝中默认是浅拷贝 结构体数组结构体数组的初始化和应用结构体指针数组 点击我查看内容 #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; typedef struct _student{ int score; char name[16];}student,*pstudent; int main(){ student stu1[3] &#x3D; { {78,”tom”}, {83,”lily”}, {79,”david”} }; student stu2[3] &#x3D; { 0 }; pstudent stu3[3] &#x3D; { 0 }; for (int i = 0; i &lt; 3; i++) { printf(&quot;Please input score and name for %d\\n&quot;, i + 1); scanf_s(&quot;%d,%s&quot;, &amp;stu2[i].score, stu2[i].name, 16); } for (int i = 0; i &lt; 3; i++) { stu3[i] = &amp;stu1[i]; } for (int i = 0; i &lt; 3; i++) { printf(&quot;stu1:%d:score:%d,name:%s\\n&quot;, i, stu1[i].score, stu1[i].name); } 结构体做参数传指针传值判断两个同学的成绩 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576","categories":[],"tags":[{"name":"C语言code","slug":"C语言code","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80code/"}]},{"title":"linux","slug":"linux","date":"2023-10-12T09:25:48.000Z","updated":"2023-11-30T11:33:47.451Z","comments":true,"path":"2023/10/12/linux/","link":"","permalink":"http://example.com/2023/10/12/linux/","excerpt":"","text":"开使ls -s 命令用于显示目录中文件的大小，以块为单位。每个块的大小通常为 512 字节。如果您想查看文件的详细信息，可以使用 ls -l 命令。该命令将显示文件的权限、所有者、大小、创建时间等详细信息。 touch 命令用于修改文件或目录的时间属性，包括存取时间和更改时间。如果文件不存在，系统会建立一个新的文件。以下是使用 touch 命令创建文件的步骤： 打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。 输入以下命令：touch filename，其中 filename 是您要创建的文件名。 按下 Enter 键即可创建文件。 在Linux中，管道符 | 用于将一个命令的输出作为另一个命令的输入。例如，要查找包含特定文本的文件，可以使用以下命令：grep “text” filename | less。此命令将 grep 命令的输出作为 less 命令的输入，以便您可以轻松地查看匹配的行。mv 命令可以用于移动文件或重命名文件。要重命名文件，请使用以下命令： mv old_filename new_filename 其中 old_filename 是要重命名的文件名，new_filename 是新的文件名。请注意，如果 new_filename 已经存在，则会覆盖该文件。 在Linux中，软链接（也称为符号链接）是指一个文件或目录，它指向另一个文件或目录。软链接类似于Windows中的快捷方式。以下是创建软链接的步骤： 打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。 输入以下命令：ln -s &#x2F;path&#x2F;to&#x2F;original &#x2F;path&#x2F;to&#x2F;link，其中 &#x2F;path&#x2F;to&#x2F;original 是要链接的文件或目录的路径，&#x2F;path&#x2F;to&#x2F;link 是新的软链接的路径。 按下 Enter 键即可创建软链接。 要将文件复制到指定位置，您可以使用 cp 命令。以下是使用 cp 命令复制文件的步骤： 打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。 输入以下命令：cp &#x2F;path&#x2F;to&#x2F;source &#x2F;path&#x2F;to&#x2F;destination，其中 &#x2F;path&#x2F;to&#x2F;source 是要复制的文件的路径，&#x2F;path&#x2F;to&#x2F;destination 是目标位置的路径。 按下 Enter 键即可复制文件。 以下是一些常见的选项： -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。 -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。 -r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项。 -i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。 -u 或 --update：仅复制源文件中更新时间较新的文件。 -v 或 --verbose：显示详细的复制过程。 -p 或 --preserve：保留源文件的权限、所有者和时间戳信息。 -f 或 --force：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。 请注意，如果要复制整个目录，则必须使用参数 -r 或者 -R。如果目标文件已存在，则默认情况下会覆盖该文件。 在Linux中，路径是用于描述文件或目录位置的一种方式。绝对路径是指从根目录 &#x2F; 开始写起的文件或目录名称，而相对路径则指的是相对于当前路径的写法。换句话说，绝对路径必须以一个正斜线 &#x2F; 开头，也就是根目录开始，到查找对象（目录或文件）所必须经过的每个目录的名字，它是文件位置的完整路标，因此，在任何情况下都可以使用绝对路径找到所需的文件。相对路径则不是由根目录 &#x2F; 写起的，而是从当前目录描述到目标文件或目录的路径。使用相对路径表明某文件的存储位置时，经常会用到前面讲到的两个特殊目录，即当前目录（用 . 表示）和父目录（用 .. 表示）。总而言之，绝对路径是相对于根目录 &#x2F; 的，只要文件不移动位置，那么它的绝对路径是恒定不变的；而相对路径是相对于当前所在目录而言的，随着程序的执行，当前所在目录可能会改变，因此文件的相对路径不是固定不变的。 在Linux中，有许多文本编辑器可供选择，例如 nano、vim、emacs 等。以下是使用 nano 编辑器的写入和保存步骤： 打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。 输入以下命令：nano filename，其中 filename 是您要编辑的文件名。 在 nano 编辑器中，您可以使用键盘输入或复制粘贴文本。如果您需要插入文本，请按下 Ctrl + Shift + V。 要保存文件，请按下 Ctrl + O。如果您想更改文件名，请输入新的文件名并按下 Enter 键。 要退出 nano 编辑器，请按下 Ctrl + X。如果您对文件进行了更改但尚未保存，则会提示您保存更改。 在Linux中，您可以使用 tar 命令来打包和压缩文件。以下是使用 tar 命令打包和压缩文件的步骤： 打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。 输入以下命令：tar -czvf archive_name.tar.gz &#x2F;path&#x2F;to&#x2F;directory-or-file，其中 archive_name.tar.gz 是您要创建的归档文件名，&#x2F;path&#x2F;to&#x2F;directory-or-file 是要打包和压缩的目录或文件的路径。 按下 Enter 键即可打包和压缩文件。tar：用于打包文件和目录。例如，要将目录 &#x2F;home&#x2F;user&#x2F;data 打包到文件 data.tar 中，请使用以下命令：tar -cvf data.tar &#x2F;home&#x2F;user&#x2F;data。 gzip：用于压缩文件。例如，要将文件 data.txt 压缩为 data.txt.gz，请使用以下命令：gzip data.txt。 bzip2：用于压缩文件。例如，要将文件 data.txt 压缩为 data.txt.bz2，请使用以下命令：bzip2 data.txt。 zip：用于打包和压缩文件。例如，要将目录 &#x2F;home&#x2F;user&#x2F;data 打包并压缩为文件 data.zip，请使用以下命令：zip -r data.zip &#x2F;home&#x2F;user&#x2F;data。tar命令也可以打包多个文件或目录，只要用空格分开即可。例如: #把anaconda-ks.cfg文件和&#x2F;tmp目录打包成ana.tar文件包[root@localhost ~]# tar -cvf ana.tar anaconda-ks.cfg &#x2F;tmp&#x2F; tar打包的选项。-c 将多个文件或目录进行打包。-A 追加 tar 文件到归档文件。-f 包名 指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；-v 显示打包文件过程； tar解打包的选项。-x 对 tar 包做解打包操作。-f 指定要解压的 tar 包的包名。-t 只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。-C 目录 指定解打包位置。-v 显示解打包的具体过程。 tar打包压缩和解压缩解打包。-z：压缩和解压缩 “.tar.gz” 格式；-j：压缩和解压缩 “.tar.bz2”格式。“-C” 用于指定解压位置、”-t” 用于查看压缩包内容 zip压缩 zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用 [root@localhost ]#zip [选项] 压缩包名 源文件或源目录列表-r 递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。-m 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。-v 显示详细的压缩过程信息。-q 在压缩的时候不显示命令的执行过程。-压缩级别 压缩级别是从 19 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。-u 更新压缩文件，即往压缩文件中添加新文件。 zip 命令的基本使用 #压缩[root@localhost ~]# zip ana.zip anaconda-ks.cfg压缩命令同时压缩多个文件 #同时压缩多个文件到test.zip压缩包中 [root@localhost ~]# zip test.zip install.log install.log.syslog使用 zip 命令压缩目录，需要使用“-r”选项，例如： #压缩目录[root@localhost ~]# zip -r dir1.zip dir1 zip解压-d 目录名 将压缩文件解压到指定目录下。-n 解压时并不覆盖已经存在的文件。-o 解压时覆盖已经存在的文件，并且无需用户确认。-v 查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。-t 测试压缩文件有无损坏，但并不解压。-x 文件列表 解压文件，但不包含文件列表中指定的文件。 gzip压缩 gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。 [root@localhost ~]# gzip [选项] 源文件-c 将压缩数据输出到标准输出中，并保留源文件。-d 对压缩文件进行解压缩。-r 递归压缩指定目录下以及子目录下的所有文件。-v 对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。-l 对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。-数字 用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。gzip命令不会打包目录，而是把目录下所有的子文件分别压缩 gunzip解压缩 [root@localhost ~]# gunzip [选项] 文件-r 递归处理，解压缩指定目录下以及子目录下的所有文件。-c 把解压缩后的文件输出到标准输出设备。-f 强制解压缩文件，不理会文件是否已存在等情况。-l 列出压缩文件内容。-v 显示命令执行过程。-t 测试压缩文件是否正常，但不对其做解压缩操作。 bzip2压缩 bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩）-d 执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。-k bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。-f bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。-t 测试压缩包文件的完整性。-v 压缩或解压缩文件时，显示详细信息。-数字 这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项 在Linux中，日志文件是用于记录系统和应用程序活动的文件。大多数日志文件都存储在 &#x2F;var&#x2F;log 目录及其子目录中，其中一些常见的日志文件包括： &#x2F;var&#x2F;log&#x2F;syslog：系统日志文件，记录系统消息和错误。&#x2F;var&#x2F;log&#x2F;auth.log：授权日志文件，记录用户登录和授权信息。&#x2F;var&#x2F;log&#x2F;kern.log：内核日志文件，记录内核消息和错误。&#x2F;var&#x2F;log&#x2F;dmesg：内核环缓冲区日志文件，记录内核启动时的消息。要查看这些日志文件，您可以使用以下命令： sudo less &#x2F;var&#x2F;log&#x2F;syslogsudo less &#x2F;var&#x2F;log&#x2F;auth.logsudo less &#x2F;var&#x2F;log&#x2F;kern.logsudo less &#x2F;var&#x2F;log&#x2F;dmesg 在Linux系统中，二进制文件通常存储在以下目录中： &#x2F;bin：存放着最常用的程序和指令。&#x2F;sbin：只有系统管理员能使用的程序和指令。&#x2F;usr&#x2F;bin：预装的绝大部分的程序都放在这里，Linux发行版和macOS上都超过了1000个程序和脚本放在这里。&#x2F;usr&#x2F;sbin：系统管理员用于存放供系统启动后使用的不重要的系统使用工具。&#x2F;usr&#x2F;local&#x2F;bin：管理员给用户安装程序可以放在这里，一些使用时自动配置安装的程序也会放在这里。&#x2F;usr&#x2F;local&#x2F;sbin：类似于 &#x2F;usr&#x2F;local&#x2F;bin，只是这里存储的是超级用户使用的比较高级的管理程序和系统守护程序。 在Linux中，可以使用 chmod 命令来更改文件或目录的权限。以下是使用 chmod 命令更改文件或目录权限的步骤： 打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。 输入以下命令：chmod permissions filename，其中 permissions 是要设置的权限，filename 是要更改权限的文件或目录的名称。 按下 Enter 键即可更改文件或目录的权限。 例如，要将文件 file.txt 设置为所有用户都可读取和写入，可以使用以下命令： chmod a+rw file.txt 要在Linux上运行可执行文件，您可以使用以下命令： .&#x2F;filename 其中 filename 是您要运行的可执行文件名。请注意，您需要在文件名前加上 .&#x2F;，以便告诉Linux在当前目录中查找该文件。 要在Linux中递归删除文件或目录，您可以使用 rm 命令。以下是使用 rm 命令递归删除文件或目录的步骤： 打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。 输入以下命令：rm -r filename，其中 filename 是要删除的文件或目录的名称。 按下 Enter 键即可递归删除文件或目录。 在Linux中，您可以使用 find 命令来查找文件，使用 grep 命令来查找文件内容。以下是使用 find 和 grep 命令查找文件和文件内容的步骤： 要使用 find 命令查找文件，请输入以下命令：find &#x2F;path&#x2F;to&#x2F;search -name “filename”，其中 &#x2F;path&#x2F;to&#x2F;search 是要搜索的目录的路径，filename 是要查找的文件名或通配符。 要使用 grep 命令查找文件内容，请输入以下命令：grep “pattern” &#x2F;path&#x2F;to&#x2F;file，其中 pattern 是要查找的文本模式，&#x2F;path&#x2F;to&#x2F;file 是要搜索的文件路径。 要设置Linux用户密码，您可以使用以下命令： sudo passwd username 其中 username 是要设置密码的用户名。输入此命令后，您将被提示输入新密码并确认。 要设置root用户密码，请使用以下命令： sudo passwd root 输入此命令后，您将被提示输入新密码并确认。 要切换用户，请使用以下命令： su username 其中 username 是要切换到的用户名。输入此命令后，您将被提示输入该用户的密码。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://example.com/tags/%E9%80%86%E5%90%91/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"C语言code","slug":"C语言code","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80code/"}]}