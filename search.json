[{"title":"Hexo文档","url":"/2023/10/29/Hexo%20Word/","content":"\n安装Node.js和Git：首先，你需要在你的计算机上安装Node.js和Git。你可以从官方网站下载并安装它们。\n\n安装Hexo：打开命令行，然后输入以下命令来全局安装Hexo：\n npm install -g hexo-cli\n\n创建博客：然后，你可以使用以下命令来创建一个新的Hexo项目：\n hexo init blog\ncd blog\n\n安装依赖：在新创建的项目目录中，运行以下命令来安装依赖：\n npm install\n\n启动服务器：现在，你可以启动Hexo服务器来预览你的博客：\n hexo server\n\n生成静态文件：当你对博客满意时，你可以生成静态文件：\n hexo generate\n\n部署到GitHub：最后，你可以将你的博客部署到GitHub。首先，你需要在_config.yml文件中设置部署配置。然后，运行以下命令来部署你的博客：\n hexo deploy\n\nhexo -v &#x2F;&#x2F;检测版本号\ngit config --global user.name &quot;GitHub用户名&quot;\ngit config --global user.email &quot;GitHub注册邮箱&quot;\n\nssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot;\n\ncat ~&#x2F;.ssh&#x2F;id_rsa.pub\n博客初始化\n首先选择一个你喜欢的地方作为你的博客根目录。\nmkdir ~&#x2F;git&#x2F;你的GitHub用户名.github.io\n\n随后依次运行：\nhexo init ~&#x2F;git&#x2F;你的GitHub用户名.github.io\ncd ~&#x2F;git&#x2F;你的GitHub用户名.github.io\nnpm install\n\n现在博客已经初始化完成了。使用以下命令：\nhexo server\n\n就可以在本地看到你的站点了。可以在终端里使用control+c关掉本地服务器。下面列举一些常用的命令，更多命令与参数可以参考.\n\nhexo clean用于清除缓存与静态文件。\nhexo new “文章标题”用于新建文章。\nhexo server用于启动本地服务器查看渲染好的网页，可简写为hexo s。\nhexo generate用于生成静态文件，可简写为hexo g。\nhexo deploy用于部署网站，需要先设置好_config.yml，可简写hexo d。\n\n设置_config.yml\ndeploy:\n  type: git\n  repo: 你的GitHub目录地址\n  branch: master\n\n首次部署我们需要再安装一个依赖：\nnpm install hexo-deployer-git --save\n\n随后一切就绪，依次运行：\nhexo clean\nhexo g\nhexo d\n\n\n安装Markdown语法扩展Hexo原生的Markdown渲染插件支持的Markdown语法不够丰富，比如不支持GitHub Flavored Markdown、CommonMark、上标下标、脚注等等。因此，我们在写文章之前，可以把原生的插件hexo-renderer-marked改为hexo-renderer-markdown-it。\n首先，根据该插件的安装指南，运行以下命令：\nnpm uninstall hexo-renderer-marked\nnpm install hexo-renderer-markdown-it\n\n随后在_config.yml里添加如下语句（可以添加在deploy前面）：\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n  plugins:\n    - markdown-it-abbr\n    - markdown-it-footnote\n    - markdown-it-ins\n    - markdown-it-sub\n    - markdown-it-sup\n  anchors:\n    level: 2\n    collisionSuffix: 'v'\n    permalink: true\n    permalinkClass: header-anchor\n    permalinkSide: 'left'\n    permalinkSymbol: ¶\n\n随后你就可以使用扩展语法了。使用方法可以参看这里和这里，尤其是后一个网页给出了很详细的例子。\n如果你觉得脚注字体偏大，可以看我的字体设置文章，看完后就知道怎么修改了。我个人做了如下设置：\n.footnotes &#123;\n    font-size: 75%;\n&#125;\n\n因为我们引入了新的插件，所以也要改一下工作流文件，在安装Hexo那一步加一些步骤，安装这些依赖。你可以在本地修改.github/workflows/main.yml的内容，也可以在GitHub的blog仓库，点击Actions，选择最近的一次部署，点击右侧的省略号中的View workflow file，然后点击右侧的铅笔按钮进行修改。将新的依赖安装写在npm install那一行后面即可。如果你采用后者，在你将本地新的改动push到GitHub之前，要记得先做git pull，否则会报错显示远程仓库有新的改动。推荐在本地修改，一步到位。\nrun: |\n    npm install hexo-cli -g\n    npm install\n  + npm uninstall hexo-renderer-marked\n  + npm install hexo-renderer-markdown-it\nHexo 静态博客指南：建站教程（上） - 知乎 (zhihu.com)\n关于一些依赖的安装cnpm installgit clone \\https://github.com/Yue-plus/hexo-theme-arknights.git themes&#x2F;arknightscnpm install hexo-server hexo-browsersync hexo-renderer-pug –save\n实用插件[代码块折叠]fletchto99&#x2F;hexo-sliding-spoiler: A sliding spoiler for hexo (github.com).使用格式为\n\\&#123;% spoiler &quot;点击我查看内容&quot; %&#125;\n\\&#123;% endspoiler %&#125;\n"},{"title":"P12","url":"/2023/10/18/P12/","content":"P12字符类型：char（1）&#x2F;wchar_t（2或4）整型：short（2）&#x2F;int（4）&#x2F;long(4或8)&#x2F;long long(8)&#x2F;_int64(8)实数单精度：float（4）实数双精度：double（8）有符号和无符号：signed&#x2F;unsdigned,(signed)int&#x2F;unsigned int布尔类型：bool，0&#x2F;1（true&#x2F;false）C99&lt;stdbool.h&gt;typedef int bool#define true 1#define false 0\n字符编码有Ascll，utf系列，unicode。·a·是ascll的L·a·是unicode的NULL，0，’\\0’都是一样的，都是值0NULL虽然值是0，但是它的含义不一样，或者说它的类型不一样。NULL是指针类型，不过它是空指针，即值为0‘\\0’我们都知道\\是转义符，用单引号包起来，再加转义，实际上就是0，只不过它表示的是字符“0”用双引号包裹的0是字符串\n#include &lt;stdio.h&gt;#include &lt;math.h&gt;\nvoid main(){    float a &#x3D; 0;\nif (fabs(a)&lt; 1e-6)\n&#123;\n    printf(&quot;a 等于 0\\n&quot;);\n&#125;\nelse\n&#123;\n    printf(&quot;a 不等于 0\\n&quot;);\n&#125;\n\nreturn;\n\n}\n#include &lt;stdio.h&gt;#include &lt;math.h&gt;\nvoid main(){    double a &#x3D; 0;\nif (fabs(a)&lt; 1e-15)\n&#123;\n    printf(&quot;a 等于 0\\n&quot;);\n&#125;\nelse\n&#123;\n    printf(&quot;a 不等于 0\\n&quot;);\n&#125;\n\nreturn;\n\n}\n"},{"title":"P13","url":"/2023/10/18/P13/","content":"P13类型长度-sizeof（是一个操作符，在编译阶段就确定）char[-128,127][0,255]short[-32768,32767][0,65535]int&#x2F;long[-2147483648,2147483647][0,4294967295]float[-3.410^38,3.410^38]double[-1.710^308,1.710^308]无符号的int最小为0，最大为-1（2进制的位全是1）有符号的intint max &#x3D; 0x7fffffff除符号位全是1int min &#x3D; 0x80000000除符号位全是0在整数上溢出1是最小值，整数下溢出1是最大值。 (char)(-128*-1)&#x3D;-12816位系统中，int有符号的取值范围是[-216&#x2F;2,216&#x2F;2-1]无符号是[0,65536]所以当i&#x3D;65536是溢出1位则是-32768，i&#x3D;65535时为-32767.\n"},{"title":"P15","url":"/2023/10/18/P15/","content":"强制转换格式（新类型）变量丢失字节从高位开始丢失。从小到大转换要用符号位填充，整数用0填充，负数用1填充。自动（隐式）转换1，若参与的运算量的类型不同，则先转换成同一类型，然后进行运算。2，转换按数据长度的增加方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后在进行运算。字节数不同的转换为高字节进行运算，字节相同的如果一种有符号另一种没有符号，则转换为无符号类型。\n自动转换2\n进行算数运算（加减乘除取余及符号运算）时，不同类型数据必须转换成同一类型的数据才能运算，算数转换原则为：\n进行运算时，以表达式中最长的类型为主，将其他类型数据均转换成该类型，\na，若运算数中有double型或float型，则其他类型的数据均转换成double类型进行运算。\nb，若运算中最长的类型为long型，则其他类型数均转换成long型数。\nc，若运算中最长型为int型，则char型也转换成int型进行运算。算数转换是在运算过程中自动完成的。\nd，函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。char和short会被转换成int，float会被转换成double。\nf，printf函数会将char和short转换成int；float会被转换成double传递。\ng，函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。\n注意事项：\n作业：\n1从int转换为char时字节是减少的512的2进制是0000 0001 0000 0000变为16进制是0x01 00，进行转换从大到小是舍弃高位变成0x00，之后输出的printf会把输出的char再转换成int就是0x00 00也就是0.\n首先我们能知道在int类型中0x000000ff是255转换为char从高位舍弃是0x00ff还是255但255是无符号的char类型的最大值但有符号时是-1而有符号转无符号时内部储存方式不变但是外部是无符号的%lu所表示的是long unsigned即4字节int也是4字节从char转long要填充，我们知道最小值向下溢出是最大数值就是2*32-1。\n3\n短整型变长整型要在符号位填充0，长整形变短整型要舍弃高位。\n4\n有符号变无符号时内部储存方式不变但是外部要表示无符号。\n看有符号数的最高位是否为1，如果不为1（即为0），则无符号数就直接等于有符号数；如果有符号数的最高位为1，则将有符号数取补码，得到的数就是无符号数。\n及无符号变有符号时，原值照赋，存储方式不变但是外部值可能改变。\n"},{"title":"P16","url":"/2023/10/18/P16/","content":"变量\n变量是内存或寄存器中用一个标识符命名的存储单元，可以用来存储一个特定类型的数据，并且数据的值在程序运行过程中可以进行修复。\n变量就至少可以给我们提供两个信息：一是变量的地址，即就是，操作系统为变量在内存中分配的若干内存首地址；二是变量的值，也就是，变量在内存中所分配的那些内存单元中所存放的数据。\n常量没有地址。\n变量的命名\n必须由字母，下划线和数字组成，但是第一个字符必须是字母，下划线也被看作是字母。\n大写字母和小写字母是不同的字符。\n局部变量建议用比较短的名，全局变量使用比较长的名字（命名变量不用拼音尽量符合英语逻辑）。\n1\n要获取变量的地址，可以用取地址符 (&amp;)来操作变量\n2\n操作系统为变量在内存中分配的若干内存首地址，变量在内存中所分配的那些内存单元中所存放的数据\n3\n3.14f中f代表这是一个单精度的数\n4\n3value，_value,value,v1\n第一个不和法。\n"},{"title":"Html","url":"/2023/11/04/Html/","content":"在HTML中，href是一个属性，全称为Hypertext Reference。它用于指定超链接目标的URL。当用户点击一个带有href属性的元素（通常是&lt;a&gt;标签）时，他们将被导航到href属性中指定的URL。例如，&lt;a href=&quot;https://www.bing.com&quot;&gt;访问Bing&lt;/a&gt;会创建一个链接，点击这个链接会导航到Bing的主页。href也可以用于其他元素，如&lt;link&gt;和&lt;base&gt;，但最常见的用途是在&lt;a&gt;标签中创建超链接。希望这个解释对您有所帮助！\n在HTML中，您可以使用 &lt;br&gt; 标签来创建新的一行。例如：\n&lt;p>这是第一行。&lt;br>这是第二行。&lt;/p>\n在这个例子中，&lt;br&gt; 标签在 “这是第一行。” 和 “这是第二行。” 之间创建了一个换行，所以这两句话会被显示在不同的行上。\n在HTML中，您可以使用 &lt;h1&gt; 到 &lt;h6&gt; 这六个标签来创建标题。&lt;h1&gt; 是最大的标题，而 &lt;h6&gt; 是最小的标题。例如：\n&lt;h1>这是一个H1标题&lt;/h1>\n&lt;h2>这是一个H2标题&lt;/h2>\n&lt;h3>这是一个H3标题&lt;/h3>\n&lt;h4>这是一个H4标题&lt;/h4>\n&lt;h5>这是一个H5标题&lt;/h5>\n&lt;h6>这是一个H6标题&lt;/h6>\n\n在这个例子中，每个 &lt;h&gt; 标签都创建了一个不同大小的标题。\n在HTML中，id是一个全局属性，可以用于标识文档中的唯一元素。id属性的值应该是唯一的，这样它就可以用于定位文档中的特定元素。例如，如果您有一个标题元素如下：\n&lt;h1 id=\"myTitle\">这是一个标题&lt;/h1>\n\n在HTML中，class是一个全局属性，它提供了一种方式来分类和选择相似的元素。class属性的值可以是一个或多个类名，类名之间用空格分隔。例如：\n&lt;p class=\"important\">这是一个重要的段落。&lt;/p>\n&lt;p class=\"highlight important\">这是一个既重要又需要高亮的段落。&lt;/p>\n\n在HTML中，&lt;figure&gt;标签用于对插入到文档中的图像、图表、照片、代码等进行分组，通常与&lt;figcaption&gt;标签一起使用，后者用于为&lt;figure&gt;元素提供标题。\n例如：\n&lt;figure>\n  &lt;img src=\"image.jpg\" alt=\"我的图片\">\n  &lt;figcaption>这是我的图片的描述&lt;/figcaption>\n&lt;/figure>\n\n在这个例子中，&lt;figure&gt;标签包含了一个&lt;img&gt;元素和一个&lt;figcaption&gt;元素。&lt;img&gt;元素用于显示图片，&lt;figcaption&gt;元素则提供了图片的描述。这样，图片和它的描述就被组织在了一起。\n在HTML中，&lt;table&gt;标签用于创建表格。一个基本的表格包含&lt;table&gt;元素，以及一个或多个&lt;tr&gt;（行）、&lt;td&gt;（数据单元格）和可选的&lt;th&gt;（表头单元格）元素。例如：\n&lt;table>\n  &lt;tr>\n    &lt;th>姓名&lt;/th>\n    &lt;th>邮箱&lt;/th>\n  &lt;/tr>\n  &lt;tr>\n    &lt;td>张三&lt;/td>\n    &lt;td>zhangsan@example.com&lt;/td>\n  &lt;/tr>\n  &lt;tr>\n    &lt;td>李四&lt;/td>\n    &lt;td>lisi@example.com&lt;/td>\n  &lt;/tr>\n&lt;/table>\n\n在这个例子中，&lt;table&gt;标签定义了一个表格。每个&lt;tr&gt;标签定义了一行，每个&lt;td&gt;标签定义了一个单元格，&lt;th&gt;标签定义了一个表头单元格。这个表格有两列和三行（包括表头行）。\n在HTML中，&lt;span&gt;标签用于对文档中的行内元素进行组合。它没有任何特定的含义，但对于通过CSS和JavaScript应用样式和行为非常有用。&lt;span&gt;元素是一个行内元素，这意味着它不会引起文本换行或创建新的块。\n例如：\n&lt;p>我是&lt;span class=\"highlight\">重要&lt;/span>的文本。&lt;/p>\n\n在这个例子中，&lt;span&gt;标签被用来标记”重要”这个词，\n在HTML中，&lt;pre&gt;标签用于表示预格式化的文本。被包含在&lt;pre&gt;标签中的文本通常会保留其原始的行距和空格。此标签在需要展示代码或者其他需要按照原样展示的文本时非常有用。\n例如：\n&lt;pre>\n  function helloWorld() &#123;\n    console.log(\"Hello, world!\");\n  &#125;\n&lt;/pre>\n\n在这个例子中，&lt;pre&gt;标签包含了一段JavaScript代码。由于使用了&lt;pre&gt;标签，代码中的缩进和换行都会被保留。如果没有使用&lt;pre&gt;标签，这些格式就会丢失。\n在HTML中，&lt;和&gt;是特殊字符，它们用于标记HTML标签的开始和结束。如果您直接在HTML中写入&lt;stdio.h&gt;，浏览器会将其误认为一个HTML标签，而不是您想要显示的文本。\n如果您想在HTML中显示&lt;stdio.h&gt;，您需要使用HTML实体来替换&lt;和&gt;。HTML实体&amp;lt;代表小于符号&lt;，&amp;gt;代表大于符号&gt;。所以，您应该这样写：\n&amp;lt;stdio.h&amp;gt;\n\n这样，浏览器就会正确地显示&lt;stdio.h&gt;了。\n在md文件能用到的html格式\n&lt;figure class=\"highlight c\">&lt;table>&lt;tr>&lt;td class=\"gutter\">&lt;pre>&lt;span \nclass=\"line\">15&lt;/span>&lt;br>&lt;/pre>&lt;/td>&lt;td\nclass=\"code\">&lt;pre>&lt;code class=\"hljs c\">&lt;span\nclass=\"line\">2&lt;/span>&lt;br>&lt;span \n&lt;br>&lt;span class=\"hljs-comment\">&lt;/span>\n&lt;br>&lt;br>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>&lt;/figure>\n\n  \n\n \n  \n   \n单击按钮，可使用JavaScript生成链接\n点击这里\n\n \nvar el_down = document.getElementById(\"DOWN\");\nfunction Fun() {\nvar a = document.createElement('a');\n//为锚a元素创建文本节点 \nvar link = document.createTextNode(\"https://www.bilibili.com\");\n// 将文本节点追加到锚a元素\na.appendChild(link);\n// 设置title.\na.title = \"https://www.bilibili.com\";\n// 设置href属性\na.href = \"https://www.bilibili.com\";\n// 将锚元素附加到body \ndocument.body.appendChild(a); \n}\n\n\n\n"},{"title":"P17","url":"/2023/10/19/P17/","content":"\n静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。 它主要存放静态数据、全局数据和常量。\n栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。\n 堆区：亦称动态内存分配\n11.0属于没有被定义的状态，此时只能打印出0 or 1.\n"},{"title":"P18","url":"/2023/10/19/P18/","content":"以 int buf[100]&#x3D;{0} 为例，集中讨论 buf、buf[0]、&amp;buf[0]、&amp;buf 四个字符含义的内涵。\n1、buf：有两层含义，一是数组名，sizeof(buf) 时就是数组名的含义；二是等价于 &amp;buf[0]，表示数组的第一个元素的首字节地址，是一个常量值。因此，既然是一个常量值，无论从哪层含义来使用，buf 都不能作为左值来使用，但是，buf 可以用来作为右值来使用，作为右值使用时，应理解为地址。\n2、buf[0]：表示存储第一个元素的空间，可对其进行读写操作，所以可以作为左值来使用。\n3、&amp;buf[0]：等价于 buf，是一个地址常量，只能作为右值使用。\n4、&amp;buf：表示地址的首地址，是一个地址常量，只能作为右值使用。\nbuf 与 &amp;buf 的值相等，但是含义完全不同。printf(“%p\\n”,buf) 与 printf(“%p\\n”,&amp;buf) 这两条代码的打印结果是相同的，表明它们的值是相同的，但是 printf(“%p\\n”,buf+1) 与 printf(“%p\\n”,&amp;buf+1) 的结果完全不同，因为它们的含义不同，buf 表示数组的第一个元素的首字节地址，加 1 加的时一个元素空间的大小；&amp;buf 表示的是整个数组的首地址，加 1 加的是整个数组空间大小，数组首地址主要用于构建多维数组，对于一堆数组来说，数组首地址没有太大的实用意义。\nfflush(sidin)使用回车键删掉上一个输入的数值。\nchar c1&#x3D;getch();直接输出值{不会在屏幕上直接显示}\nchar c2&#x3D;getchar();需要回车键输出值\n使用上述两个需要有#include &lt;conio.h&gt;\ngetch()可以间隔分段使用。\nscanf_s可以用来限制输入的字符防止数值溢出。（只有微软有）\ngets,puts平替scanf。\n输入一个字符串时不用&amp;，而变量需要在前面加&amp;\n使用_wchart定义，在scanf中使用%lc或%C输入\nscanf后加入_s可以限制字符的输入防止溢出。\nget同理\n4996警告是一种数据溢出警告当输入的数值过大时溢出的数值可能会损坏其他数据造成破坏。\n"},{"title":"P19","url":"/2023/10/19/P19/","content":"i++和++i的区别：\n一，C语言内建型别：\ni++;\n++i;\nC++里，i是一个对象，++i比i++效率高。\n二，在复合表达式或赋值语句中：\nint i&#x3D;0；\nint a&#x3D; i++;a&#x3D;i;i&#x3D;i+1\nint i&#x3D;0;\nint b&#x3D; ++i;i&#x3D;i+1;b&#x3D;i-&gt;b&#x3D;1,i&#x3D;1\n三，函数中\ni++\n++i\nI++,++i属于不确定（由编译器决定） \n\n对于i&#x3D;&#x3D;0和0&#x3D;&#x3D;i来说，在if（）{}时是没错的但是，如果输入少&#x3D;时i&#x3D;&#x3D;0不会报错，产生的错误不易被发现，但是0&#x3D;&#x3D;i就会报错使错误更容易被发现改正。\na%&#x3D;5是指a&#x3D;a%5取余，a*&#x3D;5是指a×5.\n"},{"title":"P20","url":"/2023/10/19/P20/","content":"\n"},{"title":"P6","url":"/2023/10/12/P6/","content":"一个X进制的整数（从an到a1），转化为十进制的公式：\na(n)a(n-1)...a(1)=a(n)*x(n-1)+...+a(2)*x+a(1)\n\n一个10进制的整数a，转化为x进制的公式为:\na除以x取余，商继续除以x取余，直到商为0，所有的余数逆序就是x的进制数。\n\n10进制转化为2进制可以用表格法及以1开始向左&#x2F;右除2所形成的表格用10进制的数字进行比较大于取1，小于取0，位数不足补上0。\n2进制和16进制的互相转换可以用以下方法:\n我们需要把2进制的数字每四个分为一组，从左向右所对应的数为8421，如果2进制的数字是1，就可以取到值，反之就是取不到。\n\n例如:\n01101011变成16进制，分为两组0110和1011，分别取值为0+4+2+0和8+0+2+1，可知16进制的数字为6b。\n\n而从16进制转换成2进制就是把16进制的每一位数字拆成由8+4+2+1所得到的形式。\n例如:\n一个8进制的数字256，它转换为10进制的数字为2x8^2+5x8^1+6=128+40+6=174。之后转换为7进制就是336。\n\n比如设计一个可以把10进制的数字转换为n进制的C语言如下。\n"},{"title":"P7","url":"/2023/10/16/P7/","content":"Bit:位，小b，最小单位。\nByte:字节，大B，1Byte&#x3D;8bit\n1个bit只能储存2个信息：0，1\n1个Byte能储存：2^8个信息：[-128，127]，[0，255]\n有2，4，8个Byte，没有3Byte\n数据储存位置：寄存器，内存，磁盘等。\n整数的符号表示：\n有符号和没有符号，\n有符号的用最高位表示正负，因此它们有符号之分，1表示负数，0表示正数。\n如：10110110为负，01001011为正。\n无符号的数表示0和正整数，无需表示正负，参与数值计算。\n对于一个字节的整数有符号的在[-128,127]之间，没有符号的整数在[0，255]之间。\n整数的编码分为：源码，反码和补码。\n原码：在数值前面增加了一位符号位（即最高位为符号位），该位为0表示正数，1则表示负数，其余的位置是数值大小。\n反码：正整数的反码就是其自身，而负整数的反码可以通过对其绝对值逐位求反来求得。\n补码：正数的补码为它本身，负数的补码就是它的绝对值求反加1，0的补码是0。\n表格法：512，256，128，64，32，16，8，4，2，1\n\n47用表格法转换为2进制为00101111，则-47的补码为11010001.\n\n-1的补码为11111111。\n\n128用表格法可知其2进制为10000000-128的补码为10000000。\n\n127的补码为01111111。\n\nint i&#x3D;-1在内存中存在的形式是补码，因为1的int形式为00000001，则-1为11111111。"},{"title":"P8","url":"/2023/10/16/P8/","content":"整数的储存方式分为：低位优先(little-endian)和高位优先(big-endian)。\n低位优先从低位到高位排序，高位优先从高到低排序。\n我们的32位系统也就是x86系统所用的方式是低位优先，64位是高位优先。对于一个整数0x00 00 00 01，靠近0x的是高位，右侧为低位。例如一个32位的整数的值为0x12345678，则在32位的系统中储存方式为78 56 34 12，如果换成64位系统就是12 34 56 78。\nhtons()\n(htons to net short)主机字节序到网络字节序转换。\nntons()\n(net to host short)网络字节序到主机字节序的转换。\n我们可以通过以下两种方式了解主机的字节序优先。\nip数据的报头是高位优先的，我们可以编写以下程序来识别。\n之后把数值改为1234.\n"},{"url":"/2023/10/16/P4/","content":""},{"title":"P9","url":"/2023/10/16/P9/","content":"C语言中浮点数的定义：\n单精度浮点数：float,占4个字节\n双精度浮点数：double,占8个字节\n例如：\nfloat x&#x3D;1.732f；\ndouble y&#x3D;3.1415926；\n在IEEE标准中，浮点数是将特定长度的连续字节（4个字节或8个字节）的所有2进制位（32或64）分割为特定的三个区域。\n符号域：S，占1位，正0，负1.\n阶码域：E,占8位或11位，E&#x3D;e+127（float） or e+1023(double),指数e右正负即为符号数，但阶码为正是无符号数，所以把e加127或1023作为偏移，方便指数的比较。\n尾数域：M，占23位和52位因为整数部分的1是默认的可以不存储。\n公式\n精度实数的存储结构：\n例如：\n-99.75的float：1 10000101 10001111000000000000000\ndouble：1 10000000101 1000111100000000000000000000000000000000000000000000\n1.5625的二进制表示用x2取整的方法，第一次x2整数部分为1，小数部分是0.125，第二次x2的整数为0，小数为0.25，第三次的x2，整数是0，小数是0.5，第四次x2，整数是1，小数为0。所以1.5625的2进制是1.1001.\n"},{"title":"define","url":"/2023/10/31/define/","content":"宏定义用一个标识符来代替一个字符串宏名 字符串宏名(参数表) 字符串const float ….\n"},{"title":"Hello World","url":"/2023/10/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"二级指针","url":"/2023/10/28/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/","content":"二级指针:存放一级指针的地址一级指针存放的是普通变量的内存地址.二级指针存放的是一级指针的地址.int a&#x3D;10;int *p&#x3D;&a;int **pp&#x3D;&p;*p为a   &amp;a为p*pp为p   &amp;p为pp**pp为a**pp–&gt;*(*pp)–&gt;*(p)–&gt;*p–&gt;a\n\\#include &lt;stdio.h&gt;\n\nint main()\n&#123;\nint a &#x3D; 10;\n\nint\\* p &#x3D; &amp;a;\nint\\*\\* pp &#x3D; &amp;p;\n\n&#x2F;&#x2F;a,&amp;a,p,&amp;p,pp,\\*pp,\\*\\*pp\n\nprintf(&quot;a:%d\\\\n&quot;,a);&#x2F;&#x2F;10\nprintf(&quot;&amp;a:%p\\\\n&quot;,&amp;a);&#x2F;&#x2F;addr of a\nprintf(&quot;p%p\\\\n&quot;,p);&#x2F;&#x2F;addr of a\nprintf(&quot;&amp;p:%p\\\\n&quot;,&amp;p);&#x2F;&#x2F;adde of p\nprintf(&quot;pp:%p\\\\n&quot;,pp);&#x2F;&#x2F;addr of p\nprintf(&quot;\\*p:%p\\\\n&quot;,\\*p);&#x2F;&#x2F;10\nprintf(&quot;\\*pp:%p\\\\n&quot;, \\*pp);&#x2F;&#x2F;p.addr of a\nprintf(&quot;\\*\\*pp:%p\\\\n&quot;,\\*\\*pp);&#x2F;&#x2F;a,10\n\nreturn 0;\n&#125;\n\n二级指针的应用如果指针做实参,那么传实参的指针(地址),就必须使用二级指针.要改变指针的值,就必须传指针的指针(地址)(二级指针)\n二级指针的作用:传参时改变一级指针的值.\n传参int func(int x);传实参值,不能改变实参int func(int *x);传实参指针,修改实参int func(int &amp;x);传实参引用,修改实参int func(int **x);实参是指针,传指针的指针,修改指针int func(int *&amp;x);实参是指针,传指针的引用,修改指针\n\\#include &lt;stdio.h&gt;\nvoid f(int\\*\\* ptr1, int\\* ptr2)\n&#123;\n\tint\\* tmp &#x3D; ptr2;\n\t\\*\\*ptr1 \\*&#x3D; 10;\n\t\\*ptr2 \\*&#x3D; 10;\n\tptr2 &#x3D; \\*ptr1;\n\t\\*ptr1 &#x3D; tmp;\n&#125;\n\nint main(void)\n&#123;\n\tint i &#x3D; 0, j &#x3D; 20, \\* p1 &#x3D; &amp;i, \\* p2 &#x3D; &amp;j;\n\tf(&amp;p1, p2);\n\tprintf(&quot;i:%d,j:%d,p1:%p,p2:%p\\\\n&quot;, i, j, \\*p1, \\*p2);\n\treturn 0;\n&#125;\n输出为0,200.\n\n\\#include &lt;stdio.h&gt;\nvoid GetMemory(char\\* p)\n&#123;\n\tp &#x3D; (char\\*)malloc(100);\n&#125;\nvoid Test(char \\*s)\n&#123;\n\tchar\\* str &#x3D; NULL;\n\tGetMemory(str);&#x2F;&#x2F;这里应该传二级指针\n\tstrcpy(str,s);\n\tprintf(str);\n&#125;\n\n正确做法\n\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\nvoid get_memory2(char \\*\\*p)\n&#123;\n\t\\*p &#x3D; (char \\*)malloc(100);\n&#125;\nint main()\n&#123;\n\tchar\\* str &#x3D; NULL;\n\tget_memory2(&amp;str);&#x2F;&#x2F;这里应该传二级指针\n\tstrcpy_s(str,100,&quot;hello world&quot;);\n\tprintf(&quot;%s\\\\n&quot;,str);\n\tfree(str);\n\tstr &#x3D; NULL;\n\treturn 0;\n&#125;"},{"title":"使字符串或者数字逆向输出的方式","url":"/2023/11/04/%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%96%E8%80%85%E6%95%B0%E5%AD%97%E9%80%86%E5%90%91%E8%BE%93%E5%87%BA%E7%9A%84%E6%96%B9%E5%BC%8F/","content":"使用递归的方式逆转字符","tags":["C语言code"]},{"title":"使用sizeof计算结构体长度","url":"/2023/10/29/%E4%BD%BF%E7%94%A8sizeof%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E9%95%BF%E5%BA%A6/","content":"结构体的自然对齐\n#pragma pack(n)#pragma pack(push)&#x2F;&#x2F;#pragma pack(n)&#x2F;&#x2F;#pragma pack(pop)&#x2F;&#x2F;\n#pragma pack(n)来设定变量n字节对齐方式.这种对齐应该遵守如下两条对齐规则.1)数据成员对齐规则:n字节对齐就是说变量存放的起始地址的偏移量:min(sizeof(基本类型),n)或其倍数.2)整体对齐规则:结构的总大小也有个约束条件:min(最大的sizeof(基本类型),n)的倍数.\n也就是说:第一,如果n大于等于该变量所占用的字节数,那么偏移量必须满足默认的对齐方式:如果n小于该变量的类型所占用的字节数,那么偏移量为n的倍数,不用满足默认的对齐方式.第二,结构的总大小也有个约束条件,分下面的两种情况:如果n大于所有成员变量的所占类型所占的字节数,那么结构的总大小必须为占用空间最大的变量占有的空间数的倍数:否则必须为n的倍数.\n例如:"},{"title":"关于我使用VScode那些事","url":"/2023/10/30/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8VScode%E9%82%A3%E4%BA%9B%E4%BA%8B/","content":"文件带空格无法运行在code running这个插件中,如果遇到文件名带空格无法运行调试时,我们可以打开code running的拓展设置找到Executor Map,之后在settings.js中打开把cpp: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, 改为&quot;cd $dir &amp;&amp; g++ \\&quot;$fileName\\&quot; -o \\&quot;$fileNameWithoutExt.exe\\&quot; &amp;&amp; &amp; \\&quot;.\\\\$fileNameWithoutExt.exe\\&quot;&quot;, .\n文件名是中文无法调试我们可以通过电脑的设置找到更改地区和时间,再找到管理语言设置,之后选择更改系统设置,勾选beta版使用unicode UTF-8提供全球语言支持.\n关于使用字体用Ctrl+逗号进入设置输入font在这里能找到字体大小和字体个性化设置(推荐用Hack).\n关于调试VScode需要在内部下载微软C&#x2F;C++三件套,再配合MinGW配置语言环境进行调试.在MinGW中,点击Basic Setup需要勾选mingw-developer-yoolkit,mingw32-base,mingw32-gcc-g++,mingw32-gcc-objc,msys-base.之后点击左上角的Installation之后点击Updata Catalogue下载.\n"},{"title":"linux","url":"/2023/10/12/linux/","content":"#开使\nls -s 命令用于显示目录中文件的大小，以块为单位。每个块的大小通常为 512 字节。如果您想查看文件的详细信息，可以使用 ls -l 命令。该命令将显示文件的权限、所有者、大小、创建时间等详细信息。\n\ntouch 命令用于修改文件或目录的时间属性，包括存取时间和更改时间。如果文件不存在，系统会建立一个新的文件。以下是使用 touch 命令创建文件的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：touch filename，其中 filename 是您要创建的文件名。\n按下 Enter 键即可创建文件。\n\n在Linux中，管道符 | 用于将一个命令的输出作为另一个命令的输入。例如，要查找包含特定文本的文件，可以使用以下命令：grep “text” filename | less。此命令将 grep 命令的输出作为 less 命令的输入，以便您可以轻松地查看匹配的行。mv 命令可以用于移动文件或重命名文件。要重命名文件，请使用以下命令：\nmv old_filename new_filename\n其中 old_filename 是要重命名的文件名，new_filename 是新的文件名。请注意，如果 new_filename 已经存在，则会覆盖该文件。\n\n\n在Linux中，软链接（也称为符号链接）是指一个文件或目录，它指向另一个文件或目录。软链接类似于Windows中的快捷方式。以下是创建软链接的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：ln -s &#x2F;path&#x2F;to&#x2F;original &#x2F;path&#x2F;to&#x2F;link，其中 &#x2F;path&#x2F;to&#x2F;original 是要链接的文件或目录的路径，&#x2F;path&#x2F;to&#x2F;link 是新的软链接的路径。\n按下 Enter 键即可创建软链接。\n\n要将文件复制到指定位置，您可以使用 cp 命令。以下是使用 cp 命令复制文件的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：cp &#x2F;path&#x2F;to&#x2F;source &#x2F;path&#x2F;to&#x2F;destination，其中 &#x2F;path&#x2F;to&#x2F;source 是要复制的文件的路径，&#x2F;path&#x2F;to&#x2F;destination 是目标位置的路径。\n按下 Enter 键即可复制文件。\n以下是一些常见的选项：\n\n-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。\n-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。\n-r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项。\n-i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。\n-u 或 --update：仅复制源文件中更新时间较新的文件。\n-v 或 --verbose：显示详细的复制过程。\n-p 或 --preserve：保留源文件的权限、所有者和时间戳信息。\n-f 或 --force：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。\n\n请注意，如果要复制整个目录，则必须使用参数 -r 或者 -R。如果目标文件已存在，则默认情况下会覆盖该文件。\n在Linux中，路径是用于描述文件或目录位置的一种方式。绝对路径是指从根目录 &#x2F; 开始写起的文件或目录名称，而相对路径则指的是相对于当前路径的写法。换句话说，绝对路径必须以一个正斜线 &#x2F; 开头，也就是根目录开始，到查找对象（目录或文件）所必须经过的每个目录的名字，它是文件位置的完整路标，因此，在任何情况下都可以使用绝对路径找到所需的文件。相对路径则不是由根目录 &#x2F; 写起的，而是从当前目录描述到目标文件或目录的路径。使用相对路径表明某文件的存储位置时，经常会用到前面讲到的两个特殊目录，即当前目录（用 . 表示）和父目录（用 .. 表示）。总而言之，绝对路径是相对于根目录 &#x2F; 的，只要文件不移动位置，那么它的绝对路径是恒定不变的；而相对路径是相对于当前所在目录而言的，随着程序的执行，当前所在目录可能会改变，因此文件的相对路径不是固定不变的。\n在Linux中，有许多文本编辑器可供选择，例如 nano、vim、emacs 等。以下是使用 nano 编辑器的写入和保存步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：nano filename，其中 filename 是您要编辑的文件名。\n在 nano 编辑器中，您可以使用键盘输入或复制粘贴文本。如果您需要插入文本，请按下 Ctrl + Shift + V。\n要保存文件，请按下 Ctrl + O。如果您想更改文件名，请输入新的文件名并按下 Enter 键。\n要退出 nano 编辑器，请按下 Ctrl + X。如果您对文件进行了更改但尚未保存，则会提示您保存更改。\n在Linux中，您可以使用 tar 命令来打包和压缩文件。以下是使用 tar 命令打包和压缩文件的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：tar -czvf archive_name.tar.gz &#x2F;path&#x2F;to&#x2F;directory-or-file，其中 archive_name.tar.gz 是您要创建的归档文件名，&#x2F;path&#x2F;to&#x2F;directory-or-file 是要打包和压缩的目录或文件的路径。\n按下 Enter 键即可打包和压缩文件。tar：用于打包文件和目录。例如，要将目录 &#x2F;home&#x2F;user&#x2F;data 打包到文件 data.tar 中，请使用以下命令：tar -cvf data.tar &#x2F;home&#x2F;user&#x2F;data。\ngzip：用于压缩文件。例如，要将文件 data.txt 压缩为 data.txt.gz，请使用以下命令：gzip data.txt。\nbzip2：用于压缩文件。例如，要将文件 data.txt 压缩为 data.txt.bz2，请使用以下命令：bzip2 data.txt。\nzip：用于打包和压缩文件。例如，要将目录 &#x2F;home&#x2F;user&#x2F;data 打包并压缩为文件 data.zip，请使用以下命令：zip -r data.zip &#x2F;home&#x2F;user&#x2F;data。tar命令也可以打包多个文件或目录，只要用空格分开即可。例如:\n#把anaconda-ks.cfg文件和&#x2F;tmp目录打包成ana.tar文件包[root@localhost ~]# tar -cvf ana.tar anaconda-ks.cfg &#x2F;tmp&#x2F;\ntar打包的选项。-c    将多个文件或目录进行打包。-A    追加 tar 文件到归档文件。-f 包名    指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；-v    显示打包文件过程；\ntar解打包的选项。-x    对 tar 包做解打包操作。-f    指定要解压的 tar 包的包名。-t    只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。-C 目录    指定解打包位置。-v    显示解打包的具体过程。\ntar打包压缩和解压缩解打包。-z：压缩和解压缩 “.tar.gz” 格式；-j：压缩和解压缩 “.tar.bz2”格式。“-C” 用于指定解压位置、”-t” 用于查看压缩包内容\nzip压缩    zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用     [root@localhost ]#zip [选项] 压缩包名 源文件或源目录列表-r    递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。-m    将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。-v    显示详细的压缩过程信息。-q    在压缩的时候不显示命令的执行过程。-压缩级别    压缩级别是从 19 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。-u    更新压缩文件，即往压缩文件中添加新文件。\nzip 命令的基本使用\n#压缩[root@localhost ~]# zip ana.zip anaconda-ks.cfg压缩命令同时压缩多个文件\n#同时压缩多个文件到test.zip压缩包中\n[root@localhost ~]# zip test.zip install.log install.log.syslog使用 zip 命令压缩目录，需要使用“-r”选项，例如：\n#压缩目录[root@localhost ~]# zip -r dir1.zip dir1\nzip解压-d 目录名    将压缩文件解压到指定目录下。-n    解压时并不覆盖已经存在的文件。-o    解压时覆盖已经存在的文件，并且无需用户确认。-v    查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。-t    测试压缩文件有无损坏，但并不解压。-x 文件列表    解压文件，但不包含文件列表中指定的文件。\ngzip压缩  gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。   [root@localhost ~]# gzip [选项] 源文件-c    将压缩数据输出到标准输出中，并保留源文件。-d    对压缩文件进行解压缩。-r    递归压缩指定目录下以及子目录下的所有文件。-v    对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。-l    对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。-数字    用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。gzip命令不会打包目录，而是把目录下所有的子文件分别压缩\ngunzip解压缩  [root@localhost ~]# gunzip [选项] 文件-r    递归处理，解压缩指定目录下以及子目录下的所有文件。-c    把解压缩后的文件输出到标准输出设备。-f    强制解压缩文件，不理会文件是否已存在等情况。-l    列出压缩文件内容。-v    显示命令执行过程。-t    测试压缩文件是否正常，但不对其做解压缩操作。\nbzip2压缩  bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩）-d    执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。-k    bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。-f    bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。-t    测试压缩包文件的完整性。-v    压缩或解压缩文件时，显示详细信息。-数字    这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项\n在Linux中，日志文件是用于记录系统和应用程序活动的文件。大多数日志文件都存储在 &#x2F;var&#x2F;log 目录及其子目录中，其中一些常见的日志文件包括：\n&#x2F;var&#x2F;log&#x2F;syslog：系统日志文件，记录系统消息和错误。&#x2F;var&#x2F;log&#x2F;auth.log：授权日志文件，记录用户登录和授权信息。&#x2F;var&#x2F;log&#x2F;kern.log：内核日志文件，记录内核消息和错误。&#x2F;var&#x2F;log&#x2F;dmesg：内核环缓冲区日志文件，记录内核启动时的消息。要查看这些日志文件，您可以使用以下命令：\nsudo less &#x2F;var&#x2F;log&#x2F;syslogsudo less &#x2F;var&#x2F;log&#x2F;auth.logsudo less &#x2F;var&#x2F;log&#x2F;kern.logsudo less &#x2F;var&#x2F;log&#x2F;dmesg\n\n在Linux系统中，二进制文件通常存储在以下目录中：\n&#x2F;bin：存放着最常用的程序和指令。&#x2F;sbin：只有系统管理员能使用的程序和指令。&#x2F;usr&#x2F;bin：预装的绝大部分的程序都放在这里，Linux发行版和macOS上都超过了1000个程序和脚本放在这里。&#x2F;usr&#x2F;sbin：系统管理员用于存放供系统启动后使用的不重要的系统使用工具。&#x2F;usr&#x2F;local&#x2F;bin：管理员给用户安装程序可以放在这里，一些使用时自动配置安装的程序也会放在这里。&#x2F;usr&#x2F;local&#x2F;sbin：类似于 &#x2F;usr&#x2F;local&#x2F;bin，只是这里存储的是超级用户使用的比较高级的管理程序和系统守护程序。\n在Linux中，可以使用 chmod 命令来更改文件或目录的权限。以下是使用 chmod 命令更改文件或目录权限的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：chmod permissions filename，其中 permissions 是要设置的权限，filename 是要更改权限的文件或目录的名称。\n按下 Enter 键即可更改文件或目录的权限。\n例如，要将文件 file.txt 设置为所有用户都可读取和写入，可以使用以下命令：\nchmod a+rw file.txt\n\n要在Linux上运行可执行文件，您可以使用以下命令：\n.&#x2F;filename\n其中 filename 是您要运行的可执行文件名。请注意，您需要在文件名前加上 .&#x2F;，以便告诉Linux在当前目录中查找该文件。\n要在Linux中递归删除文件或目录，您可以使用 rm 命令。以下是使用 rm 命令递归删除文件或目录的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：rm -r filename，其中 filename 是要删除的文件或目录的名称。\n按下 Enter 键即可递归删除文件或目录。\n\n\n在Linux中，您可以使用 find 命令来查找文件，使用 grep 命令来查找文件内容。以下是使用 find 和 grep 命令查找文件和文件内容的步骤：\n要使用 find 命令查找文件，请输入以下命令：find &#x2F;path&#x2F;to&#x2F;search -name “filename”，其中 &#x2F;path&#x2F;to&#x2F;search 是要搜索的目录的路径，filename 是要查找的文件名或通配符。\n要使用 grep 命令查找文件内容，请输入以下命令：grep “pattern” &#x2F;path&#x2F;to&#x2F;file，其中 pattern 是要查找的文本模式，&#x2F;path&#x2F;to&#x2F;file 是要搜索的文件路径。\n要设置Linux用户密码，您可以使用以下命令：\nsudo passwd username\n其中 username 是要设置密码的用户名。输入此命令后，您将被提示输入新密码并确认。\n要设置root用户密码，请使用以下命令：\nsudo passwd root\n输入此命令后，您将被提示输入新密码并确认。\n要切换用户，请使用以下命令：\nsu username\n其中 username 是要切换到的用户名。输入此命令后，您将被提示输入该用户的密码。\n"},{"title":"计算机的内存","url":"/2023/11/03/%E5%86%85%E5%AD%98/","content":"半导体储存器|–&gt;随机读写存储器RAM|–&gt;静态RAM(SRAM)          |                  |–&gt;动态RAM(DRAM)          |          |          |–&gt;只读存储器ROM|–&gt;可编程ROM(PROM)                          |–&gt;可擦除ROM(EPPROM)                          |–&gt;电擦除ROM(F2PROM)                          |–&gt;掩膜ROM计算机内存是计算机中最重要的部件之一，它是程序与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存对计算机的影响非常大，内存又被称为主存，其作用是存放CPU中的运算数据，以及与硬盘等外部存储设备交换的数据\n内存的物理结构包括电路板、内存芯片（内存颗粒）、金手指和存储芯片（EEPROM）等构成，部分还有散热马甲、灯带等。电路板包括其上的电容等，作用就是连接各零件，供电。内存颗粒就是内存最为重要的东西，内存基本所有的参数都是围绕着它而描述。金手指是内存和主板连接的地方，一方面是数据交换，一方面是供电。而最后的这个存储芯片，就是存储内存的各种信息，交给主板识别.\n内存的读写过程是这样的：首先给VCC接通+5V的电源，给GND接通0V的电源，使用AO-A9来指定数据的存储场所。然后再把数据的值输入给DO-D7的数据信号，并把WR (write)的值置为1，执行完这些操作后，就可以向内存IC写入数据了。读出数据时，只需要通过AO-A9的地址信号指定数据的存储场所，然后再将RD的值置为1即可.\n内存的使用方式有很多，例如指针、数组、栈和队列等。指针是一种变量，只不过它所表示的不是数据的值，而是内存的地址。通过使用指针，可以对任意内存地址的数据进行读写。数组是指多个相同的数据类型在内存中连续排列的一种形式。作为数组元素的各个数据会通过下标编号来区分，这个编号也叫做索引，如此一来，就可以对指定索引的元素进行读写操作。\n","tags":["汇编语言"]},{"title":"好用的声明函数","url":"/2023/11/03/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A3%B0%E6%98%8E%E5%87%BD%E6%95%B0/","content":"转换2进制#include &lt;stdio.h&gt;= 0; --i) &#123;\n        y[i] = (x & 1) + '0';\n        x >>= 1;\n    &#125;\n    y[32] = '\\0';\n &#125;\n\n数组的转换 arr[j+1]) &#123;\n                // 交换 arr[j] 和 arr[j+1]\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n数组的打印","tags":["C语言code"]},{"title":"实用软件集合","url":"/2023/10/30/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%9B%86%E5%90%88/","content":"黑曜石文档Z-library电脑阅读exe硬盘检测C语言环境下载MinGW7z解压阅读appONLYOFFICE开源办公VM虚拟机的一个许可证MC60H-DWHD5-H80U9-6V85M-8280D(网上都能找到).\nGitHub项目： 【键盘预测】https://github.com/ggerganov/kbd-audio【回溯机】 https://github.com/internetarchive/wayback-machine-webextension【亲戚计算器】https://github.com/mumuy/relationship【电子包浆】https://github.com/itorr/patina【今天吃什么】https://github.com/YunYouJun/cook[CursorWorkshop](Axialis Software - CursorWorkshop)鼠标指针修改.\n汇编语言编辑器Radasm汇编IDEC51 v5版本更新说明c51v959下载地址:http://www.keil.com/files/uc51/c51v959.EXEc51v957下载地址:http://www.keil.com/files/uc51/c51v957.EXEc51v900下载地址:http://www.keil.com/files/uc51/c51v900.EXE更多版本请访问keil-C51产品列表(C51 Version 7.01—C51 Version 9.59)\n"},{"title":"指针","url":"/2023/10/28/%E6%8C%87%E9%92%88/","content":"指针是个变量里面存放内存地址。指针的初始化，可以让指针指向某一个变量的地址，也可以让指针指向一个分配的内存或者字符串常量，当然也可以指向NULL。例如：一，int i，*p  \\\\声明了一个整形变量i，一个指针p，这里的*与int一起。p&#x3D;&i;二，int i;int *p&#x3D;NULL;&#x2F;&#x2F;声明了一个指针p，并初始化为NULL。p&#x3D;&i;&#x2F;&#x2F;将指针p指向变量i.三，int i;int *p&#x3D;&i;&#x2F;&#x2F;声明了一个指针p，并直接初始化为变量i的地址。四，char *p (char*)malloc(100);&#x2F;&#x2F;声明一个字符指针p，并初始化为堆上的一个地址。char *str&#x3D;”hello world”;&#x2F;&#x2F;声明了一个字符指针str，并初始化为字符串的首地址。char c&#x3D;’A’;char *str&#x3D;&c;&#x2F;&#x2F;声明了一个指针并直接初始化围为变量C的地址。char *pch &#x3D;&c;\n地址：有效地址，NULL地址，野地址，信封地址。#define NULL ((void*)0)\n*p 解引用运算符（dereferrnce）*解引用：通过指针（存放的内存地址），找到对应的内存和里面存放的数据，（类似于邮递员根据信封地址，找到地点）。\n&amp;和*互为逆运算：*&amp;与&amp;*&amp;:取址，取变量的地址（reference）*:取内存，是取地址对应的内存（dereference），*p代表该内存，内存的长度就是p类型的长度，如果为void类型，那么长度不确定，GCC中默认为1字节。\n*在指针定义的时候，是和类型结合的.*在指针使用的时候，是取内存（解引用）char *s&#x3D;”hello world”;&#x2F;&#x2F;此处的*s是用于定义指针s.char c&#x3D;’a’;char *p&#x3D;&c;&#x2F;&#x2F;此处的*p是用于定义指针p,实际上是（char*）p&#x3D;&c;int x&#x3D;10,*p;&#x2F;&#x2F;此处的*p一样是用于定义指针p，此处的*与int结合：int *.*p+&#x3D;1;&#x2F;&#x2F;此处的*p是解引用(即C).printf(“%c\\n”,*p);&#x2F;&#x2F;此处的*p是解引用.void func(char *p){    printf(“%c\\n”,*p);&#x2F;&#x2F;取值}\n指针类型和相互转换char *p;&#x2F;&#x2F;指向内存单元的1个字节.short *p;&#x2F;&#x2F;指向内存单元的2个字节.int *p;&#x2F;&#x2F;指向内存单元的4个字节.float *p;&#x2F;&#x2F;指向内存单元的4个字节.double *p;&#x2F;&#x2F;指向内存单元的8个字节.\nsizeof(p)&#x3D;4 or 8 &#x2F; x86 or x64sizeof(*p)&#x3D;所知类型的长度\nchar c;int *p &#x3D; (int *)&c;\nint a;int *p1 &#x3D; &a;char *p2 &#x3D; (char*)p1;\nvoid *pvoid *p;&#x2F;&#x2F;这个类型来说,其他类型指针隐式转换成该类型,不能*p来取值,先转换特定类型再取值.可以接受任何类型的指针赋值给其他类型的指针,需要强转.不能进行解引用*运算,必须先转换.int i&#x3D;10;char ch&#x3D;’a’;int *p&#x3D;&i;char *p2&#x3D;&ch;\nvoid *pv1&#x3D;p1;&#x2F;&#x2F;不能*pv1 errorvoid *pv2&#x3D;p2;&#x2F;&#x2F;不能*pv2 error\nint *p3&#x3D;(int*)pv1;&#x2F;&#x2F;*p3char *p4&#x3D;(char*)pv2;&#x2F;&#x2F;*p4void *memcpy(void *dst,void *src,size_t len)sizeof(pv1)=&#x3D;4 or 8sizeof(*pv1)=&#x3D;error,gcc=&#x3D;1.\n字符指针既可以指向字符,也可以指向字符(其实也是指向的字符,即字符串的地址).判断指向字符还是字符串,在代码中可以自己确定.将字符或者字符串传给函数做参数,也可以通过字符指针完成.(二者需要自己确定)char ch&#x3D;’a’;char *p&#x3D;ch;\nchar p&#x3D;”hello world”;while(*p&#x3D;’\\0’){    printf(“%c”,*p);    p++;}\nsizeof(p),sizeof(*p)第一个指的是指针的长度第二个指的是指针对应类型的长度\n用指针的方法判断低位优先还是高位优先\n\\#include &lt;stdio.h&gt;\nint main(void)\n&#123;\n\tint num &#x3D; 0x000000ff;\n\tchar\\* p1 &#x3D; (char\\*)&amp;num;\n\tunsigned char\\* p2 &#x3D; (unsigned char\\*)&amp;num;\n\tprintf(&quot;%lu\\\\n&quot;,\\*p1);\n\tprintf(&quot;%lu\\\\n&quot;,\\*p2);\n\treturn 0;\n&#125;\n输出是4294967295,255\n"},{"title":"循环","url":"/2023/10/20/%E5%BE%AA%E7%8E%AF/","content":"switch语句是一种多路段判定语句，它测试表达语句是否为一些常量整数值中的某一个值匹配，并执行相应的分支动作。所以switch语句也是一种分支语句，可以和if语句互相转换。\nswitch(a)&#x2F;&#x2F;a只能为整数(char,short,int,long等),不能为指针，浮点数。\n控制语句之循环语句：for,while,do-while.\n\nfor(表达式1;条件表达式2;表达式3)\n{\n循环体\n}\nfor循环中的“参数初始化表达式”，“条件表达式”和“更新循环变量表达式”都是选择项，即可以缺省，但是“;”不能缺。省略了初始化，表示不对循环控制变量赋初值，省略了条件表达式，则不做其他处理时便成为死循环。省略了增量，则不对循环控制变量进行操作，这时可在语句中加入修改循环控制变量的语句。\n1，简单的for循环\nfor(int i&#x3D;0; i&lt;10;i++)\n{\nprintf(“i:%d\\n”,i);\n}\nreturn 0; \n2，while的循环\nint i&#x3D;0;\nwhile(i&lt;10)\n{\nprintf(“i:%d\\n”,i);\ni++;\n}\nreturn 0;\n3，do_while语句的用法\nint i&#x3D;0;\ndo\n{\nprintf(“i:%d\\n”,i);&#x2F;&#x2F;先执行在打印。\ni++;\n} while  (i&lt;10);&#x2F;&#x2F;while的循环写在花括号后边。\nreturn 0;\n控制语句之转向语句\n\ngoto\n循环中的转向语句\nbreak\ncontinue\nreturn:\nreturn 0 or return.\n慎用goto语句，使用方式：\n语句1\n语句2\ngoto Lable1;\n. . . . \nLable1:\n语句7；\n语句8；\n语句9；\n\n"},{"title":"数组","url":"/2023/10/21/%E6%95%B0%E7%BB%84/","content":"数组一维数组的定义：数据类型 数组名[常量表达式]数组元素的类型 合法标识符 数组元素个数。数组是连续的可以随机访问。但是链表就不能。\n字符数组char str1[]&#x3D;{‘h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’};char str2[]&#x3D;”hello world”;第一个是字符数组，第二个即是字符数组还是字符串。&#x2F;&#x2F;sizeof是用来计算类型和数据的长度，strlen是用来计算字符串中非‘\\0’的字符个数。每当重新定义变量的时候所对应的a[i]就会改变。数组的赋值要在初始化阶段完成，初始化结束后不能直接赋值必须拷贝或单个元素赋值。数组名是常量指针一旦定义就不能修改。 #define hansu(a) sizeof(a)&#x2F;sizeof(a[0]) 如果输入的数组过多就会导致产生一些垃圾数值，C语言不会检测数组溢出。\n二维数组初始化数组a[5]&#x3D;{1,2,3,4,5};二维数组和一维数组的储存方式相同数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。 下面将深入介绍数组在内存中的运行机制。 数组引用变量只是一个引用，这个引用变量可以指向任何有效的内存，只有当该引用指向有效内存后，才可通过该数组变量来访问数组元素。 与所有引用变量相同的是，引用变量是访问真实对象的根本方式。 也就是说，如果我们希望在程序中访问数组，则只能通过这个数组的引用变量来访问它。 实际的数组元素被存储在堆（heap）内存中；数组引用变量是一个引用类型的变量，被存储在栈（stack）内存中。采用按行列出的效率高因为这样的数组是连续的可以随机访问而按列排序在储存中是跳跃的。\n\\#include &lt;stdio.h&gt;\nvoid func(int a\\[],int len)\n&#123;\n    printf(&quot;sizeof(a) in func&#x3D;%d\\n&quot;,sizeof(a));\n&#125;\nint main()\n&#123;\nint a\\[10]&#x3D;&#123;0&#125;;\nprintf(&quot;sizeof(a)&#x3D;%d\\n&quot;,sizeof(a));\nfunc(a,10);\nreturn  0;\n&#125;\n输出40，4\n\n\\#include &lt;stdio.h&gt;\nint main()\n&#123;\n    int a\\[5]&#x3D;&#123;1,2,3,4,5&#125;;\n    int *ptr1&#x3D;(int*)(&amp;a+1);\n    int *ptr2&#x3D;(int*)((int)a+1);\n    printf(&quot;%x,%x&quot;,ptr1\\[-1],*ptr2);\n    return 0;\n&#125;\n输出5，200000\n\n字符串数组是由零个或多个字符组成的有限序列。C语言的字符串可以定义为：”c1c2c3c4……cn\\0”。从定义的形式可以看出，C语言的字符串是以’\\0’结尾的。程序在存放字符后会自动加上’\\0’。当字符串中的字符有符号时可以用&quot;real&quot;来防止产生的语法错误。（即在普通字符前加上反斜线。）\n多字节字符串和宽字节字符串在C语言中，多字节字符串每个字符的编码宽度都不等，可以是一个字节还可以是多个字节。例如：char *str &#x3D; “Hello World!你好，世界!”。就是一个多字节的字符串(英文一个字节，中文两个字节)宽字节符的每个字节都是一样的。比如：wchar_t *wstr&#x3D;L”Hello World!你好，世界！”。上面的字符串都是两个字节。我们可以利用wctomb()进行宽字节和多字节的转。\n \\#include &lt;stdio.h&gt;\n int g_sl\\[]&#x3D;&quot;hello world 1&quot;;\nint main()\n&#123;\n\tchar \\*s2&#x3D;&quot;hello world 2&quot;;*不能在指针上修改数据，即不能修改存在静态常量值的字符串*\n\tchar s3\\[]&#x3D;&quot;hello world 3&quot;;\n\tchar \\*ps4&#x3D;(char\\*)malloc(128);\n\t\nif(ps4\\&#x3D;&#x3D;NULL)\n&#123;\n\treturn -1;\n&#125;\nmemset(ps4,1,128);\nstrcpy(ps4,128,&quot;hello world 4&quot;);\n\nprintf(&quot;%s\\\\n&quot;,g_sl);*静态区*\nprintf(&quot;%s\\\\n&quot;,s2);*静态常量区*\nprintf(&quot;%s\\\\n&quot;,s3);*栈*\nprintf(&quot;%s\\\\n&quot;,ps4);*堆*\n\nfree(ps4);\n\nreturn 0;\n&#125;\n\n\n字符串遍历的三种方法：char *str &#x3D; “hello world!”;while(*str !&#x3D; ‘\\0’){    printf(“%c”,*str);    str++;}\nfor(;*str !&#x3D; ‘\\0’;str++){    printf(“%c”,str);}\nfor(int i&#x3D;0;str[i] !&#x3D; ‘\\0’;i++){    printf(“%c”,str[i]);}\n字符串库函数的应用：#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;tchar.h&gt;&#x2F;&#x2F;定义三种类型的字符串，缓存\nprintf &#x2F; printf(“%ws”) &#x2F; _tprintf(_T(“%s”),xx)strlen(取得多字节字符串中字符长度，不包含 ‘&#x2F;0’。) &#x2F; wsclen(取得宽字节字符串中字符长度，不包含 ‘&#x2F;0’。) &#x2F; _tcslen(取得宽字节&#x2F;多字节字符串中字符长度，不包含 ‘&#x2F;0’。)\nstrcpy &#x2F; stecpy_s &#x2F; _tcslen1,例如:char *strcpy(char* dest, const char *src);功能:把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间,说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的指针。\nwcscpy &#x2F; wcscpy_s &#x2F; wcsncpy_tcscpy &#x2F; _tcscpy_s &#x2F; _tcsncpystrcmp &#x2F; strncmp &#x2F; stricmp &#x2F; strnicmp比较字符串s1和s2\nstrcat &#x2F; strcat_s   &#x2F;&#x2F;hello+world，文件路径字符串追加&#x2F;连接函数，它的功能就是在一个字符串后面追加上另外一个字符串。\nstrchr &#x2F; strrchr &#x2F;&#x2F;返回位置地址，str，求文件名，扩展名。查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置.\nstrstr函数搜索一个字符串在另一个字符串中的第一次出现找到所搜索的字符串，则该函数返回第一次匹配的字符串的地址如果未找到所搜索的字符串，则返回NULL\nstrtok &#x2F; strtok_s  &#x2F;&#x2F;ip地址    strtok(st_ip,st_ip_delim);\n    strtok_s(NULL,st_s1_deilm,&amp;next);\n\n用于分解字符串，返回分解得到的字符串指针.atof &#x2F; atoi &#x2F; atol &#x2F; atoll &#x2F; _ttol()\n"},{"title":"条件编译","url":"/2023/11/01/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/","content":"在C语言源代码里,除了那些被注释了的代码不会被编译进程序里外,还有一种方式来规定代码是否会被编译进程序里,这就是所谓的条件编译,即代码只有在某种条件下才能编译进程序。因为有的代码只有在某些情况下才具有被执行的可能,在其它条件下这些代码要么无法执行,要么没有必要行。比如在Windows平台,有的函数只能在Vista以上平台才能被执行,那么在XP及以下的平台里就无法被执行,因此在XP及以下平台就没有必要将这部分代码编译进程序,有时候甚至还无法在这些平台里编译通过。又比如有的代码只能在X86平台才能执行,在X64平台下是无效的,因此也要对这部分代码进行条件编译.\n"},{"title":"枚举类型","url":"/2023/10/31/%E6%9E%9A%E4%B8%BE/","content":"enum枚举当一个变量的值被限于列出来二点值的范围内,那么这个变量就可以被定义为一个枚举类型的量.比如一个星期有7天,每一天都是确定的;假如用一个变量来表示一个星期的某一天,用其他类型都不是很恰当.于是就引入了枚举类型.在枚举类型中列出所有可能的取值,被说明为该”枚举”类型的变量取值不能超过定义的范围.枚举类型是一种基本数据类型,而不是像struct这样的一种构造类型,因为它不能再分解为任何的基本类型.\n"},{"title":"汇编语言基础知识1","url":"/2023/11/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/","content":"汇编语言由以下三类组成:1,汇编指令(机器码的助记符){核心:决定特性}2,伪指令(由编译器执行)3,其他符号(由编译器识别)\nCPU对储存器的读写:1,地址信息2,控制信息3,数据信息\n(1)汇编指令是机器指令的助记符,同机器指令一一对应。(2)每一种CPU都有自己的汇编指令集。(3)CPU可以直接使用的信息在存储器中存放。(4)在存储器中指令和数据没有任何区別,都是二进制信息。\nCPU工作原理(寄存器)bim源程序汇编指令不区分大小写.\nmov\n我们前面讲到,8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址,送入地址加法器合成物理地址。这里,需要看一下,是什么部件提供段地址。段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器:CS、DS、SS、ES。当 8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址.\n8086CPU的工作过成从CS:IP指向内存单元读取指令,读取的指令进入指令缓冲区.Debug是DOS,WINdows提供的实模式(8086)程序的调试工具.用 Debug 的R 命令查看,改变CPU 寄存器的内容:用 Debug 的 D 命令查看内存中的内容:用 Debug 的E命令改写内存中的内容;用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令:用 Debug 的T命令执行一条机器指令:用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令。\n","tags":["汇编语言"]},{"title":"测试","url":"/2023/11/03/%E6%B5%8B%E8%AF%95/","content":"diffIndex: languages/ini.js===================================================================--- languages/ini.js (revision 199)+++ languages/ini.js (revision 200)@@ -1,8 +1,7 @@ hljs.LANGUAGES.ini = &#123; case_insensitive: true,- defaultMode:- &#123;+ defaultMode: &#123; contains: [&#x27;comment&#x27;, &#x27;title&#x27;, &#x27;setting&#x27;], illegal: &#x27;[^\\\\s]&#x27; &#125;,*** /path/to/original timestamp--- /path/to/new timestamp****************** 1,3 ****--- 1,9 ----+ This is an important+ notice! It should+ therefore be located at+ the beginning of this+ document!! compress the size of the! changes. It is important to spell\n\n\n#include &lt;stdio.h&gt;= 0; --i) &#123;\n        y[i] = (x & 1) + '0';\n        x >>= 1;\n    &#125;\n    y[32] = '\\0';\n &#125;\n"},{"title":"源程序","url":"/2023/11/09/%E6%BA%90%E7%A8%8B%E5%BA%8F/","content":"操作系统操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统,都要提供一个称shell (外壳)的程序,用戶(操作人员)使用这个程序来操作计算机系统互作。DOS中有一个程序command.com,这个程序在 DOS 中称为命令解释器,也就是DOS系统的shell。程序加载后,ds中存放着程序所在内存区的 段地址,这个内存区的偏移地址为0,则程序所在的内存区的地址为:ds:0;这个内存区的前256个字节中存放的是PSP,dos用来和程序进行通信。从256字节处向后的空间存放的是程序.总结(续)所以,我们从ds中可以得到PSP的段地址SA,PSP的偏移地址为0,则物理地址为SA×16+0。因为PSP占256(100H)字节,所以程序的物理地址是:SAX16+0+256&#x3D;SA×16+16×16&#x3D;(SA+16) ×16+0可用段地址和偏移地址表示为:SA+10:0。﻿需要注意的是,在DOS中运行程序时,是command将程序加载入内存;所以程序运行结束后返回到command中,而在这里是debug将程序加载入内存,所以程序运行结束后要返回到Debug中。我们在DOS中用“Debug 1.exe”运行Debug对1.exe进行跟踪时,程序加载的顺序是:command加载Debug,Debug加载1.exe。返回的顺序是:从l.exe中的程序返回到Debug,从Debug返回到command。\n","tags":["汇编语言"]},{"title":"汇编语言寄存器(内存访问)","url":"/2023/11/07/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AF%84%E5%AD%98%E5%99%A8(%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE)/","content":"内存中文字的储存任何两个地址连续的内存单元,N号 单元和N+1号单元,可以将它们看 成两个内存单元,也可以看成一个 地址为N的字单元中的高位字节单元 和低位字节单元。CPU要读取一个内存单元的时候,必须 先给出这个内存单元的地址;在8086PC中,内存地址由段地址和偏移 地址组成。8086CPU中有一个RS寄存器,通常用来 存放要访问的数据的段地址。mov al,[0]已知的mov指令可完成的两种传送功能:(1)将数据直接送入寄存器:(2)将一个寄存器中的内容送入另一个寄存器中.除此之外,mov 指令还可以将一个内存 单元中的内容送入一个寄存器。\nmov bx,1000hmov ds,bxmov al,[0]\n从哪个内存单元送到哪个寄存器中呢?mov指令的格式:mov 寄存器名,内存单元地址“[…]”表示一个内存单元,“[…]”中的0表示内存单元的偏移地址。那么内存单元的段地址是多少呢?\n想要在段寄存器中存储数据要通过通用寄存器.\n字的传送已学Mov指令的几种形式:mou 寄存器,数据mov 寄存器,寄存器mov 寄存器,内存单元mov 内存单元,寄存器mov 段寄存器,寄存器add 寄存器,数据add 寄存器,寄存器add 寄存器,内存单元add 内存单元,寄存器sub 寄存器,数据sub 寄存器,寄存器sub 寄存器,内存单元sub 内存单元,寄存器 \n数据段和栈基本操作:入栈和出栈.push入栈pop出栈\n换个角度看:任意时刻,SS:SP指向栈顶元素,当栈为空的时 候,栈中没有元素,也就不存在栈顶元素所以SS:SP只能指向栈的最底部单元下面的单元, 该单元的偏移地址为栈最底部的字单元的偏移地址+2栈最底部字单元的地址为1000:000E,所以栈空时, SP&#x3D;0010H。\npush和pop指令的格式(2)Opush 段寄存器:将一个段寄存器中的数据入栈opop段寄存器:出栈,用一个段寄存器接收出栈的数据例如:push dspop es用栈来暂存以 后需要恢复的寄存器中的内容时,出栈 的顺序要和入栈的顺序相反,因为最后 入栈的寄存器的内容在栈顶,所以在恢 复时,要最先出栈。结论push、pop实质上就是一种内存传送指令, 可以在寄存器和内存之间传送数据,与mov指令不同的是,push和pop指令访问的内存单元的地址不是在指令中给出的,而是由SS:SP指出的.\n将一段内存当作栈段,仅仅是我们在编 程时的一种安排,CPU 并不会由于这种 安排,就在执行push、pop等栈操作指令 时就自动地将我们定义的栈段当作栈空 间来访问。\n我们可以将一段内存定义为一个段,用 一个段地址指示段,用偏移地址访问段 内的单元。这完全是我们自己的安排。1,我们可以用一个段存放数据,将它定义 为“数据段”;2,我们可以用一个段存放代码,将它定义 为“代码段”;3,我们可以用一个段当作栈,将它定义为 “栈段”;\n标号第一个标号指代了一个地址。codesg:放在segment的前面,作为一个段的名称,这个段的名称最终将被编译、连接程序处理为一个段的段地址。\n程序的结构任务:编程运算 2^3。定义一个段实现处理任务程序结束段与段寄存器关联\n汇编程序assume cs:abcabc segmentmov ax,2add ax,axadd ax,axabc endsend\nDOS是一个单任务操作系统。如一个程序P2在可执行文件中,则必须有一个正在运行的程序P1,将P2从可执行文件中加载入内存后,将CPU的控制权交给P2,P2才能得以运行。P2开始运行后,P1暂停运行.而当P2运行完毕后,应该将CPU的控制权交还给使它得以运行的程序P1,此后,P1继续运行.我们的程序没有像显示器输出任何信息程序只是做了一些将数据送入寄存器和加法的操作,而这些事情,我们不可能从显示屏上看出来。程序执行完成后,返回,屏幕上再次出现操作系统的提示符。\n编译连和接的作用连接的作用有以下几个:当源程序很大时,可以将它分为多个源程序文件来编译,每个源程序编译成为目标文件后,再用连接程序将它们连接到一起,生成一个可执行文件;程序中调用了某个库文件中的子程序,需要将这个库文件和该程序生成的目标文件连接到一起,生成一个可执行文件;一个源程序编译后,得到了存有机器码的目标文件,目标文件中的有些内容还不能直接用来生成可执行文件,连接程序将这此内容处理为最终的可执行信息。所以,在只有一个源程序文件,而又不需要调用某个库中的子程序的情况下,也必须用连接程序对目标文件进行处理,生成可执行文件。注意,对于连接的过程,可执行文件是我们要得到的最终结果。\n","tags":["汇编语言"]},{"title":"特殊运算符","url":"/2023/10/31/%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"位运算位运算是一种基于二进制数的计算方式，主要包括以下几种类型：\n\n按位与（AND）：对应位都为1时结果才为1，否则为0。例如，1010 &amp; 1100 的结果是 1000。\n按位或（OR）：对应位只要有一个为1时结果就为1，否则为0。例如，1010 | 1100 的结果是 1110。\n按位异或（XOR）：对应位相同为0，不同为1。例如，1010 ^ 1100 的结果是 0110。\n按位取反（NOT）：0变1，1变0。例如，~1010 的结果是 0101。\n左移（&lt;&lt;）：将二进制数的所有位向左移动指定的位数，右边用0填充。例如，1010 &lt;&lt; 2 的结果是 101000。\n右移（&gt;&gt;）：将二进制数的所有位向右移动指定的位数，左边用0填充。例如，1010 &gt;&gt; 2 的结果是 10。这些运算在编程中非常常见，可以用于进行高效的数学运算，如乘法、除法和模运算等。同时，位运算也常用于处理二进制数据，如图像和音频数据。\n\n#define SETFLAG(a,n) ((a)|&#x3D;(1&lt;&lt;(n)))&#x2F;&#x2F;把整数a中的第n位置为1#define CLEARFLAG(a,n) ((a)&amp;&#x3D;~(1&lt;&lt;(n)))&#x2F;&#x2F;把整数a中第n位置为0#define FLAGON(a,n) ((a)&amp;(1&lt;&lt;(n)))&#x2F;&#x2F;判断整数a中第n位是否为1\n#define offserof(s,m) (size_t)&amp;(((s*)0)-&gt;m)计算m在结构体s中的偏移\n宏的注意事项(1)宏名一般用大写(2)使用宏可提高程序的通用性和易读性,便于修改.例如:数组的大小常用宏定义(3)预处理是在编译之前的处理,而编译工作的任务之一就是语法检查,预处理不做语法检查.(4)宏定义末尾不加分号.(5)宏定义通常在文件的最开头,写在函数的花括号外边,作用域为其后边的程序.(6)宏定义允许被嵌套(宏定义中包括其他宏定义)(7)字符串””中永远不包含宏.(8)宏定义不分配内存,变量定义分配内存.(9)宏定义不存在类型问题,他的参数也是无类型的.\n宏定义中一个井号和两个井号对于一个井号来说,宏会把#的内容当作一个字符串来替换.\n#define CAT(c) “123”#c于是:CAT(abc)就会被替换为:”123””abc”-&gt;”123abc”#define STR(c) #c于是:STR(a)就会被替换为:”a”.\n对于连个井号来说,用于把两侧的参数合并为一个符号.比如:\n#define combine(a,b,c) a##b##c于是:combine(1,2,3)就会被替换为;123;而combine(“1”,”2”,”3”)就会被替换为”123”.#define WIDE(str) L##str则会将形参str的前面加上L比如:WIDE(“abc”)就会被替换为L”abc”.\n宏的二义性只是在预处理的地方把代码展开,不需要额外的空间和时间方面的开销,所以调用一个宏比调用一个函数更有效率.但是宏容易产生二义性,也不能访问对象的私有成员,这是宏的局限.\n","tags":["C语言code"]},{"title":"结构体指针和数组","url":"/2023/10/29/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/","content":"结构体赋值时的拷贝typedef struct _struct1{    …    …}struct1;struct1 s1&#x3D;{1,’a’};struct1 s2&#x3D;s1;&#x2F;&#x2F;?struct1 s3;s3&#x3D;s1;&#x2F;&#x2F;?\n浅拷贝和深拷贝拷贝中默认是浅拷贝\n结构体数组结构体数组的初始化和应用结构体指针数组\n\n    \n        点击我查看内容\n    \n    \n        #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;\ntypedef struct _student{    int score;    char name[16];}student,*pstudent;\nint main(){    student stu1[3] &#x3D; { {78,”tom”}, {83,”lily”}, {79,”david”} };    student stu2[3] &#x3D; { 0 };    pstudent stu3[3] &#x3D; { 0 };\nfor (int i = 0; i &lt; 3; i++)\n{\n    printf(&quot;Please input score and name for %d\\n&quot;, i + 1);\n    scanf_s(&quot;%d,%s&quot;, &amp;stu2[i].score, stu2[i].name, 16);\n}\n\nfor (int i = 0; i &lt; 3; i++)\n{\n    stu3[i] = &amp;stu1[i];\n}\n\nfor (int i = 0; i &lt; 3; i++)\n{\n    printf(&quot;stu1:%d:score:%d,name:%s\\n&quot;, i, stu1[i].score,\n        stu1[i].name);\n}\n\n\n    \n\n\n\n结构体做参数传指针传值判断两个同学的成绩\n"},{"title":"结构体","url":"/2023/10/28/%E7%BB%93%E6%9E%84%E4%BD%93/","content":"结构体定义:struct(结构体)每一个构成成员可以是一个基本数据类型或者又是一个构造类型.四种定义结构体的方法一,struct 结构名{    成员列表}struct 结构名 变量名;二,struct 结构名{    成员列表}变量名1,变量名2;三,struct{    成员列表}变量名1,变量名2;四,typedef struct_结构名{    成员列表}结构名,*p结构名;结构名 变量名;\n结构体的定义,初始化与成员的访问\\#include &lt;stdio.h>\n\\#include &lt;string.h>\n\ntypedef struct \\_student\n&#123;\n\tint id;\n\tint age;\n\tchar name\\[20\\];\n\tchar sex;\n\tfloat score;\n&#125;student,\\*pstudent;\n\nint main()\n&#123;\n\tstudent s1 = &#123;17,22,\"Tom\",'M',99.5f&#125;;\n\tstudent s2 = &#123;0&#125;;\n\ns2.id = 19;\ns2.age = 23;\nstrcpy_s(s2.name,20, \"lily\");\ns2.sex = 'F';\ns2.score = 87.5f;\n\nprintf(\"id:%d,age:%d,name:%s,sex=%c,%f\\\\n\",\n\ts1.id,s1.age,s1.name,s1.sex,s1.score);\nprintf(\"id:%d,age:%d,name:%s,sex=%c,%f\\\\n\",\n\ts2.id, s2.age, s2.name,s2.sex,s2.score);\n\nreturn 0;\n&#125;\n\n结构体指针访问\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\n\\#include &lt;stdlib.h&gt;\n\ntypedef struct \\_student\n&#123;\n\tint id;\n\tint age;\n\tchar name\\[20\\];\n\tchar sex;\n\tfloat score;\n&#125;student, \\* pstudent;\n\nint main()\n&#123;\n\tstudent s1 &#x3D; &#123; 17,22,&quot;Tom&quot;,&#39;M&#39;,99.5f &#125;;\n\tstudent s2 &#x3D; &#123; 0 &#125;;\n\ns2.id &#x3D; 19;\ns2.age &#x3D; 23;\nstrcpy_s(s2.name, 20, &quot;lily&quot;);\ns2.sex &#x3D; &#39;F&#39;;\ns2.score &#x3D; 87.5f;\n\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;,\n\ts1.id, s1.age, s1.name, s1.sex, s1.score);\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;,\n\ts2.id, s2.age, s2.name, s2.sex, s2.score);\n\nstudent* ps1 &#x3D; &amp;s1;\npstudent ps2 &#x3D; &amp;s2;&#x2F;&#x2F;pstudent &#x3D;&#x3D; student \\*\n\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;,\n\tps1-&gt;id,ps1-&gt;age,ps1-&gt;name,ps1-&gt;sex,ps1-&gt;score);\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;,\n\tps2-&gt;id, ps2-&gt;age, ps2-&gt;name, ps2-&gt;sex, ps2-&gt;score);\n\n&#x2F;&#x2F;ps1+1\n&#x2F;&#x2F;sizeof(ps1),sizeof(\\*ps1)\\&#x3D;\\&#x3D;sizeof(student)\n\nprintf(&quot;sizeof(ps1)&#x3D;%d,sizeof(*ps1)&#x3D;%d,sizepf(student)&#x3D;%d\\\\n&quot;,\n\tsizeof(ps1),sizeof(*ps1),sizeof(student));\n\nprintf(&quot;sizeof(student*):%d\\\\n&quot;,sizeof(student\\*));\n\nprintf(&quot;ps1:%p,ps1+1:%p\\\\n&quot;,ps1,ps1+1);\n\nstudent* ps3 &#x3D; (student*)malloc(sizeof(student));\nif (ps3 &#x3D;&#x3D; NULL)\n&#123;\nreturn -1;\n&#125;\nmemset(ps3, 0, sizeof(student));\nps3-&gt;id &#x3D; 25;\nps3-&gt;age &#x3D; 24;\nstrcpy_s(ps3-&gt;name, 20, &quot;lilei&quot;);\nps3-&gt;sex &#x3D; &#39;M&#39;;\nps3-&gt;score &#x3D; 86.5f;\n\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\\\n&quot;,\n\tps3-&gt;id, ps3-&gt;age, ps3-&gt;name, ps3-&gt;sex, ps3-&gt;score);\nfree(ps3);\nps3 &#x3D; NULL;\n\nreturn 0;\n&#125;\n\n*与-&gt;,.运算符首先-&gt;与.运算符比*优先级高\ntypedef struct \\_student\n&#123;\n\tint id;\n\tint age;\n\tchar name\\[20\\];\n\tchar sex;\n\tfloat score;\n&#125;student, \\* pstudent;\nstudent stdt&#x3D;&#123;...&#125;;\npstdt&#x3D;&amp;stdt;\n\\*pstdt-&gt;sex--&gt;\\*(pstdt-&gt;sex)&#x2F;&#x2F;错误,因为sex不是一个指针.\n\\*pstdt-&gt;name--&gt;\\*(pstdt-&gt;name)&#x2F;&#x2F;正确的,因为name是一个指针,name是一个字符.\n\\*pstdt.sex--&gt;\\*(pstdt.sex)&#x2F;&#x2F;错误,pstdt是指针,不支持.运算符,没有.这个运算符.\n(\\*pstdt).sex--&gt;stdt.sex\\&#x2F;&#x2F;正确,\\*pstdt就是stdt.\n\n结构体中的结构体\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\n\\#include &lt;stdlib.h&gt;\n\ntypedef struct _date\n&#123;\n\tint year;\n\tint month;\n\tint day;\n\n&#125;date;\n\ntypedef struct _student\n&#123;\n\tint id;\n\tint age;\n\tchar name[20];\n\tchar sex;\n\tfloat score;\n\tdate birthday;\n&#125;student, * pstudent;\n\nint main()\n&#123;\n\tstudent s1 &#x3D; &#123; 17,22,&quot;Tom&quot;,&#39;M&#39;,99.5f,&#123;1995,2,5&#125;&#125;;\n\tstudent s2 &#x3D; &#123; 0 &#125;;\n\ns2.id &#x3D; 19;\ns2.age &#x3D; 23;\nstrcpy_s(s2.name, 20, &quot;lily&quot;);\ns2.sex &#x3D; &#39;F&#39;;\ns2.score &#x3D; 87.5f;\ns2.birthday.year &#x3D; 1997;\ns2.birthday.month &#x3D; 6;\ns2.birthday.day &#x3D; 21;\n\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f,&quot;\n\t&quot;year:%d,month:%d,day:%d\\n&quot;,\n\ts1.id, s1.age, s1.name, s1.sex, s1.score,\n\ts1.birthday.year,s1.birthday.month,s1.birthday.day);\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f,&quot;\n\t&quot;year:%d,month:%d,day:%d\\n&quot;,\n\ts2.id, s2.age, s2.name, s2.sex, s2.score,\n\ts2.birthday.year,s2.birthday.month,s2.birthday.day);\n\nstudent* ps1 &#x3D; &amp;s1;\npstudent ps2 &#x3D; &amp;s2;&#x2F;&#x2F;pstudent &#x3D;&#x3D; student *\n\t\n\nprintf(&quot;*ps2-&gt;name:%c\\n&quot;, *ps2-&gt;name);\n\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\n&quot;,\n\tps1-&gt;id,ps1-&gt;age,ps1-&gt;name,ps1-&gt;sex,ps1-&gt;score);\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f\\n&quot;,\n\tps2-&gt;id, ps2-&gt;age, ps2-&gt;name, ps2-&gt;sex, ps2-&gt;score);\n\n&#x2F;&#x2F;ps1+1\n&#x2F;&#x2F;sizeof(ps1),sizeof(*ps1)&#x3D;&#x3D;sizeof(student)\n\nprintf(&quot;sizeof(ps1)&#x3D;%d,sizeof(*ps1)&#x3D;%d,sizepf(student)&#x3D;%d\\n&quot;,\n\tsizeof(ps1),sizeof(*ps1),sizeof(student));\n\nprintf(&quot;sizeof(student*):%d\\n&quot;,sizeof(student*));\n\nprintf(&quot;ps1:%p,ps1+1:%p\\n&quot;,ps1,ps1+1);\n\nstudent* ps3 &#x3D; (student*)malloc(sizeof(student));\nif (ps3 &#x3D;&#x3D; NULL)\n&#123;\n\treturn -1;\n&#125;\nmemset(ps3, 0, sizeof(student));\nps3-&gt;id &#x3D; 25;\nps3-&gt;age &#x3D; 24;\nstrcpy_s(ps3-&gt;name, 20, &quot;lilei&quot;);\nps3-&gt;sex &#x3D; &#39;M&#39;;\nps3-&gt;score &#x3D; 86.5f;\nps3-&gt;birthday.year &#x3D; 1996;\nps3-&gt;birthday.month &#x3D; 6;\nps3-&gt;birthday.day &#x3D; 7;\n\nprintf(&quot;id:%d,age:%d,name:%s,sex&#x3D;%c,%f,&quot;\n\t&quot;year:%d,month:%d,day:%d\\n&quot;,\n\tps3-&gt;id, ps3-&gt;age, ps3-&gt;name, ps3-&gt;sex, ps3-&gt;score,\n\tps3-&gt;birthday.year,ps3-&gt;birthday.month,\n\tps3-&gt;birthday.day);\nfree(ps3);\nps3 &#x3D; NULL;\n\nreturn 0;\n&#125;\n\n结构体中的指针-1\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\n\\#include &lt;stdlib.h&gt;\n\ntypedef struct _student\n&#123;\n\tint id;\n\tint age;\n\tchar *name;\n\tchar sex;\n\tfloat score;\n&#125;student,*pstudent;\n\nint main()\n&#123;\n&#x2F;&#x2F;student s1 &#x3D; &#123; 11,21,&quot;Tom&quot;,&#39;M&#39;,97.5f&#125;;\nstudent s2 &#x3D; &#123; 0 &#125;;\n\ns2.id &#x3D; 15;\ns2.age &#x3D; 22;\n\ns2.name &#x3D; (char*)malloc(20);\nif (s2.name &#x3D;&#x3D; NULL)\n&#123;\n\treturn -1;\n&#125;\nstrcpy_s(s2.name,20,&quot;lily&quot;);\ns2.sex &#x3D; &#39;M&#39;;\ns2.score &#x3D; 94.5f;\n\t\n\t\n\t\nstudent* s3 &#x3D; (student*)malloc(sizeof(student));\nif (s3 &#x3D;&#x3D; NULL)\n&#123;\n\treturn -1;\n&#125;\nmemset(s3, 0, sizeof(student));\ns3-&gt;id &#x3D; 18;\ns3-&gt;age &#x3D; 23;\ns3-&gt;name &#x3D; (char*)malloc(20);\nif (s3-&gt;name &#x3D;&#x3D; NULL)\n&#123;\n\tfree(s3);\n\treturn -1;\n&#125;\nmemset(s3-&gt;name, 0, 20);\nstrcpy_s(s3-&gt;name, 20, &quot;david&quot;);\ns3-&gt;sex &#x3D; &#39;M&#39;;\ns3-&gt;score &#x3D; 92.5f;\n\n&#x2F;&#x2F;printf(&quot;s1:name:%s\\n&quot;,s1.name);\nprintf(&quot;s2:name:%s\\n&quot;, s2.name);\nprintf(&quot;s3.name:%s\\n&quot;, s3-&gt;name);\n\nfree(s2.name);\ns2.name &#x3D; NULL;\nfree(s3-&gt;name);\ns3-&gt;name &#x3D; NULL;\nreturn 0;\n&#125;\n\n\n结构体中的指针-2:链表和树typedef struct _node{int value;struct _node *next;}node,*pnode;\ntypedef struct _btree{int data;struct _btree *left;struct _btree *right;}btree,*pbtree;\n"},{"title":"聚合体","url":"/2023/10/29/%E8%81%94%E5%90%88%E4%BD%93/","content":"联合体(UNION)定义:C语言编程的时候,需要使几种不同类型的变量存放到同一段内存单元中.也就是使用覆盖技术,几个变量互相覆盖重叠,这种几个不同的变量共同占用一段内存的结构,在C语言中,被称为联合体(union),也被称为共用体.\n\n    \n        点击我查看内容\n    \n    \n        union foo{    char s[10];    int i;}a,b;\nunion foo{    char s[10];    int i;};union foo s;\ntypedef union{    char s[10];    int i;}foo;foo a;\ntypedef union _foo{    char s[10];    int i;}foo,* pfoo;foo a;\n\n    \n\n结构体与联合体的区别1,联合体和结构体都是由多个不同的数据类型成员组成的,但在任何同一时刻,共用体只存放了一个被选中的成员而结构体的所有成员都存在.2,对于联合体的不同成员赋值,将会对其他成员重写,原来的成员的值就不存在了,而对于结构体的不同成员赋值是互不影响的.3,结构体里可以含有union的成员,union里也可以含结构体成员.结构体:先存放数据成员;联合体:并排存放数据成员.\n"},{"title":"汇编语言指令","url":"/2023/11/09/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%8C%87%E4%BB%A4/","content":"加汇编语言中的 add 指令用于将两个操作数相加，并将结果存储在目标操作数中。add 指令的语法如下：\nadd 目标, 源\n这里，目标 是将存储加法结果的操作数，源 是将与目标操作数相加的操作数。目标 和 源 可以是寄存器或内存位置。\n减汇编语言中的 sub 指令用于从目标操作数中减去源操作数，并将结果存储在目标操作数中。sub 指令的语法如下：\nsub 目标, 源\n这里，目标 是将存储减法结果的操作数，源 是将从目标操作数中减去的操作数。目标 和 源 可以是寄存器或内存位置.\n乘汇编语言中的 mul 指令用于执行无符号乘法运算。mul 指令的语法如下：\nmul 源\n这里，源 是与累加器（AX，EAX 或 RAX，取决于操作数的大小）一起进行乘法运算的操作数。结果将存储在 DX:AX，EDX:EAX 或 RDX:RAX 中，取决于操作数的大小。例如，以下代码将 eax 寄存器中的值与 ebx 寄存器中的值相乘，并将结果存储在 edx:eax 中：\nmov eax, ebx\nmul ecx\n在这个例子中，eax 中的值与 ecx 中的值相乘，结果存储在 edx:eax 中。\n除汇编语言中的 div 指令用于执行无符号除法运算。div 指令的语法如下：\ndiv 源\n这里，源 是作为除数的操作数。被除数是累加器（AX，EAX 或 RAX，取决于操作数的大小）或 DX:AX，EDX:EAX 或 RDX:RAX，取决于操作数的大小。商将存储在累加器中，余数将存储在 DX，EDX 或 RDX 中。例如，以下代码将 eax 寄存器中的值除以 ebx 寄存器中的值，并将商存储在 eax 中，余数存储在 edx 中：\nmov eax, ebx\ndiv ecx\n在这个例子中，eax 中的值除以 ecx 中的值，商存储在 eax 中，余数存储在 edx 中。\n除了 div 指令，汇编语言还有一个用于执行带符号除法的 idiv 指令。idiv 指令的语法如下：\nidiv 源\n这里，源 是作为除数的操作数。被除数是累加器（AX，EAX 或 RAX，取决于操作数的大小）或 DX:AX，EDX:EAX 或 RDX:RAX，取决于操作数的大小。商将存储在累加器中，余数将存储在 DX，EDX 或 RDX 中。例如，以下代码将 eax 寄存器中的值除以 ebx 寄存器中的值，并将商存储在 eax 中，余数存储在 edx 中：\nmov eax, ebx\nidiv ecx\n在这个例子中，eax 中的值除以 ecx 中的值，商存储在 eax 中，余数存储在 edx 中。idiv 指令与 div 指令的主要区别在于，idiv 执行的是带符号的除法，而 div 执行的是无符号的除法。\n跳转指令JMP  ;无条件跳转\nJE   ;&#x2F;&#x2F;等于则跳转\t\t\t同JZJNE  ;&#x2F;&#x2F;不等于则跳转\t\t同JNZJA   ;&#x2F;&#x2F;无符号大于则跳转JNA  ;&#x2F;&#x2F;无符号不大于则跳转JAE  ;&#x2F;&#x2F;无符号大于等于则跳转\t\t同JNBJNAE ;&#x2F;&#x2F;无符号不大于等于则跳转\t同JBJB   ;&#x2F;&#x2F;无符号小于则跳转JNB  ;&#x2F;&#x2F;无符号不小于则跳转JBE  ;&#x2F;&#x2F;无符号小于等于则跳转\t\t同JNAJNBE ;&#x2F;&#x2F;无符号不小于等于则跳转\t同JAJG   ;&#x2F;&#x2F;有符号大于则跳转JNG  ;&#x2F;&#x2F;有符号不大于则跳转JGE  ;&#x2F;&#x2F;有符号大于等于则跳转\t\t同JNLJNGE ;&#x2F;&#x2F;有符号不大于等于则跳转\t同JLJL   ;&#x2F;&#x2F;有符号小于则跳转JNL  ;&#x2F;&#x2F;有符号不小于则跳转JLE  ;&#x2F;&#x2F;有符号小于等于则跳转\t\t同JNGJNLE ;&#x2F;&#x2F;有符号不小于等于则跳转\t同JGJZ   ;&#x2F;&#x2F;为零则跳转JNZ  ;&#x2F;&#x2F;不为零则跳转JS   ;&#x2F;&#x2F;为负则跳转JNS  ;&#x2F;&#x2F;不为负则跳转JC   ;&#x2F;&#x2F;进位则跳转JNC  ;&#x2F;&#x2F;不进位则跳转JO   ;&#x2F;&#x2F;溢出则跳转JNO  ;&#x2F;&#x2F;不溢出则跳转JP   ;&#x2F;&#x2F;为偶则跳转JNP  ;&#x2F;&#x2F;不为偶则跳转JPE  ;&#x2F;&#x2F;奇偶位置位则跳转\t\t同JPJPO  ;&#x2F;&#x2F;奇偶位复位则跳转\t\t同JNP\nTest指令test指令用于两个操作数的按位AND运算，并根据结果设置标志寄存器，结果本身不会写回到目的操作数。(1) AND 运算结果为0时， ZF(zero flag)置位(2) test可以影响CF，OF，PF，SF，ZF标志位(3) 两个操作数相等,同时为0时,AND 结果为0,此时ZF置位。例如test和je的连用\nTest eax,eax\nje some_address\n\nmov系列指令MOVSX说明:带符号扩展传送指令符号扩展的意思是,当计算机存储某一个有符号数时,符号位位于该数的第一位,所以，当扩展一个负数的时候需要将扩展的高位全赋为1.对于正数而言，符号扩展和零扩展MOVZX是一样的，将扩展的高位全赋为0.\nMOVZX功能:将8位或16位的OPS零扩展为16位或32位,在传给OPD.格式:\nMOVZX OPD,OPS\n说明:所谓零扩展,就是把新扩展的高位字节填0,这可以保证无符号数扩展后还是原来的无符号数.至于什么时候用符号扩展,什么时候用零扩展,视程序中是用带符号数还是无符 号数操作而定.样列：\nmovzx edi,bx\t\t; movzx 扩展高位为0，并把其赋值到edi\n\nmovsb movsw movsd 指令详解\n这三个指令，都是数据传送指令,都是从源地址向目的地址传送数据。\n16位模式下:\n源地址是`DS:SI`,目的地址是`ES:DI`  \n32位模式下:  \n源地址是`DS:ESI`,目的地址是`ES:EDI`\n注意:在传送完成之后，`SI`和`DI`(或者`ESI`和`EDI`)会增加或者减小.\n当`DF`=0时，表示正向传送，传送之后`SI`和`DI`(或者`ESI`和`EDI`)的值会增加;\n当`DF`=1时，表示反向传送，传送之后`SI`和`DI`(或者`ESI`和`EDI`)的值会减小;\n区别:\n`MOVSB`:传送一个字节，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`1`.\n`MOVSW`:传送一个字，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`2`.\n`MOVSD`:传送一个双字，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`4`.\n单纯的`movsb/ movsw/ movsd`只能执行一次，如果希望处理器自动地反复执行，可以加上指令前缀`rep`;在寄存器`CX`（16位模式）或者`ECX`（32位模式）中设置传送的次数。当`CX`/`ECX`不等于0时，则执行`movsb/ movsw/ movsd`,执行后，`CX`/`ECX`的值减一，直到减为0为止.\n### rep stosd循环 \n从`lea edi`,`EBP+arg_0`开始,到rep stosd结束.EDI中存入的是循环操作的起始地址,ECX存入的是循环次数,EAX是循环填入的值.这一段的操作就是从`EBP+var_40`处开始,循环十次,向下依次填入CCCCCCCC,写入的长度由EAX决定,32位.\n### lea指令\nlea eax，addr\n就是将表达式addr的值放入eax寄存器，示例如下：\nlea eax,401000h; 将值401000h写入eax寄存器中\nlea指令右边的操作数表示一个精指针，上述指令和mov eax，401000h是等价的\n2、lea eax，dword ptr ebx;将ebx的值赋值给eax\n3、lea eax，c；其中c为一个int型的变量，该条语句的意思是把c的地址赋值给eax；\n","tags":["汇编语言"]}]