[{"title":"P12","url":"/2023/10/18/P12/","content":"P12字符类型：char（1）&#x2F;wchar_t（2或4）整型：short（2）&#x2F;int（4）&#x2F;long(4或8)&#x2F;long long(8)&#x2F;_int64(8)实数单精度：float（4）实数双精度：double（8）有符号和无符号：signed&#x2F;unsdigned,(signed)int&#x2F;unsigned int布尔类型：bool，0&#x2F;1（true&#x2F;false）C99&lt;stdbool.h&gt;typedef int bool#define true 1#define false 0\n字符编码有Ascll，utf系列，unicode。·a·是ascll的L·a·是unicode的NULL，0，’\\0’都是一样的，都是值0NULL虽然值是0，但是它的含义不一样，或者说它的类型不一样。NULL是指针类型，不过它是空指针，即值为0‘\\0’我们都知道\\是转义符，用单引号包起来，再加转义，实际上就是0，只不过它表示的是字符“0”用双引号包裹的0是字符串\n#include &lt;stdio.h&gt;#include &lt;math.h&gt;\nvoid main(){    float a &#x3D; 0;\nif (fabs(a)&lt; 1e-6)\n&#123;\n    printf(&quot;a 等于 0\\n&quot;);\n&#125;\nelse\n&#123;\n    printf(&quot;a 不等于 0\\n&quot;);\n&#125;\n\nreturn;\n\n}\n#include &lt;stdio.h&gt;#include &lt;math.h&gt;\nvoid main(){    double a &#x3D; 0;\nif (fabs(a)&lt; 1e-15)\n&#123;\n    printf(&quot;a 等于 0\\n&quot;);\n&#125;\nelse\n&#123;\n    printf(&quot;a 不等于 0\\n&quot;);\n&#125;\n\nreturn;\n\n}\n"},{"title":"P13","url":"/2023/10/18/P13/","content":"P13类型长度-sizeof（是一个操作符，在编译阶段就确定）char[-128,127][0,255]short[-32768,32767][0,65535]int&#x2F;long[-2147483648,2147483647][0,4294967295]float[-3.410^38,3.410^38]double[-1.710^308,1.710^308]无符号的int最小为0，最大为-1（2进制的位全是1）有符号的intint max &#x3D; 0x7fffffff除符号位全是1int min &#x3D; 0x80000000除符号位全是0在整数上溢出1是最小值，整数下溢出1是最大值。 (char)(-128*-1)&#x3D;-12816位系统中，int有符号的取值范围是[-216&#x2F;2,216&#x2F;2-1]无符号是[0,65536]所以当i&#x3D;65536是溢出1位则是-32768，i&#x3D;65535时为-32767.\n"},{"title":"P16","url":"/2023/10/18/P16/","content":"变量\n变量是内存或寄存器中用一个标识符命名的存储单元，可以用来存储一个特定类型的数据，并且数据的值在程序运行过程中可以进行修复。\n变量就至少可以给我们提供两个信息：一是变量的地址，即就是，操作系统为变量在内存中分配的若干内存首地址；二是变量的值，也就是，变量在内存中所分配的那些内存单元中所存放的数据。\n常量没有地址。\n变量的命名\n必须由字母，下划线和数字组成，但是第一个字符必须是字母，下划线也被看作是字母。\n大写字母和小写字母是不同的字符。\n局部变量建议用比较短的名，全局变量使用比较长的名字（命名变量不用拼音尽量符合英语逻辑）。\n1\n要获取变量的地址，可以用取地址符 (&amp;)来操作变量\n2\n操作系统为变量在内存中分配的若干内存首地址，变量在内存中所分配的那些内存单元中所存放的数据\n3\n3.14f中f代表这是一个单精度的数\n4\n3value，_value,value,v1\n第一个不和法。\n"},{"title":"P15","url":"/2023/10/18/P15/","content":"强制转换格式（新类型）变量丢失字节从高位开始丢失。从小到大转换要用符号位填充，整数用0填充，负数用1填充。自动（隐式）转换1，若参与的运算量的类型不同，则先转换成同一类型，然后进行运算。2，转换按数据长度的增加方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后在进行运算。字节数不同的转换为高字节进行运算，字节相同的如果一种有符号另一种没有符号，则转换为无符号类型。\n自动转换2\n进行算数运算（加减乘除取余及符号运算）时，不同类型数据必须转换成同一类型的数据才能运算，算数转换原则为：\n进行运算时，以表达式中最长的类型为主，将其他类型数据均转换成该类型，\na，若运算数中有double型或float型，则其他类型的数据均转换成double类型进行运算。\nb，若运算中最长的类型为long型，则其他类型数均转换成long型数。\nc，若运算中最长型为int型，则char型也转换成int型进行运算。算数转换是在运算过程中自动完成的。\nd，函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。char和short会被转换成int，float会被转换成double。\nf，printf函数会将char和short转换成int；float会被转换成double传递。\ng，函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。\n注意事项：\n作业：\n1从int转换为char时字节是减少的512的2进制是0000 0001 0000 0000变为16进制是0x01 00，进行转换从大到小是舍弃高位变成0x00，之后输出的printf会把输出的char再转换成int就是0x00 00也就是0.\n首先我们能知道在int类型中0x000000ff是255转换为char从高位舍弃是0x00ff还是255但255是无符号的char类型的最大值但有符号时是-1而有符号转无符号时内部储存方式不变但是外部是无符号的%lu所表示的是long unsigned即4字节int也是4字节从char转long要填充，我们知道最小值向下溢出是最大数值就是2*32-1。\n3\n短整型变长整型要在符号位填充0，长整形变短整型要舍弃高位。\n4\n有符号变无符号时内部储存方式不变但是外部要表示无符号。\n看有符号数的最高位是否为1，如果不为1（即为0），则无符号数就直接等于有符号数；如果有符号数的最高位为1，则将有符号数取补码，得到的数就是无符号数。\n及无符号变有符号时，原值照赋，存储方式不变但是外部值可能改变。\n"},{"title":"P18","url":"/2023/10/19/P18/","content":"以 int buf[100]&#x3D;{0} 为例，集中讨论 buf、buf[0]、&amp;buf[0]、&amp;buf 四个字符含义的内涵。\n1、buf：有两层含义，一是数组名，sizeof(buf) 时就是数组名的含义；二是等价于 &amp;buf[0]，表示数组的第一个元素的首字节地址，是一个常量值。因此，既然是一个常量值，无论从哪层含义来使用，buf 都不能作为左值来使用，但是，buf 可以用来作为右值来使用，作为右值使用时，应理解为地址。\n2、buf[0]：表示存储第一个元素的空间，可对其进行读写操作，所以可以作为左值来使用。\n3、&amp;buf[0]：等价于 buf，是一个地址常量，只能作为右值使用。\n4、&amp;buf：表示地址的首地址，是一个地址常量，只能作为右值使用。\nbuf 与 &amp;buf 的值相等，但是含义完全不同。printf(“%p\\n”,buf) 与 printf(“%p\\n”,&amp;buf) 这两条代码的打印结果是相同的，表明它们的值是相同的，但是 printf(“%p\\n”,buf+1) 与 printf(“%p\\n”,&amp;buf+1) 的结果完全不同，因为它们的含义不同，buf 表示数组的第一个元素的首字节地址，加 1 加的时一个元素空间的大小；&amp;buf 表示的是整个数组的首地址，加 1 加的是整个数组空间大小，数组首地址主要用于构建多维数组，对于一堆数组来说，数组首地址没有太大的实用意义。\nfflush(sidin)使用回车键删掉上一个输入的数值。\nchar c1&#x3D;getch();直接输出值{不会在屏幕上直接显示}\nchar c2&#x3D;getchar();需要回车键输出值\n使用上述两个需要有#include &lt;conio.h&gt;\ngetch()可以间隔分段使用。\nscanf_s可以用来限制输入的字符防止数值溢出。（只有微软有）\ngets,puts平替scanf。\n输入一个字符串时不用&amp;，而变量需要在前面加&amp;\n使用_wchart定义，在scanf中使用%lc或%C输入\nscanf后加入_s可以限制字符的输入防止溢出。\nget同理\n4996警告是一种数据溢出警告当输入的数值过大时溢出的数值可能会损坏其他数据造成破坏。\n"},{"title":"P17","url":"/2023/10/19/P17/","content":"\n静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。 它主要存放静态数据、全局数据和常量。\n栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。\n 堆区：亦称动态内存分配\n11.0属于没有被定义的状态，此时只能打印出0 or 1.\n"},{"title":"P19","url":"/2023/10/19/P19/","content":"i++和++i的区别：\n一，C语言内建型别：\ni++;\n++i;\nC++里，i是一个对象，++i比i++效率高。\n二，在复合表达式或赋值语句中：\nint i&#x3D;0；\nint a&#x3D; i++;a&#x3D;i;i&#x3D;i+1\nint i&#x3D;0;\nint b&#x3D; ++i;i&#x3D;i+1;b&#x3D;i-&gt;b&#x3D;1,i&#x3D;1\n三，函数中\ni++\n++i\nI++,++i属于不确定（由编译器决定） \n\n对于i&#x3D;&#x3D;0和0&#x3D;&#x3D;i来说，在if（）{}时是没错的但是，如果输入少&#x3D;时i&#x3D;&#x3D;0不会报错，产生的错误不易被发现，但是0&#x3D;&#x3D;i就会报错使错误更容易被发现改正。\na%&#x3D;5是指a&#x3D;a%5取余，a*&#x3D;5是指a×5.\n"},{"title":"P20","url":"/2023/10/19/P20/","content":"\n"},{"url":"/2023/10/16/P4/","content":""},{"title":"P7","url":"/2023/10/16/P7/","content":"Bit:位，小b，最小单位。\nByte:字节，大B，1Byte&#x3D;8bit\n1个bit只能储存2个信息：0，1\n1个Byte能储存：2^8个信息：[-128，127]，[0，255]\n有2，4，8个Byte，没有3Byte\n数据储存位置：寄存器，内存，磁盘等。\n整数的符号表示：\n有符号和没有符号，\n有符号的用最高位表示正负，因此它们有符号之分，1表示负数，0表示正数。\n如：10110110为负，01001011为正。\n无符号的数表示0和正整数，无需表示正负，参与数值计算。\n对于一个字节的整数有符号的在[-128,127]之间，没有符号的整数在[0，255]之间。\n整数的编码分为：源码，反码和补码。\n原码：在数值前面增加了一位符号位（即最高位为符号位），该位为0表示正数，1则表示负数，其余的位置是数值大小。\n反码：正整数的反码就是其自身，而负整数的反码可以通过对其绝对值逐位求反来求得。\n补码：正数的补码为它本身，负数的补码就是它的绝对值求反加1，0的补码是0。\n表格法：512，256，128，64，32，16，8，4，2，1\n\n47用表格法转换为2进制为00101111，则-47的补码为11010001.\n\n-1的补码为11111111。\n\n128用表格法可知其2进制为10000000-128的补码为10000000。\n\n127的补码为01111111。\n\nint i=-1在内存中存在的形式是补码，因为1的int形式为00000001，则-1为11111111。\n\n"},{"title":"P6","url":"/2023/10/12/P6/","content":"一个X进制的整数（从an到a1），转化为十进制的公式：\na(n)a(n-1)...a(1)=a(n)*x(n-1)+...+a(2)*x+a(1)\n\n一个10进制的整数a，转化为x进制的公式为:\na除以x取余，商继续除以x取余，直到商为0，所有的余数逆序就是x的进制数。\n\n10进制转化为2进制可以用表格法及以1开始向左&#x2F;右除2所形成的表格用10进制的数字进行比较大于取1，小于取0，位数不足补上0。\n2进制和16进制的互相转换可以用以下方法:\n我们需要把2进制的数字每四个分为一组，从左向右所对应的数为8421，如果2进制的数字是1，就可以取到值，反之就是取不到。\n\n例如:\n01101011变成16进制，分为两组0110和1011，分别取值为0+4+2+0和8+0+2+1，可知16进制的数字为6b。\n\n而从16进制转换成2进制就是把16进制的每一位数字拆成由8+4+2+1所得到的形式。\n例如:\n一个8进制的数字256，它转换为10进制的数字为2x8^2+5x8^1+6=128+40+6=174。之后转换为7进制就是336。\n\n比如设计一个可以把10进制的数字转换为n进制的C语言如下。\n"},{"title":"P8","url":"/2023/10/16/P8/","content":"整数的储存方式分为：低位优先(little-endian)和高位优先(big-endian)。\n低位优先从低位到高位排序，高位优先从高到低排序。\n我们的32位系统也就是x86系统所用的方式是低位优先，64位是高位优先。对于一个整数0x00 00 00 01，靠近0x的是高位，右侧为低位。例如一个32位的整数的值为0x12345678，则在32位的系统中储存方式为78 56 34 12，如果换成64位系统就是12 34 56 78。\nhtons()\n(htons to net short)主机字节序到网络字节序转换。\nntons()\n(net to host short)网络字节序到主机字节序的转换。\n我们可以通过以下两种方式了解主机的字节序优先。\nip数据的报头是高位优先的，我们可以编写以下程序来识别。\n之后把数值改为1234.\n"},{"title":"P9","url":"/2023/10/16/P9/","content":"C语言中浮点数的定义：\n单精度浮点数：float,占4个字节\n双精度浮点数：double,占8个字节\n例如：\nfloat x&#x3D;1.732f；\ndouble y&#x3D;3.1415926；\n在IEEE标准中，浮点数是将特定长度的连续字节（4个字节或8个字节）的所有2进制位（32或64）分割为特定的三个区域。\n符号域：S，占1位，正0，负1.\n阶码域：E,占8位或11位，E&#x3D;e+127（float） or e+1023(double),指数e右正负即为符号数，但阶码为正是无符号数，所以把e加127或1023作为偏移，方便指数的比较。\n尾数域：M，占23位和52位因为整数部分的1是默认的可以不存储。\n公式\n精度实数的存储结构：\n例如：\n-99.75的float：1 10000101 10001111000000000000000\ndouble：1 10000000101 1000111100000000000000000000000000000000000000000000\n1.5625的二进制表示用x2取整的方法，第一次x2整数部分为1，小数部分是0.125，第二次x2的整数为0，小数为0.25，第三次的x2，整数是0，小数是0.5，第四次x2，整数是1，小数为0。所以1.5625的2进制是1.1001.\n"},{"title":"Hello World","url":"/2023/10/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"linux","url":"/2023/10/12/linux/","content":"#开使\nls -s 命令用于显示目录中文件的大小，以块为单位。每个块的大小通常为 512 字节。如果您想查看文件的详细信息，可以使用 ls -l 命令。该命令将显示文件的权限、所有者、大小、创建时间等详细信息。\n\ntouch 命令用于修改文件或目录的时间属性，包括存取时间和更改时间。如果文件不存在，系统会建立一个新的文件。以下是使用 touch 命令创建文件的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：touch filename，其中 filename 是您要创建的文件名。\n按下 Enter 键即可创建文件。\n\n在Linux中，管道符 | 用于将一个命令的输出作为另一个命令的输入。例如，要查找包含特定文本的文件，可以使用以下命令：grep “text” filename | less。此命令将 grep 命令的输出作为 less 命令的输入，以便您可以轻松地查看匹配的行。mv 命令可以用于移动文件或重命名文件。要重命名文件，请使用以下命令：\nmv old_filename new_filename\n其中 old_filename 是要重命名的文件名，new_filename 是新的文件名。请注意，如果 new_filename 已经存在，则会覆盖该文件。\n\n\n在Linux中，软链接（也称为符号链接）是指一个文件或目录，它指向另一个文件或目录。软链接类似于Windows中的快捷方式。以下是创建软链接的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：ln -s &#x2F;path&#x2F;to&#x2F;original &#x2F;path&#x2F;to&#x2F;link，其中 &#x2F;path&#x2F;to&#x2F;original 是要链接的文件或目录的路径，&#x2F;path&#x2F;to&#x2F;link 是新的软链接的路径。\n按下 Enter 键即可创建软链接。\n\n要将文件复制到指定位置，您可以使用 cp 命令。以下是使用 cp 命令复制文件的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：cp &#x2F;path&#x2F;to&#x2F;source &#x2F;path&#x2F;to&#x2F;destination，其中 &#x2F;path&#x2F;to&#x2F;source 是要复制的文件的路径，&#x2F;path&#x2F;to&#x2F;destination 是目标位置的路径。\n按下 Enter 键即可复制文件。\n以下是一些常见的选项：\n\n-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。\n-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。\n-r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项。\n-i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。\n-u 或 --update：仅复制源文件中更新时间较新的文件。\n-v 或 --verbose：显示详细的复制过程。\n-p 或 --preserve：保留源文件的权限、所有者和时间戳信息。\n-f 或 --force：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。\n\n请注意，如果要复制整个目录，则必须使用参数 -r 或者 -R。如果目标文件已存在，则默认情况下会覆盖该文件。\n在Linux中，路径是用于描述文件或目录位置的一种方式。绝对路径是指从根目录 &#x2F; 开始写起的文件或目录名称，而相对路径则指的是相对于当前路径的写法。换句话说，绝对路径必须以一个正斜线 &#x2F; 开头，也就是根目录开始，到查找对象（目录或文件）所必须经过的每个目录的名字，它是文件位置的完整路标，因此，在任何情况下都可以使用绝对路径找到所需的文件。相对路径则不是由根目录 &#x2F; 写起的，而是从当前目录描述到目标文件或目录的路径。使用相对路径表明某文件的存储位置时，经常会用到前面讲到的两个特殊目录，即当前目录（用 . 表示）和父目录（用 .. 表示）。总而言之，绝对路径是相对于根目录 &#x2F; 的，只要文件不移动位置，那么它的绝对路径是恒定不变的；而相对路径是相对于当前所在目录而言的，随着程序的执行，当前所在目录可能会改变，因此文件的相对路径不是固定不变的。\n在Linux中，有许多文本编辑器可供选择，例如 nano、vim、emacs 等。以下是使用 nano 编辑器的写入和保存步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：nano filename，其中 filename 是您要编辑的文件名。\n在 nano 编辑器中，您可以使用键盘输入或复制粘贴文本。如果您需要插入文本，请按下 Ctrl + Shift + V。\n要保存文件，请按下 Ctrl + O。如果您想更改文件名，请输入新的文件名并按下 Enter 键。\n要退出 nano 编辑器，请按下 Ctrl + X。如果您对文件进行了更改但尚未保存，则会提示您保存更改。\n在Linux中，您可以使用 tar 命令来打包和压缩文件。以下是使用 tar 命令打包和压缩文件的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：tar -czvf archive_name.tar.gz &#x2F;path&#x2F;to&#x2F;directory-or-file，其中 archive_name.tar.gz 是您要创建的归档文件名，&#x2F;path&#x2F;to&#x2F;directory-or-file 是要打包和压缩的目录或文件的路径。\n按下 Enter 键即可打包和压缩文件。tar：用于打包文件和目录。例如，要将目录 &#x2F;home&#x2F;user&#x2F;data 打包到文件 data.tar 中，请使用以下命令：tar -cvf data.tar &#x2F;home&#x2F;user&#x2F;data。\ngzip：用于压缩文件。例如，要将文件 data.txt 压缩为 data.txt.gz，请使用以下命令：gzip data.txt。\nbzip2：用于压缩文件。例如，要将文件 data.txt 压缩为 data.txt.bz2，请使用以下命令：bzip2 data.txt。\nzip：用于打包和压缩文件。例如，要将目录 &#x2F;home&#x2F;user&#x2F;data 打包并压缩为文件 data.zip，请使用以下命令：zip -r data.zip &#x2F;home&#x2F;user&#x2F;data。tar命令也可以打包多个文件或目录，只要用空格分开即可。例如:\n#把anaconda-ks.cfg文件和&#x2F;tmp目录打包成ana.tar文件包[root@localhost ~]# tar -cvf ana.tar anaconda-ks.cfg &#x2F;tmp&#x2F;\ntar打包的选项。-c    将多个文件或目录进行打包。-A    追加 tar 文件到归档文件。-f 包名    指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；-v    显示打包文件过程；\ntar解打包的选项。-x    对 tar 包做解打包操作。-f    指定要解压的 tar 包的包名。-t    只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。-C 目录    指定解打包位置。-v    显示解打包的具体过程。\ntar打包压缩和解压缩解打包。-z：压缩和解压缩 “.tar.gz” 格式；-j：压缩和解压缩 “.tar.bz2”格式。“-C” 用于指定解压位置、”-t” 用于查看压缩包内容\nzip压缩    zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用     [root@localhost ]#zip [选项] 压缩包名 源文件或源目录列表-r    递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。-m    将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。-v    显示详细的压缩过程信息。-q    在压缩的时候不显示命令的执行过程。-压缩级别    压缩级别是从 19 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。-u    更新压缩文件，即往压缩文件中添加新文件。\nzip 命令的基本使用\n#压缩[root@localhost ~]# zip ana.zip anaconda-ks.cfg压缩命令同时压缩多个文件\n#同时压缩多个文件到test.zip压缩包中\n[root@localhost ~]# zip test.zip install.log install.log.syslog使用 zip 命令压缩目录，需要使用“-r”选项，例如：\n#压缩目录[root@localhost ~]# zip -r dir1.zip dir1\nzip解压-d 目录名    将压缩文件解压到指定目录下。-n    解压时并不覆盖已经存在的文件。-o    解压时覆盖已经存在的文件，并且无需用户确认。-v    查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。-t    测试压缩文件有无损坏，但并不解压。-x 文件列表    解压文件，但不包含文件列表中指定的文件。\ngzip压缩  gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。   [root@localhost ~]# gzip [选项] 源文件-c    将压缩数据输出到标准输出中，并保留源文件。-d    对压缩文件进行解压缩。-r    递归压缩指定目录下以及子目录下的所有文件。-v    对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。-l    对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。-数字    用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。gzip命令不会打包目录，而是把目录下所有的子文件分别压缩\ngunzip解压缩  [root@localhost ~]# gunzip [选项] 文件-r    递归处理，解压缩指定目录下以及子目录下的所有文件。-c    把解压缩后的文件输出到标准输出设备。-f    强制解压缩文件，不理会文件是否已存在等情况。-l    列出压缩文件内容。-v    显示命令执行过程。-t    测试压缩文件是否正常，但不对其做解压缩操作。\nbzip2压缩  bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩）-d    执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。-k    bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。-f    bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。-t    测试压缩包文件的完整性。-v    压缩或解压缩文件时，显示详细信息。-数字    这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项\n在Linux中，日志文件是用于记录系统和应用程序活动的文件。大多数日志文件都存储在 &#x2F;var&#x2F;log 目录及其子目录中，其中一些常见的日志文件包括：\n&#x2F;var&#x2F;log&#x2F;syslog：系统日志文件，记录系统消息和错误。&#x2F;var&#x2F;log&#x2F;auth.log：授权日志文件，记录用户登录和授权信息。&#x2F;var&#x2F;log&#x2F;kern.log：内核日志文件，记录内核消息和错误。&#x2F;var&#x2F;log&#x2F;dmesg：内核环缓冲区日志文件，记录内核启动时的消息。要查看这些日志文件，您可以使用以下命令：\nsudo less &#x2F;var&#x2F;log&#x2F;syslogsudo less &#x2F;var&#x2F;log&#x2F;auth.logsudo less &#x2F;var&#x2F;log&#x2F;kern.logsudo less &#x2F;var&#x2F;log&#x2F;dmesg\n\n在Linux系统中，二进制文件通常存储在以下目录中：\n&#x2F;bin：存放着最常用的程序和指令。&#x2F;sbin：只有系统管理员能使用的程序和指令。&#x2F;usr&#x2F;bin：预装的绝大部分的程序都放在这里，Linux发行版和macOS上都超过了1000个程序和脚本放在这里。&#x2F;usr&#x2F;sbin：系统管理员用于存放供系统启动后使用的不重要的系统使用工具。&#x2F;usr&#x2F;local&#x2F;bin：管理员给用户安装程序可以放在这里，一些使用时自动配置安装的程序也会放在这里。&#x2F;usr&#x2F;local&#x2F;sbin：类似于 &#x2F;usr&#x2F;local&#x2F;bin，只是这里存储的是超级用户使用的比较高级的管理程序和系统守护程序。\n在Linux中，可以使用 chmod 命令来更改文件或目录的权限。以下是使用 chmod 命令更改文件或目录权限的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：chmod permissions filename，其中 permissions 是要设置的权限，filename 是要更改权限的文件或目录的名称。\n按下 Enter 键即可更改文件或目录的权限。\n例如，要将文件 file.txt 设置为所有用户都可读取和写入，可以使用以下命令：\nchmod a+rw file.txt\n\n要在Linux上运行可执行文件，您可以使用以下命令：\n.&#x2F;filename\n其中 filename 是您要运行的可执行文件名。请注意，您需要在文件名前加上 .&#x2F;，以便告诉Linux在当前目录中查找该文件。\n要在Linux中递归删除文件或目录，您可以使用 rm 命令。以下是使用 rm 命令递归删除文件或目录的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：rm -r filename，其中 filename 是要删除的文件或目录的名称。\n按下 Enter 键即可递归删除文件或目录。\n\n\n在Linux中，您可以使用 find 命令来查找文件，使用 grep 命令来查找文件内容。以下是使用 find 和 grep 命令查找文件和文件内容的步骤：\n要使用 find 命令查找文件，请输入以下命令：find &#x2F;path&#x2F;to&#x2F;search -name “filename”，其中 &#x2F;path&#x2F;to&#x2F;search 是要搜索的目录的路径，filename 是要查找的文件名或通配符。\n要使用 grep 命令查找文件内容，请输入以下命令：grep “pattern” &#x2F;path&#x2F;to&#x2F;file，其中 pattern 是要查找的文本模式，&#x2F;path&#x2F;to&#x2F;file 是要搜索的文件路径。\n要设置Linux用户密码，您可以使用以下命令：\nsudo passwd username\n其中 username 是要设置密码的用户名。输入此命令后，您将被提示输入新密码并确认。\n要设置root用户密码，请使用以下命令：\nsudo passwd root\n输入此命令后，您将被提示输入新密码并确认。\n要切换用户，请使用以下命令：\nsu username\n其中 username 是要切换到的用户名。输入此命令后，您将被提示输入该用户的密码。\n"},{"title":"P21","url":"/2023/10/20/P21/","content":"switch语句是一种多路段判定语句，它测试表达语句是否为一些常量整数值中的某一个值匹配，并执行相应的分支动作。所以switch语句也是一种分支语句，可以和if语句互相转换。\nswitch(a)&#x2F;&#x2F;a只能为整数(char,short,int,long等),不能为指针，浮点数。\n控制语句之循环语句：for,while,do-while.\n\nfor(表达式1;条件表达式2;表达式3)\n{\n循环体\n}\nfor循环中的“参数初始化表达式”，“条件表达式”和“更新循环变量表达式”都是选择项，即可以缺省，但是“;”不能缺。省略了初始化，表示不对循环控制变量赋初值，省略了条件表达式，则不做其他处理时便成为死循环。省略了增量，则不对循环控制变量进行操作，这时可在语句中加入修改循环控制变量的语句。\n1，简单的for循环\nfor(int i&#x3D;0; i&lt;10;i++)\n{\nprintf(“i:%d\\n”,i);\n}\nreturn 0; \n2，while的循环\nint i&#x3D;0;\nwhile(i&lt;10)\n{\nprintf(“i:%d\\n”,i);\ni++;\n}\nreturn 0;\n3，do_while语句的用法\nint i&#x3D;0;\ndo\n{\nprintf(“i:%d\\n”,i);&#x2F;&#x2F;先执行在打印。\ni++;\n} while  (i&lt;10);&#x2F;&#x2F;while的循环写在花括号后边。\nreturn 0;\n控制语句之转向语句\n\ngoto\n循环中的转向语句\nbreak\ncontinue\nreturn:\nreturn 0 or return.\n慎用goto语句，使用方式：\n语句1\n语句2\ngoto Lable1;\n. . . . \nLable1:\n语句7；\n语句8；\n语句9；\n\n"},{"title":"Arrey","url":"/2023/10/21/Array/","content":"数组\n一维数组的定义：数据类型 数组名[常量表达式]数组元素的类型 合法标识符 数组元素个数。数组是连续的可以随机访问。但是链表就不能。字符数组char str1[]&#x3D;{‘h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’};char str2[]&#x3D;”hello world”;第一个是字符数组，第二个即是字符数组还是字符串。&#x2F;&#x2F;sizeof是用来计算类型和数据的长度，strlen是用来计算字符串中非‘\\0’的字符个数。每当重新定义变量的时候所对应的a[i]就会改变。数组的赋值要在初始化阶段完成，初始化结束后不能直接赋值必须拷贝或单个元素赋值。数组名是常量指针一旦定义就不能修改。 #define hansu(a) sizeof(a)&#x2F;sizeof(a[0]) 如果输入的数组过多就会导致产生一些垃圾数值，C语言不会检测数组溢出。\n二维数组初始化数组a[5]&#x3D;{1,2,3,4,5};二维数组和一维数组的储存方式相同数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。 下面将深入介绍数组在内存中的运行机制。 数组引用变量只是一个引用，这个引用变量可以指向任何有效的内存，只有当该引用指向有效内存后，才可通过该数组变量来访问数组元素。 与所有引用变量相同的是，引用变量是访问真实对象的根本方式。 也就是说，如果我们希望在程序中访问数组，则只能通过这个数组的引用变量来访问它。 实际的数组元素被存储在堆（heap）内存中；数组引用变量是一个引用类型的变量，被存储在栈（stack）内存中。采用按行列出的效率高因为这样的数组是连续的可以随机访问而按列排序在储存中是跳跃的。\n#include &lt;stdio.h&gt;void func(int a[],int len){    printf(“sizeof(a) in func&#x3D;%d\\n”,sizeof(a));}int main(){int a[10]&#x3D;{0};printf(“sizeof(a)&#x3D;%d\\n”,sizeof(a));func(a,10);return  0;}输出40，4\n#include &lt;stdio.h&gt;int main(){    int a[5]&#x3D;{1,2,3,4,5};    int ptr1&#x3D;(int)(&amp;a+1);    int ptr2&#x3D;(int)((int)a+1);    printf(“%x,%x”,ptr1[-1],*ptr2);    return 0;}输出5，200000\n字符串数组是由零个或多个字符组成的有限序列。C语言的字符串可以定义为：”c1c2c3c4……cn\\0”。从定义的形式可以看出，C语言的字符串是以’\\0’结尾的。程序在存放字符后会自动加上’\\0’。当字符串中的字符有符号时可以用&quot;real&quot;来防止产生的语法错误。（即在普通字符前加上反斜线。）\n多字节字符串和宽字节字符串在C语言中，多字节字符串每个字符的编码宽度都不等，可以是一个字节还可以是多个字节。例如：char *str &#x3D; “Hello World!你好，世界!”。就是一个多字节的字符串(英文一个字节，中文两个字节)宽字节符的每个字节都是一样的。比如：wchar_t *wstr&#x3D;L”Hello World!你好，世界！”。上面的字符串都是两个字节。我们可以利用wctomb()进行宽字节和多字节的转。\n #include &lt;stdio.h&gt; int g_sl[]&#x3D;”hello world 1”;int main(){    char *s2&#x3D;”hello world 2”;不能在指针上修改数据，即不能修改存在静态常量值的字符串    char s3[]&#x3D;”hello world 3”;    char *ps4&#x3D;(char*)malloc(128);\nif(ps4=&#x3D;NULL){    return -1;}memset(ps4,1,128);strcpy(ps4,128,”hello world 4”);\nprintf(“%s\\n”,g_sl);静态区printf(“%s\\n”,s2);静态常量区printf(“%s\\n”,s3);栈printf(“%s\\n”,ps4);堆\nfree(ps4);\nreturn 0;}\n字符串遍历的三种方法：char *str &#x3D; “hello world!”;while(*str !&#x3D; ‘\\0’){    printf(“%c”,*str);    str++;}\nfor(;*str !&#x3D; ‘\\0’;str++){    printf(“%c”,str);}\nfor(int i&#x3D;0;str[i] !&#x3D; ‘\\0’;i++){    printf(“%c”,str[i]);}\n字符串库函数的应用：#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;tchar.h&gt;&#x2F;&#x2F;定义三种类型的字符串，缓存printf &#x2F; printf(“%ws”) &#x2F; _tprintf(_T(“%s”),xx)strlen(取得多字节字符串中字符长度，不包含 ‘&#x2F;0’。) &#x2F; wsclen(取得宽字节字符串中字符长度，不包含 ‘&#x2F;0’。) &#x2F; _tcslen(取得宽字节&#x2F;多字节字符串中字符长度，不包含 ‘&#x2F;0’。)strcpy &#x2F; stecpy_s &#x2F; _tcslen1,例如:char *strcpy(char* dest, const char *src);功能:把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间,说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的指针。wcscpy &#x2F; wcscpy_s &#x2F; wcsncpy_tcscpy &#x2F; _tcscpy_s &#x2F; _tcsncpystrcmp &#x2F; strncmp &#x2F; stricmp &#x2F; strnicmp比较字符串s1和s2strcat &#x2F; strcat_s   &#x2F;&#x2F;hello+world，文件路径字符串追加&#x2F;连接函数，它的功能就是在一个字符串后面追加上另外一个字符串。strchr &#x2F; strrchr &#x2F;&#x2F;返回位置地址，str，求文件名，扩展名。查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置.strstr函数搜索一个字符串在另一个字符串中的第一次出现找到所搜索的字符串，则该函数返回第一次匹配的字符串的地址如果未找到所搜索的字符串，则返回NULLstrtok &#x2F; strtok_s  &#x2F;&#x2F;ip地址        strtok(st_ip,st_ip_delim);        strtok_s(NULL,st_s1_deilm,&amp;next);用于分解字符串，返回分解得到的字符串指针.atof &#x2F; atoi &#x2F; atol &#x2F; atoll &#x2F; _ttol()\n"}]