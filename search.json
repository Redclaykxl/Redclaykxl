[{"title":"P12","url":"/2023/10/18/P12/","content":"P12字符类型：char（1）&#x2F;wchar_t（2或4）整型：short（2）&#x2F;int（4）&#x2F;long(4或8)&#x2F;long long(8)&#x2F;_int64(8)实数单精度：float（4）实数双精度：double（8）有符号和无符号：signed&#x2F;unsdigned,(signed)int&#x2F;unsigned int布尔类型：bool，0&#x2F;1（true&#x2F;false）C99&lt;stdbool.h&gt;typedef int bool#define true 1#define false 0\n字符编码有Ascll，utf系列，unicode。·a·是ascll的L·a·是unicode的NULL，0，’\\0’都是一样的，都是值0NULL虽然值是0，但是它的含义不一样，或者说它的类型不一样。NULL是指针类型，不过它是空指针，即值为0‘\\0’我们都知道\\是转义符，用单引号包起来，再加转义，实际上就是0，只不过它表示的是字符“0”用双引号包裹的0是字符串\n#include &lt;stdio.h&gt;#include &lt;math.h&gt;\nvoid main(){    float a &#x3D; 0;\nif (fabs(a)&lt; 1e-6)\n&#123;\n    printf(&quot;a 等于 0\\n&quot;);\n&#125;\nelse\n&#123;\n    printf(&quot;a 不等于 0\\n&quot;);\n&#125;\n\nreturn;\n\n}\n#include &lt;stdio.h&gt;#include &lt;math.h&gt;\nvoid main(){    double a &#x3D; 0;\nif (fabs(a)&lt; 1e-15)\n&#123;\n    printf(&quot;a 等于 0\\n&quot;);\n&#125;\nelse\n&#123;\n    printf(&quot;a 不等于 0\\n&quot;);\n&#125;\n\nreturn;\n\n}\n"},{"title":"Arrey","url":"/2023/10/21/Array/","content":"数组一维数组的定义：数据类型 数组名[常量表达式]数组元素的类型 合法标识符 数组元素个数。数组是连续的可以随机访问。但是链表就不能。\n字符数组char str1[]&#x3D;{‘h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’};char str2[]&#x3D;”hello world”;第一个是字符数组，第二个即是字符数组还是字符串。&#x2F;&#x2F;sizeof是用来计算类型和数据的长度，strlen是用来计算字符串中非‘\\0’的字符个数。每当重新定义变量的时候所对应的a[i]就会改变。数组的赋值要在初始化阶段完成，初始化结束后不能直接赋值必须拷贝或单个元素赋值。数组名是常量指针一旦定义就不能修改。 #define hansu(a) sizeof(a)&#x2F;sizeof(a[0]) 如果输入的数组过多就会导致产生一些垃圾数值，C语言不会检测数组溢出。\n二维数组初始化数组a[5]&#x3D;{1,2,3,4,5};二维数组和一维数组的储存方式相同数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。 下面将深入介绍数组在内存中的运行机制。 数组引用变量只是一个引用，这个引用变量可以指向任何有效的内存，只有当该引用指向有效内存后，才可通过该数组变量来访问数组元素。 与所有引用变量相同的是，引用变量是访问真实对象的根本方式。 也就是说，如果我们希望在程序中访问数组，则只能通过这个数组的引用变量来访问它。 实际的数组元素被存储在堆（heap）内存中；数组引用变量是一个引用类型的变量，被存储在栈（stack）内存中。采用按行列出的效率高因为这样的数组是连续的可以随机访问而按列排序在储存中是跳跃的。\n\\#include &lt;stdio.h&gt;\nvoid func(int a\\[],int len)\n&#123;\n    printf(&quot;sizeof(a) in func=%d\\n&quot;,sizeof(a));\n&#125;\nint main()\n&#123;\nint a\\[10]=&#123;0&#125;;\nprintf(&quot;sizeof(a)=%d\\n&quot;,sizeof(a));\nfunc(a,10);\nreturn  0;\n&#125;\n输出40，4\n\n\\#include &lt;stdio.h&gt;\nint main()\n&#123;\n    int a\\[5]=&#123;1,2,3,4,5&#125;;\n    int *ptr1=(int*)(&amp;a+1);\n    int *ptr2=(int*)((int)a+1);\n    printf(&quot;%x,%x&quot;,ptr1\\[-1],*ptr2);\n    return 0;\n&#125;\n输出5，200000\n\n字符串数组是由零个或多个字符组成的有限序列。C语言的字符串可以定义为：”c1c2c3c4……cn\\0”。从定义的形式可以看出，C语言的字符串是以’\\0’结尾的。程序在存放字符后会自动加上’\\0’。当字符串中的字符有符号时可以用&quot;real&quot;来防止产生的语法错误。（即在普通字符前加上反斜线。）\n多字节字符串和宽字节字符串在C语言中，多字节字符串每个字符的编码宽度都不等，可以是一个字节还可以是多个字节。例如：char *str &#x3D; “Hello World!你好，世界!”。就是一个多字节的字符串(英文一个字节，中文两个字节)宽字节符的每个字节都是一样的。比如：wchar_t *wstr&#x3D;L”Hello World!你好，世界！”。上面的字符串都是两个字节。我们可以利用wctomb()进行宽字节和多字节的转。\n \\#include &lt;stdio.h&gt;\n int g_sl\\[]=&quot;hello world 1&quot;;\nint main()\n&#123;\n    char \\*s2=&quot;hello world 2&quot;;*不能在指针上修改数据，即不能修改存在静态常量值的字符串*\n    char s3\\[]=&quot;hello world 3&quot;;\n    char \\*ps4=(char\\*)malloc(128);\n    \nif(ps4\\==NULL)\n&#123;\n    return -1;\n&#125;\nmemset(ps4,1,128);\nstrcpy(ps4,128,&quot;hello world 4&quot;);\n\nprintf(&quot;%s\\\\n&quot;,g_sl);*静态区*\nprintf(&quot;%s\\\\n&quot;,s2);*静态常量区*\nprintf(&quot;%s\\\\n&quot;,s3);*栈*\nprintf(&quot;%s\\\\n&quot;,ps4);*堆*\n\nfree(ps4);\n\nreturn 0;\n&#125;\n\n字符串遍历的三种方法：char *str &#x3D; “hello world!”;while(*str !&#x3D; ‘\\0’){    printf(“%c”,*str);    str++;}\nfor(;*str !&#x3D; ‘\\0’;str++){    printf(“%c”,str);}\nfor(int i&#x3D;0;str[i] !&#x3D; ‘\\0’;i++){    printf(“%c”,str[i]);}\n字符串库函数的应用：#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;tchar.h&gt;&#x2F;&#x2F;定义三种类型的字符串，缓存\nprintf &#x2F; printf(“%ws”) &#x2F; _tprintf(_T(“%s”),xx)strlen(取得多字节字符串中字符长度，不包含 ‘&#x2F;0’。) &#x2F; wsclen(取得宽字节字符串中字符长度，不包含 ‘&#x2F;0’。) &#x2F; _tcslen(取得宽字节&#x2F;多字节字符串中字符长度，不包含 ‘&#x2F;0’。)\nstrcpy &#x2F; stecpy_s &#x2F; _tcslen1,例如:char *strcpy(char* dest, const char *src);功能:把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间,说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的指针。\nwcscpy &#x2F; wcscpy_s &#x2F; wcsncpy_tcscpy &#x2F; _tcscpy_s &#x2F; _tcsncpystrcmp &#x2F; strncmp &#x2F; stricmp &#x2F; strnicmp比较字符串s1和s2\nstrcat &#x2F; strcat_s   &#x2F;&#x2F;hello+world，文件路径字符串追加&#x2F;连接函数，它的功能就是在一个字符串后面追加上另外一个字符串。\nstrchr &#x2F; strrchr &#x2F;&#x2F;返回位置地址，str，求文件名，扩展名。查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置.\nstrstr函数搜索一个字符串在另一个字符串中的第一次出现找到所搜索的字符串，则该函数返回第一次匹配的字符串的地址如果未找到所搜索的字符串，则返回NULL\nstrtok &#x2F; strtok_s  &#x2F;&#x2F;ip地址    strtok(st_ip,st_ip_delim);\n    strtok_s(NULL,st_s1_deilm,&amp;next);\n\n用于分解字符串，返回分解得到的字符串指针.atof &#x2F; atoi &#x2F; atol &#x2F; atoll &#x2F; _ttol()\n"},{"title":"P13","url":"/2023/10/18/P13/","content":"P13类型长度-sizeof（是一个操作符，在编译阶段就确定）char[-128,127][0,255]short[-32768,32767][0,65535]int&#x2F;long[-2147483648,2147483647][0,4294967295]float[-3.410^38,3.410^38]double[-1.710^308,1.710^308]无符号的int最小为0，最大为-1（2进制的位全是1）有符号的intint max &#x3D; 0x7fffffff除符号位全是1int min &#x3D; 0x80000000除符号位全是0在整数上溢出1是最小值，整数下溢出1是最大值。 (char)(-128*-1)&#x3D;-12816位系统中，int有符号的取值范围是[-216&#x2F;2,216&#x2F;2-1]无符号是[0,65536]所以当i&#x3D;65536是溢出1位则是-32768，i&#x3D;65535时为-32767.\n"},{"title":"P15","url":"/2023/10/18/P15/","content":"强制转换格式（新类型）变量丢失字节从高位开始丢失。从小到大转换要用符号位填充，整数用0填充，负数用1填充。自动（隐式）转换1，若参与的运算量的类型不同，则先转换成同一类型，然后进行运算。2，转换按数据长度的增加方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后在进行运算。字节数不同的转换为高字节进行运算，字节相同的如果一种有符号另一种没有符号，则转换为无符号类型。\n自动转换2\n进行算数运算（加减乘除取余及符号运算）时，不同类型数据必须转换成同一类型的数据才能运算，算数转换原则为：\n进行运算时，以表达式中最长的类型为主，将其他类型数据均转换成该类型，\na，若运算数中有double型或float型，则其他类型的数据均转换成double类型进行运算。\nb，若运算中最长的类型为long型，则其他类型数均转换成long型数。\nc，若运算中最长型为int型，则char型也转换成int型进行运算。算数转换是在运算过程中自动完成的。\nd，函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。char和short会被转换成int，float会被转换成double。\nf，printf函数会将char和short转换成int；float会被转换成double传递。\ng，函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。\n注意事项：\n作业：\n1从int转换为char时字节是减少的512的2进制是0000 0001 0000 0000变为16进制是0x01 00，进行转换从大到小是舍弃高位变成0x00，之后输出的printf会把输出的char再转换成int就是0x00 00也就是0.\n首先我们能知道在int类型中0x000000ff是255转换为char从高位舍弃是0x00ff还是255但255是无符号的char类型的最大值但有符号时是-1而有符号转无符号时内部储存方式不变但是外部是无符号的%lu所表示的是long unsigned即4字节int也是4字节从char转long要填充，我们知道最小值向下溢出是最大数值就是2*32-1。\n3\n短整型变长整型要在符号位填充0，长整形变短整型要舍弃高位。\n4\n有符号变无符号时内部储存方式不变但是外部要表示无符号。\n看有符号数的最高位是否为1，如果不为1（即为0），则无符号数就直接等于有符号数；如果有符号数的最高位为1，则将有符号数取补码，得到的数就是无符号数。\n及无符号变有符号时，原值照赋，存储方式不变但是外部值可能改变。\n"},{"title":"P16","url":"/2023/10/18/P16/","content":"变量\n变量是内存或寄存器中用一个标识符命名的存储单元，可以用来存储一个特定类型的数据，并且数据的值在程序运行过程中可以进行修复。\n变量就至少可以给我们提供两个信息：一是变量的地址，即就是，操作系统为变量在内存中分配的若干内存首地址；二是变量的值，也就是，变量在内存中所分配的那些内存单元中所存放的数据。\n常量没有地址。\n变量的命名\n必须由字母，下划线和数字组成，但是第一个字符必须是字母，下划线也被看作是字母。\n大写字母和小写字母是不同的字符。\n局部变量建议用比较短的名，全局变量使用比较长的名字（命名变量不用拼音尽量符合英语逻辑）。\n1\n要获取变量的地址，可以用取地址符 (&amp;)来操作变量\n2\n操作系统为变量在内存中分配的若干内存首地址，变量在内存中所分配的那些内存单元中所存放的数据\n3\n3.14f中f代表这是一个单精度的数\n4\n3value，_value,value,v1\n第一个不和法。\n"},{"title":"P18","url":"/2023/10/19/P18/","content":"以 int buf[100]&#x3D;{0} 为例，集中讨论 buf、buf[0]、&amp;buf[0]、&amp;buf 四个字符含义的内涵。\n1、buf：有两层含义，一是数组名，sizeof(buf) 时就是数组名的含义；二是等价于 &amp;buf[0]，表示数组的第一个元素的首字节地址，是一个常量值。因此，既然是一个常量值，无论从哪层含义来使用，buf 都不能作为左值来使用，但是，buf 可以用来作为右值来使用，作为右值使用时，应理解为地址。\n2、buf[0]：表示存储第一个元素的空间，可对其进行读写操作，所以可以作为左值来使用。\n3、&amp;buf[0]：等价于 buf，是一个地址常量，只能作为右值使用。\n4、&amp;buf：表示地址的首地址，是一个地址常量，只能作为右值使用。\nbuf 与 &amp;buf 的值相等，但是含义完全不同。printf(“%p\\n”,buf) 与 printf(“%p\\n”,&amp;buf) 这两条代码的打印结果是相同的，表明它们的值是相同的，但是 printf(“%p\\n”,buf+1) 与 printf(“%p\\n”,&amp;buf+1) 的结果完全不同，因为它们的含义不同，buf 表示数组的第一个元素的首字节地址，加 1 加的时一个元素空间的大小；&amp;buf 表示的是整个数组的首地址，加 1 加的是整个数组空间大小，数组首地址主要用于构建多维数组，对于一堆数组来说，数组首地址没有太大的实用意义。\nfflush(sidin)使用回车键删掉上一个输入的数值。\nchar c1&#x3D;getch();直接输出值{不会在屏幕上直接显示}\nchar c2&#x3D;getchar();需要回车键输出值\n使用上述两个需要有#include &lt;conio.h&gt;\ngetch()可以间隔分段使用。\nscanf_s可以用来限制输入的字符防止数值溢出。（只有微软有）\ngets,puts平替scanf。\n输入一个字符串时不用&amp;，而变量需要在前面加&amp;\n使用_wchart定义，在scanf中使用%lc或%C输入\nscanf后加入_s可以限制字符的输入防止溢出。\nget同理\n4996警告是一种数据溢出警告当输入的数值过大时溢出的数值可能会损坏其他数据造成破坏。\n"},{"title":"P19","url":"/2023/10/19/P19/","content":"i++和++i的区别：\n一，C语言内建型别：\ni++;\n++i;\nC++里，i是一个对象，++i比i++效率高。\n二，在复合表达式或赋值语句中：\nint i&#x3D;0；\nint a&#x3D; i++;a&#x3D;i;i&#x3D;i+1\nint i&#x3D;0;\nint b&#x3D; ++i;i&#x3D;i+1;b&#x3D;i-&gt;b&#x3D;1,i&#x3D;1\n三，函数中\ni++\n++i\nI++,++i属于不确定（由编译器决定） \n\n对于i&#x3D;&#x3D;0和0&#x3D;&#x3D;i来说，在if（）{}时是没错的但是，如果输入少&#x3D;时i&#x3D;&#x3D;0不会报错，产生的错误不易被发现，但是0&#x3D;&#x3D;i就会报错使错误更容易被发现改正。\na%&#x3D;5是指a&#x3D;a%5取余，a*&#x3D;5是指a×5.\n"},{"title":"P20","url":"/2023/10/19/P20/","content":"\n"},{"title":"P17","url":"/2023/10/19/P17/","content":"\n静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。 它主要存放静态数据、全局数据和常量。\n栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。\n 堆区：亦称动态内存分配\n11.0属于没有被定义的状态，此时只能打印出0 or 1.\n"},{"title":"P21","url":"/2023/10/20/P21/","content":"switch语句是一种多路段判定语句，它测试表达语句是否为一些常量整数值中的某一个值匹配，并执行相应的分支动作。所以switch语句也是一种分支语句，可以和if语句互相转换。\nswitch(a)&#x2F;&#x2F;a只能为整数(char,short,int,long等),不能为指针，浮点数。\n控制语句之循环语句：for,while,do-while.\n\nfor(表达式1;条件表达式2;表达式3)\n{\n循环体\n}\nfor循环中的“参数初始化表达式”，“条件表达式”和“更新循环变量表达式”都是选择项，即可以缺省，但是“;”不能缺。省略了初始化，表示不对循环控制变量赋初值，省略了条件表达式，则不做其他处理时便成为死循环。省略了增量，则不对循环控制变量进行操作，这时可在语句中加入修改循环控制变量的语句。\n1，简单的for循环\nfor(int i&#x3D;0; i&lt;10;i++)\n{\nprintf(“i:%d\\n”,i);\n}\nreturn 0; \n2，while的循环\nint i&#x3D;0;\nwhile(i&lt;10)\n{\nprintf(“i:%d\\n”,i);\ni++;\n}\nreturn 0;\n3，do_while语句的用法\nint i&#x3D;0;\ndo\n{\nprintf(“i:%d\\n”,i);&#x2F;&#x2F;先执行在打印。\ni++;\n} while  (i&lt;10);&#x2F;&#x2F;while的循环写在花括号后边。\nreturn 0;\n控制语句之转向语句\n\ngoto\n循环中的转向语句\nbreak\ncontinue\nreturn:\nreturn 0 or return.\n慎用goto语句，使用方式：\n语句1\n语句2\ngoto Lable1;\n. . . . \nLable1:\n语句7；\n语句8；\n语句9；\n\n"},{"url":"/2023/10/16/P4/","content":""},{"title":"P7","url":"/2023/10/16/P7/","content":"Bit:位，小b，最小单位。\nByte:字节，大B，1Byte&#x3D;8bit\n1个bit只能储存2个信息：0，1\n1个Byte能储存：2^8个信息：[-128，127]，[0，255]\n有2，4，8个Byte，没有3Byte\n数据储存位置：寄存器，内存，磁盘等。\n整数的符号表示：\n有符号和没有符号，\n有符号的用最高位表示正负，因此它们有符号之分，1表示负数，0表示正数。\n如：10110110为负，01001011为正。\n无符号的数表示0和正整数，无需表示正负，参与数值计算。\n对于一个字节的整数有符号的在[-128,127]之间，没有符号的整数在[0，255]之间。\n整数的编码分为：源码，反码和补码。\n原码：在数值前面增加了一位符号位（即最高位为符号位），该位为0表示正数，1则表示负数，其余的位置是数值大小。\n反码：正整数的反码就是其自身，而负整数的反码可以通过对其绝对值逐位求反来求得。\n补码：正数的补码为它本身，负数的补码就是它的绝对值求反加1，0的补码是0。\n表格法：512，256，128，64，32，16，8，4，2，1\n\n47用表格法转换为2进制为00101111，则-47的补码为11010001.\n\n-1的补码为11111111。\n\n128用表格法可知其2进制为10000000-128的补码为10000000。\n\n127的补码为01111111。\n\nint i=-1在内存中存在的形式是补码，因为1的int形式为00000001，则-1为11111111。\n\n"},{"title":"P6","url":"/2023/10/12/P6/","content":"一个X进制的整数（从an到a1），转化为十进制的公式：\na(n)a(n-1)...a(1)=a(n)*x(n-1)+...+a(2)*x+a(1)\n\n一个10进制的整数a，转化为x进制的公式为:\na除以x取余，商继续除以x取余，直到商为0，所有的余数逆序就是x的进制数。\n\n10进制转化为2进制可以用表格法及以1开始向左&#x2F;右除2所形成的表格用10进制的数字进行比较大于取1，小于取0，位数不足补上0。\n2进制和16进制的互相转换可以用以下方法:\n我们需要把2进制的数字每四个分为一组，从左向右所对应的数为8421，如果2进制的数字是1，就可以取到值，反之就是取不到。\n\n例如:\n01101011变成16进制，分为两组0110和1011，分别取值为0+4+2+0和8+0+2+1，可知16进制的数字为6b。\n\n而从16进制转换成2进制就是把16进制的每一位数字拆成由8+4+2+1所得到的形式。\n例如:\n一个8进制的数字256，它转换为10进制的数字为2x8^2+5x8^1+6=128+40+6=174。之后转换为7进制就是336。\n\n比如设计一个可以把10进制的数字转换为n进制的C语言如下。\n"},{"title":"P8","url":"/2023/10/16/P8/","content":"整数的储存方式分为：低位优先(little-endian)和高位优先(big-endian)。\n低位优先从低位到高位排序，高位优先从高到低排序。\n我们的32位系统也就是x86系统所用的方式是低位优先，64位是高位优先。对于一个整数0x00 00 00 01，靠近0x的是高位，右侧为低位。例如一个32位的整数的值为0x12345678，则在32位的系统中储存方式为78 56 34 12，如果换成64位系统就是12 34 56 78。\nhtons()\n(htons to net short)主机字节序到网络字节序转换。\nntons()\n(net to host short)网络字节序到主机字节序的转换。\n我们可以通过以下两种方式了解主机的字节序优先。\nip数据的报头是高位优先的，我们可以编写以下程序来识别。\n之后把数值改为1234.\n"},{"title":"P9","url":"/2023/10/16/P9/","content":"C语言中浮点数的定义：\n单精度浮点数：float,占4个字节\n双精度浮点数：double,占8个字节\n例如：\nfloat x&#x3D;1.732f；\ndouble y&#x3D;3.1415926；\n在IEEE标准中，浮点数是将特定长度的连续字节（4个字节或8个字节）的所有2进制位（32或64）分割为特定的三个区域。\n符号域：S，占1位，正0，负1.\n阶码域：E,占8位或11位，E&#x3D;e+127（float） or e+1023(double),指数e右正负即为符号数，但阶码为正是无符号数，所以把e加127或1023作为偏移，方便指数的比较。\n尾数域：M，占23位和52位因为整数部分的1是默认的可以不存储。\n公式\n精度实数的存储结构：\n例如：\n-99.75的float：1 10000101 10001111000000000000000\ndouble：1 10000000101 1000111100000000000000000000000000000000000000000000\n1.5625的二进制表示用x2取整的方法，第一次x2整数部分为1，小数部分是0.125，第二次x2的整数为0，小数为0.25，第三次的x2，整数是0，小数是0.5，第四次x2，整数是1，小数为0。所以1.5625的2进制是1.1001.\n"},{"title":"指针","url":"/2023/10/28/Pointer/","content":"指针是个变量里面存放内存地址。指针的初始化，可以让指针指向某一个变量的地址，也可以让指针指向一个分配的内存或者字符串常量，当然也可以指向NULL。例如：一，int i，*p  \\\\声明了一个整形变量i，一个指针p，这里的*与int一起。p&#x3D;&i;二，int i;int *p&#x3D;NULL;&#x2F;&#x2F;声明了一个指针p，并初始化为NULL。p&#x3D;&i;&#x2F;&#x2F;将指针p指向变量i.三，int i;int *p&#x3D;&i;&#x2F;&#x2F;声明了一个指针p，并直接初始化为变量i的地址。四，char *p (char*)malloc(100);&#x2F;&#x2F;声明一个字符指针p，并初始化为堆上的一个地址。char *str&#x3D;”hello world”;&#x2F;&#x2F;声明了一个字符指针str，并初始化为字符串的首地址。char c&#x3D;’A’;char *str&#x3D;&c;&#x2F;&#x2F;声明了一个指针并直接初始化围为变量C的地址。char *pch &#x3D;&c;\n地址：有效地址，NULL地址，野地址，信封地址。#define NULL ((void*)0)\n*p 解引用运算符（dereferrnce）*解引用：通过指针（存放的内存地址），找到对应的内存和里面存放的数据，（类似于邮递员根据信封地址，找到地点）。\n&amp;和*互为逆运算：*&amp;与&amp;*&amp;:取址，取变量的地址（reference）*:取内存，是取地址对应的内存（dereference），*p代表该内存，内存的长度就是p类型的长度，如果为void类型，那么长度不确定，GCC中默认为1字节。\n*在指针定义的时候，是和类型结合的.*在指针使用的时候，是取内存（解引用）char *s&#x3D;”hello world”;&#x2F;&#x2F;此处的*s是用于定义指针s.char c&#x3D;’a’;char *p&#x3D;&c;&#x2F;&#x2F;此处的*p是用于定义指针p,实际上是（char*）p&#x3D;&c;int x&#x3D;10,*p;&#x2F;&#x2F;此处的*p一样是用于定义指针p，此处的*与int结合：int *.*p+&#x3D;1;&#x2F;&#x2F;此处的*p是解引用(即C).printf(“%c\\n”,*p);&#x2F;&#x2F;此处的*p是解引用.void func(char *p){    printf(“%c\\n”,*p);&#x2F;&#x2F;取值}\n指针类型和相互转换char *p;&#x2F;&#x2F;指向内存单元的1个字节.short *p;&#x2F;&#x2F;指向内存单元的2个字节.int *p;&#x2F;&#x2F;指向内存单元的4个字节.float *p;&#x2F;&#x2F;指向内存单元的4个字节.double *p;&#x2F;&#x2F;指向内存单元的8个字节.\nsizeof(p)&#x3D;4 or 8 &#x2F; x86 or x64sizeof(*p)&#x3D;所知类型的长度\nchar c;int *p &#x3D; (int *)&c;\nint a;int *p1 &#x3D; &a;char *p2 &#x3D; (char*)p1;\nvoid *pvoid *p;&#x2F;&#x2F;这个类型来说,其他类型指针隐式转换成该类型,不能*p来取值,先转换特定类型再取值.可以接受任何类型的指针赋值给其他类型的指针,需要强转.不能进行解引用*运算,必须先转换.int i&#x3D;10;char ch&#x3D;’a’;int *p&#x3D;&i;char *p2&#x3D;&ch;\nvoid *pv1&#x3D;p1;&#x2F;&#x2F;不能*pv1 errorvoid *pv2&#x3D;p2;&#x2F;&#x2F;不能*pv2 error\nint *p3&#x3D;(int*)pv1;&#x2F;&#x2F;*p3char *p4&#x3D;(char*)pv2;&#x2F;&#x2F;*p4void *memcpy(void *dst,void *src,size_t len)sizeof(pv1)=&#x3D;4 or 8sizeof(*pv1)=&#x3D;error,gcc=&#x3D;1.\n字符指针既可以指向字符,也可以指向字符(其实也是指向的字符,即字符串的地址).判断指向字符还是字符串,在代码中可以自己确定.将字符或者字符串传给函数做参数,也可以通过字符指针完成.(二者需要自己确定)char ch&#x3D;’a’;char *p&#x3D;ch;\nchar p&#x3D;”hello world”;while(*p&#x3D;’\\0’){    printf(“%c”,*p);    p++;}\nsizeof(p),sizeof(*p)第一个指的是指针的长度第二个指的是指针对应类型的长度\n用指针的方法判断低位优先还是高位优先\n\\#include &lt;stdio.h&gt;\nint main(void)\n&#123;\n    int num = 0x000000ff;\n    char\\* p1 = (char\\*)&amp;num;\n    unsigned char\\* p2 = (unsigned char\\*)&amp;num;\n    printf(&quot;%lu\\\\n&quot;,\\*p1);\n    printf(&quot;%lu\\\\n&quot;,\\*p2);\n    return 0;\n&#125;\n输出是4294967295,255\n\n"},{"title":"Hello World","url":"/2023/10/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"二级指针","url":"/2023/10/28/secondary%20pointer/","content":"二级指针:存放一级指针的地址一级指针存放的是普通变量的内存地址.二级指针存放的是一级指针的地址.int a&#x3D;10;int *p&#x3D;&a;int **pp&#x3D;&p;*p为a   &amp;a为p*pp为p   &amp;p为pp**pp为a**pp–&gt;*(*pp)–&gt;*(p)–&gt;*p–&gt;a\n\\#include &lt;stdio.h&gt;\n\nint main()\n&#123;\nint a = 10;\n\nint\\* p = &amp;a;\nint\\*\\* pp = &amp;p;\n\n//a,&amp;a,p,&amp;p,pp,\\*pp,\\*\\*pp\n\nprintf(&quot;a:%d\\\\n&quot;,a);//10\nprintf(&quot;&amp;a:%p\\\\n&quot;,&amp;a);//addr of a\nprintf(&quot;p%p\\\\n&quot;,p);//addr of a\nprintf(&quot;&amp;p:%p\\\\n&quot;,&amp;p);//adde of p\nprintf(&quot;pp:%p\\\\n&quot;,pp);//addr of p\nprintf(&quot;\\*p:%p\\\\n&quot;,\\*p);//10\nprintf(&quot;\\*pp:%p\\\\n&quot;, \\*pp);//p.addr of a\nprintf(&quot;\\*\\*pp:%p\\\\n&quot;,\\*\\*pp);//a,10\n\nreturn 0;\n&#125;\n\n二级指针的应用如果指针做实参,那么传实参的指针(地址),就必须使用二级指针.要改变指针的值,就必须传指针的指针(地址)(二级指针)\n二级指针的作用:传参时改变一级指针的值.\n传参int func(int x);传实参值,不能改变实参int func(int *x);传实参指针,修改实参int func(int &amp;x);传实参引用,修改实参int func(int **x);实参是指针,传指针的指针,修改指针int func(int *&amp;x);实参是指针,传指针的引用,修改指针\n\\#include &lt;stdio.h&gt;\nvoid f(int\\*\\* ptr1, int\\* ptr2)\n&#123;\n    int\\* tmp = ptr2;\n    \\*\\*ptr1 \\*= 10;\n    \\*ptr2 \\*= 10;\n    ptr2 = \\*ptr1;\n    \\*ptr1 = tmp;\n&#125;\n\nint main(void)\n&#123;\n    int i = 0, j = 20, \\* p1 = &amp;i, \\* p2 = &amp;j;\n    f(&amp;p1, p2);\n    printf(&quot;i:%d,j:%d,p1:%p,p2:%p\\\\n&quot;, i, j, \\*p1, \\*p2);\n    return 0;\n&#125;\n输出为0,200.\n\n\\#include &lt;stdio.h&gt;\nvoid GetMemory(char\\* p)\n&#123;\n    p = (char\\*)malloc(100);\n&#125;\nvoid Test(char \\*s)\n&#123;\n    char\\* str = NULL;\n    GetMemory(str);//这里应该传二级指针\n    strcpy(str,s);\n    printf(str);\n&#125;\n\n正确做法\n\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\nvoid get_memory2(char \\*\\*p)\n&#123;\n    \\*p = (char \\*)malloc(100);\n&#125;\nint main()\n&#123;\n    char\\* str = NULL;\n    get_memory2(&amp;str);//这里应该传二级指针\n    strcpy_s(str,100,&quot;hello world&quot;);\n    printf(&quot;%s\\\\n&quot;,str);\n    free(str);\n    str = NULL;\n    return 0;\n&#125;\n\n"},{"title":"linux","url":"/2023/10/12/linux/","content":"#开使\nls -s 命令用于显示目录中文件的大小，以块为单位。每个块的大小通常为 512 字节。如果您想查看文件的详细信息，可以使用 ls -l 命令。该命令将显示文件的权限、所有者、大小、创建时间等详细信息。\n\ntouch 命令用于修改文件或目录的时间属性，包括存取时间和更改时间。如果文件不存在，系统会建立一个新的文件。以下是使用 touch 命令创建文件的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：touch filename，其中 filename 是您要创建的文件名。\n按下 Enter 键即可创建文件。\n\n在Linux中，管道符 | 用于将一个命令的输出作为另一个命令的输入。例如，要查找包含特定文本的文件，可以使用以下命令：grep “text” filename | less。此命令将 grep 命令的输出作为 less 命令的输入，以便您可以轻松地查看匹配的行。mv 命令可以用于移动文件或重命名文件。要重命名文件，请使用以下命令：\nmv old_filename new_filename\n其中 old_filename 是要重命名的文件名，new_filename 是新的文件名。请注意，如果 new_filename 已经存在，则会覆盖该文件。\n\n\n在Linux中，软链接（也称为符号链接）是指一个文件或目录，它指向另一个文件或目录。软链接类似于Windows中的快捷方式。以下是创建软链接的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：ln -s &#x2F;path&#x2F;to&#x2F;original &#x2F;path&#x2F;to&#x2F;link，其中 &#x2F;path&#x2F;to&#x2F;original 是要链接的文件或目录的路径，&#x2F;path&#x2F;to&#x2F;link 是新的软链接的路径。\n按下 Enter 键即可创建软链接。\n\n要将文件复制到指定位置，您可以使用 cp 命令。以下是使用 cp 命令复制文件的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：cp &#x2F;path&#x2F;to&#x2F;source &#x2F;path&#x2F;to&#x2F;destination，其中 &#x2F;path&#x2F;to&#x2F;source 是要复制的文件的路径，&#x2F;path&#x2F;to&#x2F;destination 是目标位置的路径。\n按下 Enter 键即可复制文件。\n以下是一些常见的选项：\n\n-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。\n-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。\n-r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项。\n-i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。\n-u 或 --update：仅复制源文件中更新时间较新的文件。\n-v 或 --verbose：显示详细的复制过程。\n-p 或 --preserve：保留源文件的权限、所有者和时间戳信息。\n-f 或 --force：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。\n\n请注意，如果要复制整个目录，则必须使用参数 -r 或者 -R。如果目标文件已存在，则默认情况下会覆盖该文件。\n在Linux中，路径是用于描述文件或目录位置的一种方式。绝对路径是指从根目录 &#x2F; 开始写起的文件或目录名称，而相对路径则指的是相对于当前路径的写法。换句话说，绝对路径必须以一个正斜线 &#x2F; 开头，也就是根目录开始，到查找对象（目录或文件）所必须经过的每个目录的名字，它是文件位置的完整路标，因此，在任何情况下都可以使用绝对路径找到所需的文件。相对路径则不是由根目录 &#x2F; 写起的，而是从当前目录描述到目标文件或目录的路径。使用相对路径表明某文件的存储位置时，经常会用到前面讲到的两个特殊目录，即当前目录（用 . 表示）和父目录（用 .. 表示）。总而言之，绝对路径是相对于根目录 &#x2F; 的，只要文件不移动位置，那么它的绝对路径是恒定不变的；而相对路径是相对于当前所在目录而言的，随着程序的执行，当前所在目录可能会改变，因此文件的相对路径不是固定不变的。\n在Linux中，有许多文本编辑器可供选择，例如 nano、vim、emacs 等。以下是使用 nano 编辑器的写入和保存步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：nano filename，其中 filename 是您要编辑的文件名。\n在 nano 编辑器中，您可以使用键盘输入或复制粘贴文本。如果您需要插入文本，请按下 Ctrl + Shift + V。\n要保存文件，请按下 Ctrl + O。如果您想更改文件名，请输入新的文件名并按下 Enter 键。\n要退出 nano 编辑器，请按下 Ctrl + X。如果您对文件进行了更改但尚未保存，则会提示您保存更改。\n在Linux中，您可以使用 tar 命令来打包和压缩文件。以下是使用 tar 命令打包和压缩文件的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：tar -czvf archive_name.tar.gz &#x2F;path&#x2F;to&#x2F;directory-or-file，其中 archive_name.tar.gz 是您要创建的归档文件名，&#x2F;path&#x2F;to&#x2F;directory-or-file 是要打包和压缩的目录或文件的路径。\n按下 Enter 键即可打包和压缩文件。tar：用于打包文件和目录。例如，要将目录 &#x2F;home&#x2F;user&#x2F;data 打包到文件 data.tar 中，请使用以下命令：tar -cvf data.tar &#x2F;home&#x2F;user&#x2F;data。\ngzip：用于压缩文件。例如，要将文件 data.txt 压缩为 data.txt.gz，请使用以下命令：gzip data.txt。\nbzip2：用于压缩文件。例如，要将文件 data.txt 压缩为 data.txt.bz2，请使用以下命令：bzip2 data.txt。\nzip：用于打包和压缩文件。例如，要将目录 &#x2F;home&#x2F;user&#x2F;data 打包并压缩为文件 data.zip，请使用以下命令：zip -r data.zip &#x2F;home&#x2F;user&#x2F;data。tar命令也可以打包多个文件或目录，只要用空格分开即可。例如:\n#把anaconda-ks.cfg文件和&#x2F;tmp目录打包成ana.tar文件包[root@localhost ~]# tar -cvf ana.tar anaconda-ks.cfg &#x2F;tmp&#x2F;\ntar打包的选项。-c    将多个文件或目录进行打包。-A    追加 tar 文件到归档文件。-f 包名    指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；-v    显示打包文件过程；\ntar解打包的选项。-x    对 tar 包做解打包操作。-f    指定要解压的 tar 包的包名。-t    只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。-C 目录    指定解打包位置。-v    显示解打包的具体过程。\ntar打包压缩和解压缩解打包。-z：压缩和解压缩 “.tar.gz” 格式；-j：压缩和解压缩 “.tar.bz2”格式。“-C” 用于指定解压位置、”-t” 用于查看压缩包内容\nzip压缩    zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用     [root@localhost ]#zip [选项] 压缩包名 源文件或源目录列表-r    递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。-m    将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。-v    显示详细的压缩过程信息。-q    在压缩的时候不显示命令的执行过程。-压缩级别    压缩级别是从 19 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。-u    更新压缩文件，即往压缩文件中添加新文件。\nzip 命令的基本使用\n#压缩[root@localhost ~]# zip ana.zip anaconda-ks.cfg压缩命令同时压缩多个文件\n#同时压缩多个文件到test.zip压缩包中\n[root@localhost ~]# zip test.zip install.log install.log.syslog使用 zip 命令压缩目录，需要使用“-r”选项，例如：\n#压缩目录[root@localhost ~]# zip -r dir1.zip dir1\nzip解压-d 目录名    将压缩文件解压到指定目录下。-n    解压时并不覆盖已经存在的文件。-o    解压时覆盖已经存在的文件，并且无需用户确认。-v    查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。-t    测试压缩文件有无损坏，但并不解压。-x 文件列表    解压文件，但不包含文件列表中指定的文件。\ngzip压缩  gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。   [root@localhost ~]# gzip [选项] 源文件-c    将压缩数据输出到标准输出中，并保留源文件。-d    对压缩文件进行解压缩。-r    递归压缩指定目录下以及子目录下的所有文件。-v    对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。-l    对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。-数字    用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。gzip命令不会打包目录，而是把目录下所有的子文件分别压缩\ngunzip解压缩  [root@localhost ~]# gunzip [选项] 文件-r    递归处理，解压缩指定目录下以及子目录下的所有文件。-c    把解压缩后的文件输出到标准输出设备。-f    强制解压缩文件，不理会文件是否已存在等情况。-l    列出压缩文件内容。-v    显示命令执行过程。-t    测试压缩文件是否正常，但不对其做解压缩操作。\nbzip2压缩  bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩）-d    执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件。-k    bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项。-f    bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件。-t    测试压缩包文件的完整性。-v    压缩或解压缩文件时，显示详细信息。-数字    这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项\n在Linux中，日志文件是用于记录系统和应用程序活动的文件。大多数日志文件都存储在 &#x2F;var&#x2F;log 目录及其子目录中，其中一些常见的日志文件包括：\n&#x2F;var&#x2F;log&#x2F;syslog：系统日志文件，记录系统消息和错误。&#x2F;var&#x2F;log&#x2F;auth.log：授权日志文件，记录用户登录和授权信息。&#x2F;var&#x2F;log&#x2F;kern.log：内核日志文件，记录内核消息和错误。&#x2F;var&#x2F;log&#x2F;dmesg：内核环缓冲区日志文件，记录内核启动时的消息。要查看这些日志文件，您可以使用以下命令：\nsudo less &#x2F;var&#x2F;log&#x2F;syslogsudo less &#x2F;var&#x2F;log&#x2F;auth.logsudo less &#x2F;var&#x2F;log&#x2F;kern.logsudo less &#x2F;var&#x2F;log&#x2F;dmesg\n\n在Linux系统中，二进制文件通常存储在以下目录中：\n&#x2F;bin：存放着最常用的程序和指令。&#x2F;sbin：只有系统管理员能使用的程序和指令。&#x2F;usr&#x2F;bin：预装的绝大部分的程序都放在这里，Linux发行版和macOS上都超过了1000个程序和脚本放在这里。&#x2F;usr&#x2F;sbin：系统管理员用于存放供系统启动后使用的不重要的系统使用工具。&#x2F;usr&#x2F;local&#x2F;bin：管理员给用户安装程序可以放在这里，一些使用时自动配置安装的程序也会放在这里。&#x2F;usr&#x2F;local&#x2F;sbin：类似于 &#x2F;usr&#x2F;local&#x2F;bin，只是这里存储的是超级用户使用的比较高级的管理程序和系统守护程序。\n在Linux中，可以使用 chmod 命令来更改文件或目录的权限。以下是使用 chmod 命令更改文件或目录权限的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：chmod permissions filename，其中 permissions 是要设置的权限，filename 是要更改权限的文件或目录的名称。\n按下 Enter 键即可更改文件或目录的权限。\n例如，要将文件 file.txt 设置为所有用户都可读取和写入，可以使用以下命令：\nchmod a+rw file.txt\n\n要在Linux上运行可执行文件，您可以使用以下命令：\n.&#x2F;filename\n其中 filename 是您要运行的可执行文件名。请注意，您需要在文件名前加上 .&#x2F;，以便告诉Linux在当前目录中查找该文件。\n要在Linux中递归删除文件或目录，您可以使用 rm 命令。以下是使用 rm 命令递归删除文件或目录的步骤：\n打开终端：在Linux中，可以通过按下 Ctrl + Alt + T 快捷键打开终端。\n输入以下命令：rm -r filename，其中 filename 是要删除的文件或目录的名称。\n按下 Enter 键即可递归删除文件或目录。\n\n\n在Linux中，您可以使用 find 命令来查找文件，使用 grep 命令来查找文件内容。以下是使用 find 和 grep 命令查找文件和文件内容的步骤：\n要使用 find 命令查找文件，请输入以下命令：find &#x2F;path&#x2F;to&#x2F;search -name “filename”，其中 &#x2F;path&#x2F;to&#x2F;search 是要搜索的目录的路径，filename 是要查找的文件名或通配符。\n要使用 grep 命令查找文件内容，请输入以下命令：grep “pattern” &#x2F;path&#x2F;to&#x2F;file，其中 pattern 是要查找的文本模式，&#x2F;path&#x2F;to&#x2F;file 是要搜索的文件路径。\n要设置Linux用户密码，您可以使用以下命令：\nsudo passwd username\n其中 username 是要设置密码的用户名。输入此命令后，您将被提示输入新密码并确认。\n要设置root用户密码，请使用以下命令：\nsudo passwd root\n输入此命令后，您将被提示输入新密码并确认。\n要切换用户，请使用以下命令：\nsu username\n其中 username 是要切换到的用户名。输入此命令后，您将被提示输入该用户的密码。\n"},{"title":"结构体","url":"/2023/10/28/Structure/","content":"结构体定义:struct(结构体)每一个构成成员可以是一个基本数据类型或者又是一个构造类型.四种定义结构体的方法一,struct 结构名{    成员列表}struct 结构名 变量名;二,struct 结构名{    成员列表}变量名1,变量名2;三,struct{    成员列表}变量名1,变量名2;四,typedef struct_结构名{    成员列表}结构名,*p结构名;结构名 变量名;\n结构体的定义,初始化与成员的访问\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\n\ntypedef struct \\_student\n&#123;\n    int id;\n    int age;\n    char name\\[20\\];\n    char sex;\n    float score;\n&#125;student,\\*pstudent;\n\nint main()\n&#123;\n    student s1 = &#123;17,22,&quot;Tom&quot;,&#39;M&#39;,99.5f&#125;;\n    student s2 = &#123;0&#125;;\n\ns2.id = 19;\ns2.age = 23;\nstrcpy_s(s2.name,20, &quot;lily&quot;);\ns2.sex = &#39;F&#39;;\ns2.score = 87.5f;\n\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f\\\\n&quot;,\n    s1.id,s1.age,s1.name,s1.sex,s1.score);\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f\\\\n&quot;,\n    s2.id, s2.age, s2.name,s2.sex,s2.score);\n\nreturn 0;\n&#125;\n\n结构体指针访问\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\n\\#include &lt;stdlib.h&gt;\n\ntypedef struct \\_student\n&#123;\n    int id;\n    int age;\n    char name\\[20\\];\n    char sex;\n    float score;\n&#125;student, \\* pstudent;\n\nint main()\n&#123;\n    student s1 = &#123; 17,22,&quot;Tom&quot;,&#39;M&#39;,99.5f &#125;;\n    student s2 = &#123; 0 &#125;;\n\ns2.id = 19;\ns2.age = 23;\nstrcpy_s(s2.name, 20, &quot;lily&quot;);\ns2.sex = &#39;F&#39;;\ns2.score = 87.5f;\n\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f\\\\n&quot;,\n    s1.id, s1.age, s1.name, s1.sex, s1.score);\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f\\\\n&quot;,\n    s2.id, s2.age, s2.name, s2.sex, s2.score);\n\nstudent* ps1 = &amp;s1;\npstudent ps2 = &amp;s2;//pstudent == student \\*\n\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f\\\\n&quot;,\n    ps1-&gt;id,ps1-&gt;age,ps1-&gt;name,ps1-&gt;sex,ps1-&gt;score);\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f\\\\n&quot;,\n    ps2-&gt;id, ps2-&gt;age, ps2-&gt;name, ps2-&gt;sex, ps2-&gt;score);\n\n//ps1+1\n//sizeof(ps1),sizeof(\\*ps1)\\=\\=sizeof(student)\n\nprintf(&quot;sizeof(ps1)=%d,sizeof(*ps1)=%d,sizepf(student)=%d\\\\n&quot;,\n    sizeof(ps1),sizeof(*ps1),sizeof(student));\n\nprintf(&quot;sizeof(student*):%d\\\\n&quot;,sizeof(student\\*));\n\nprintf(&quot;ps1:%p,ps1+1:%p\\\\n&quot;,ps1,ps1+1);\n\nstudent* ps3 = (student*)malloc(sizeof(student));\nif (ps3 == NULL)\n&#123;\nreturn -1;\n&#125;\nmemset(ps3, 0, sizeof(student));\nps3-&gt;id = 25;\nps3-&gt;age = 24;\nstrcpy_s(ps3-&gt;name, 20, &quot;lilei&quot;);\nps3-&gt;sex = &#39;M&#39;;\nps3-&gt;score = 86.5f;\n\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f\\\\n&quot;,\n    ps3-&gt;id, ps3-&gt;age, ps3-&gt;name, ps3-&gt;sex, ps3-&gt;score);\nfree(ps3);\nps3 = NULL;\n\nreturn 0;\n&#125;\n\n*与-&gt;,.运算符首先-&gt;与.运算符比*优先级高\ntypedef struct \\_student\n&#123;\n    int id;\n    int age;\n    char name\\[20\\];\n    char sex;\n    float score;\n&#125;student, \\* pstudent;\nstudent stdt=&#123;...&#125;;\npstdt=&amp;stdt;\n\\*pstdt-&gt;sex--&gt;\\*(pstdt-&gt;sex)//错误,因为sex不是一个指针.\n\\*pstdt-&gt;name--&gt;\\*(pstdt-&gt;name)//正确的,因为name是一个指针,name是一个字符.\n\\*pstdt.sex--&gt;\\*(pstdt.sex)//错误,pstdt是指针,不支持.运算符,没有.这个运算符.\n(\\*pstdt).sex--&gt;stdt.sex\\//正确,\\*pstdt就是stdt.\n\n结构体中的结构体\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\n\\#include &lt;stdlib.h&gt;\n\ntypedef struct _date\n&#123;\n    int year;\n    int month;\n    int day;\n\n&#125;date;\n\ntypedef struct _student\n&#123;\n    int id;\n    int age;\n    char name[20];\n    char sex;\n    float score;\n    date birthday;\n&#125;student, * pstudent;\n\nint main()\n&#123;\n    student s1 = &#123; 17,22,&quot;Tom&quot;,&#39;M&#39;,99.5f,&#123;1995,2,5&#125;&#125;;\n    student s2 = &#123; 0 &#125;;\n\ns2.id = 19;\ns2.age = 23;\nstrcpy_s(s2.name, 20, &quot;lily&quot;);\ns2.sex = &#39;F&#39;;\ns2.score = 87.5f;\ns2.birthday.year = 1997;\ns2.birthday.month = 6;\ns2.birthday.day = 21;\n\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f,&quot;\n    &quot;year:%d,month:%d,day:%d\\n&quot;,\n    s1.id, s1.age, s1.name, s1.sex, s1.score,\n    s1.birthday.year,s1.birthday.month,s1.birthday.day);\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f,&quot;\n    &quot;year:%d,month:%d,day:%d\\n&quot;,\n    s2.id, s2.age, s2.name, s2.sex, s2.score,\n    s2.birthday.year,s2.birthday.month,s2.birthday.day);\n\nstudent* ps1 = &amp;s1;\npstudent ps2 = &amp;s2;//pstudent == student *\n    \n\nprintf(&quot;*ps2-&gt;name:%c\\n&quot;, *ps2-&gt;name);\n\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f\\n&quot;,\n    ps1-&gt;id,ps1-&gt;age,ps1-&gt;name,ps1-&gt;sex,ps1-&gt;score);\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f\\n&quot;,\n    ps2-&gt;id, ps2-&gt;age, ps2-&gt;name, ps2-&gt;sex, ps2-&gt;score);\n\n//ps1+1\n//sizeof(ps1),sizeof(*ps1)==sizeof(student)\n\nprintf(&quot;sizeof(ps1)=%d,sizeof(*ps1)=%d,sizepf(student)=%d\\n&quot;,\n    sizeof(ps1),sizeof(*ps1),sizeof(student));\n\nprintf(&quot;sizeof(student*):%d\\n&quot;,sizeof(student*));\n\nprintf(&quot;ps1:%p,ps1+1:%p\\n&quot;,ps1,ps1+1);\n\nstudent* ps3 = (student*)malloc(sizeof(student));\nif (ps3 == NULL)\n&#123;\n    return -1;\n&#125;\nmemset(ps3, 0, sizeof(student));\nps3-&gt;id = 25;\nps3-&gt;age = 24;\nstrcpy_s(ps3-&gt;name, 20, &quot;lilei&quot;);\nps3-&gt;sex = &#39;M&#39;;\nps3-&gt;score = 86.5f;\nps3-&gt;birthday.year = 1996;\nps3-&gt;birthday.month = 6;\nps3-&gt;birthday.day = 7;\n\nprintf(&quot;id:%d,age:%d,name:%s,sex=%c,%f,&quot;\n    &quot;year:%d,month:%d,day:%d\\n&quot;,\n    ps3-&gt;id, ps3-&gt;age, ps3-&gt;name, ps3-&gt;sex, ps3-&gt;score,\n    ps3-&gt;birthday.year,ps3-&gt;birthday.month,\n    ps3-&gt;birthday.day);\nfree(ps3);\nps3 = NULL;\n\nreturn 0;\n&#125;\n\n结构体中的指针-1\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\n\\#include &lt;stdlib.h&gt;\n\ntypedef struct _student\n&#123;\n    int id;\n    int age;\n    char *name;\n    char sex;\n    float score;\n&#125;student,*pstudent;\n\nint main()\n&#123;\n//student s1 = &#123; 11,21,&quot;Tom&quot;,&#39;M&#39;,97.5f&#125;;\nstudent s2 = &#123; 0 &#125;;\n\ns2.id = 15;\ns2.age = 22;\n\ns2.name = (char*)malloc(20);\nif (s2.name == NULL)\n&#123;\n    return -1;\n&#125;\nstrcpy_s(s2.name,20,&quot;lily&quot;);\ns2.sex = &#39;M&#39;;\ns2.score = 94.5f;\n    \n    \n    \nstudent* s3 = (student*)malloc(sizeof(student));\nif (s3 == NULL)\n&#123;\n    return -1;\n&#125;\nmemset(s3, 0, sizeof(student));\ns3-&gt;id = 18;\ns3-&gt;age = 23;\ns3-&gt;name = (char*)malloc(20);\nif (s3-&gt;name == NULL)\n&#123;\n    free(s3);\n    return -1;\n&#125;\nmemset(s3-&gt;name, 0, 20);\nstrcpy_s(s3-&gt;name, 20, &quot;david&quot;);\ns3-&gt;sex = &#39;M&#39;;\ns3-&gt;score = 92.5f;\n\n//printf(&quot;s1:name:%s\\n&quot;,s1.name);\nprintf(&quot;s2:name:%s\\n&quot;, s2.name);\nprintf(&quot;s3.name:%s\\n&quot;, s3-&gt;name);\n\nfree(s2.name);\ns2.name = NULL;\nfree(s3-&gt;name);\ns3-&gt;name = NULL;\nreturn 0;\n&#125;\n\n结构体中的指针-2:链表和树typedef struct _node{int value;struct _node *next;}node,*pnode;\ntypedef struct _btree{int data;struct _btree *left;struct _btree *right;}btree,*pbtree;\n"},{"title":"Hexo文档","url":"/2023/10/29/Hexo%20Word/","content":"\n安装Node.js和Git：首先，你需要在你的计算机上安装Node.js和Git。你可以从官方网站下载并安装它们。\n\n安装Hexo：打开命令行，然后输入以下命令来全局安装Hexo：\nnpm install -g hexo-cli\n\n\n创建博客：然后，你可以使用以下命令来创建一个新的Hexo项目：\nhexo init blog\ncd blog\n\n\n安装依赖：在新创建的项目目录中，运行以下命令来安装依赖：\nnpm install\n\n\n启动服务器：现在，你可以启动Hexo服务器来预览你的博客：\nhexo server\n\n\n生成静态文件：当你对博客满意时，你可以生成静态文件：\nhexo generate\n\n\n部署到GitHub：最后，你可以将你的博客部署到GitHub。首先，你需要在_config.yml文件中设置部署配置。然后，运行以下命令来部署你的博客：\nhexo deploy\n\n\n\nhexo -v //检测版本号\ngit config --global user.name &quot;GitHub用户名&quot;\ngit config --global user.email &quot;GitHub注册邮箱&quot;\n\nssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot;\n\ncat ~/.ssh/id_rsa.pub\n\n博客初始化\n首先选择一个你喜欢的地方作为你的博客根目录。\nmkdir ~/git/你的GitHub用户名.github.io\n\n随后依次运行：\nhexo init ~/git/你的GitHub用户名.github.io\ncd ~/git/你的GitHub用户名.github.io\nnpm install\n\n现在博客已经初始化完成了。使用以下命令：\nhexo server\n\n就可以在本地看到你的站点了。可以在终端里使用control+c关掉本地服务器。下面列举一些常用的命令，更多命令与参数可以参考.\n\nhexo clean用于清除缓存与静态文件。\nhexo new “文章标题”用于新建文章。\nhexo server用于启动本地服务器查看渲染好的网页，可简写为hexo s。\nhexo generate用于生成静态文件，可简写为hexo g。\nhexo deploy用于部署网站，需要先设置好_config.yml，可简写hexo d。\n\n设置_config.yml\ndeploy:\n  type: git\n  repo: 你的GitHub目录地址\n  branch: master\n\n首次部署我们需要再安装一个依赖：\nnpm install hexo-deployer-git --save\n\n随后一切就绪，依次运行：\nhexo clean\nhexo g\nhexo d\n\n安装Markdown语法扩展Hexo原生的Markdown渲染插件支持的Markdown语法不够丰富，比如不支持GitHub Flavored Markdown、CommonMark、上标下标、脚注等等。因此，我们在写文章之前，可以把原生的插件hexo-renderer-marked改为hexo-renderer-markdown-it。\n首先，根据该插件的安装指南，运行以下命令：\nnpm uninstall hexo-renderer-marked\nnpm install hexo-renderer-markdown-it\n\n随后在_config.yml里添加如下语句（可以添加在deploy前面）：\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: &#39;“”‘’&#39;\n  plugins:\n    - markdown-it-abbr\n    - markdown-it-footnote\n    - markdown-it-ins\n    - markdown-it-sub\n    - markdown-it-sup\n  anchors:\n    level: 2\n    collisionSuffix: &#39;v&#39;\n    permalink: true\n    permalinkClass: header-anchor\n    permalinkSide: &#39;left&#39;\n    permalinkSymbol: ¶\n\n随后你就可以使用扩展语法了。使用方法可以参看这里和这里，尤其是后一个网页给出了很详细的例子。\n如果你觉得脚注字体偏大，可以看我的字体设置文章，看完后就知道怎么修改了。我个人做了如下设置：\n.footnotes &#123;\n    font-size: 75%;\n&#125;\n\n因为我们引入了新的插件，所以也要改一下工作流文件，在安装Hexo那一步加一些步骤，安装这些依赖。你可以在本地修改.github/workflows/main.yml的内容，也可以在GitHub的blog仓库，点击Actions，选择最近的一次部署，点击右侧的省略号中的View workflow file，然后点击右侧的铅笔按钮进行修改。将新的依赖安装写在npm install那一行后面即可。如果你采用后者，在你将本地新的改动push到GitHub之前，要记得先做git pull，否则会报错显示远程仓库有新的改动。推荐在本地修改，一步到位。\nrun: |\n    npm install hexo-cli -g\n    npm install\n  + npm uninstall hexo-renderer-marked\n  + npm install hexo-renderer-markdown-it\n\nHexo 静态博客指南：建站教程（上） - 知乎 (zhihu.com)\n关于一些依赖的安装cnpm installgit clone \\https://github.com/Yue-plus/hexo-theme-arknights.git themes&#x2F;arknightscnpm install hexo-server hexo-browsersync hexo-renderer-pug –save\n实用插件[代码块折叠]fletchto99&#x2F;hexo-sliding-spoiler: A sliding spoiler for hexo (github.com).\n"},{"title":"结构体指针和数组","url":"/2023/10/29/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/","content":"结构体赋值时的拷贝typedef struct _struct1{    …    …}struct1;struct1 s1&#x3D;{1,’a’};struct1 s2&#x3D;s1;&#x2F;&#x2F;?struct1 s3;s3&#x3D;s1;&#x2F;&#x2F;?\n浅拷贝和深拷贝拷贝中默认是浅拷贝\n结构体数组结构体数组的初始化和应用结构体指针数组\n\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\n\\#include &lt;stdlib.h&gt;\n\ntypedef struct \\_student\n&#123;\n    int score;\n    char name\\[16];\n\n&#125;student,\\*pstudent;\n \n\n\nint main() \n&#123;\n    student stu1\\[3] = &#123; &#123;78,&quot;tom&quot;&#125;, &#123;83,&quot;lily&quot;&#125;, &#123;79,&quot;david&quot;&#125; &#125;;\n    student stu2\\[3] = &#123; 0 &#125;;\n    pstudent stu3\\[3] = &#123; 0 &#125;;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        printf(&quot;Please input score and name for %d\\\\n&quot;, i + 1);\n        scanf_s(&quot;%d%s&quot;, &amp;stu2\\[i].score, stu2\\[i].name, 16);\n    &#125;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        stu3\\[i] = &amp;stu1\\[i];\n    &#125;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        printf(&quot;stu1:%d:score:%d,name:%s\\\\n&quot;, i, stu1\\[i].score,\n            stu1\\[i].name);\n    &#125;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        printf(&quot;stu2:%d:score:%d,name:%s\\\\n&quot;, i, stu2\\[i].score,\n            stu2\\[i].name);\n    &#125;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        printf(&quot;stu3:%d:score:%d,name:%s\\\\n&quot;,i,stu3\\[i]-&gt;score,\n            stu3\\[i]-&gt;name);\n    &#125;\n    return 0;\n&#125;\n\n结构体做参数传指针传值判断两个同学的成绩\n\\#include &lt;stdio.h&gt;\n\\#include &lt;string.h&gt;\n\\#include &lt;stdlib.h&gt;\n\ntypedef struct \\_student\n&#123;\n    int score;\n    char name\\[16];\n\n&#125;student,\\*pstudent;\n \nint compare_student_score1(student s1, student s2)\n&#123;\n    return s1.score - s2.score;\n&#125;\n\nint compare_student_score2(student\\* s1, student\\* s2)\n&#123;\n    return s1-&gt;score - s2-&gt;score;\n&#125;\n\nint main() \n&#123;\n    student stu1\\[3] = &#123; &#123;78,&quot;tom&quot;&#125;, &#123;83,&quot;lily&quot;&#125;, &#123;79,&quot;david&quot;&#125; &#125;;\n    student stu2\\[3] = &#123; 0 &#125;;\n    pstudent stu3\\[3] = &#123; 0 &#125;;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        printf(&quot;Please input score and name for %d\\\\n&quot;, i + 1);\n        scanf_s(&quot;%d%s&quot;, &amp;stu2\\[i].score, stu2\\[i].name, 16);\n    &#125;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        stu3\\[i] = &amp;stu1\\[i];\n    &#125;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        printf(&quot;stu1:%d:score:%d,name:%s\\\\n&quot;, i, stu1\\[i].score,\n            stu1\\[i].name);\n    &#125;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        printf(&quot;stu2:%d:score:%d,name:%s\\\\n&quot;, i, stu2\\[i].score,\n            stu2\\[i].name);\n    &#125;\n    for (int i = 0; i &lt; 3; i++)\n    &#123;\n        printf(&quot;stu3:%d:score:%d,name:%s\\\\n&quot;,i,stu3\\[i]-&gt;score,\n            stu3\\[i]-&gt;name);\n    &#125;\n    \n\\\tstudent s3 = &#123; 85,&quot;a&quot; &#125;;\n    student s4 = &#123; 91,&quot;b&quot; &#125;;\n    int res = compare_student_score1(s3,s4);\n    if (res == 0)\n    &#123;\n        printf(&quot;the score of %s equals the score of %s\\\\n&quot;,\n            s3.name,s4.name);\n    &#125;\n    else if (res &gt; 0)\n    &#123;\n        printf(&quot;the score of %s above the score of %s\\\\n&quot;,\n            s3.name, s4.name);\n    &#125;\n    else\n    &#123;\n        printf(&quot;the score of %s below the score of %s\\\\n&quot;,\n            s3.name, s4.name);\n    &#125;\n\n\\    return 0;\n&#125;\n\n"},{"title":"使用sizeof计算结构体长度","url":"/2023/10/29/%E4%BD%BF%E7%94%A8sizeof%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E9%95%BF%E5%BA%A6/","content":"结构体的自然对齐\n#pragma pack(n)#pragma pack(push)&#x2F;&#x2F;#pragma pack(n)&#x2F;&#x2F;#pragma pack(pop)&#x2F;&#x2F;\n#pragma pack(n)来设定变量n字节对齐方式.这种对齐应该遵守如下两条对齐规则.1)数据成员对齐规则:n字节对齐就是说变量存放的起始地址的偏移量:min(sizeof(基本类型),n)或其倍数.2)整体对齐规则:结构的总大小也有个约束条件:min(最大的sizeof(基本类型),n)的倍数.\n也就是说:第一,如果n大于等于该变量所占用的字节数,那么偏移量必须满足默认的对齐方式:如果n小于该变量的类型所占用的字节数,那么偏移量为n的倍数,不用满足默认的对齐方式.第二,结构的总大小也有个约束条件,分下面的两种情况:如果n大于所有成员变量的所占类型所占的字节数,那么结构的总大小必须为占用空间最大的变量占有的空间数的倍数:否则必须为n的倍数.\n例如:#pragma pack(8)struct s1{    short a;    long b;};struct s2{    char c;    s1 d;    long long 3;};struct s3{    char c;    short a;    long b;    long long e;};#pragma pack()1,sizeof(s1)&#x3D;?sizeof(s2)&#x3D;?sizeof(s3)&#x3D;?2,s2的c后面空了几个字节接着d?\n栈空间的对齐栈形参部分:按4字节(x86)或8字节(x64)对齐\n局部变量区间:变量位置可能改变,char对齐到一个字节, short2个字节.\n"},{"title":"union","url":"/2023/10/29/%E8%81%94%E5%90%88%E4%BD%93/","content":"联合体(UNION)定义:C语言编程的时候,需要使几种不同类型的变量存放到同一段内存单元中.也就是使用覆盖技术,几个变量互相覆盖重叠,这种几个不同的变量共同占用一段内存的结构,在C语言中,被称为联合体(union),也被称为共用体.\nunion foo{\\\tchar s[10];\\\tint i;}a,b;\nunion foo{\\\tchar s[10];\\\tint i;};union foo s;\ntypedef union{\\\tchar s[10];\\    int i;}foo;foo a;\ntypedef union _foo{\\\tchar s[10];\\\tint i;}foo,*pfoo;foo a;\n结构体与联合体的区别1,联合体和结构体都是由多个不同的数据类型成员组成的,但在任何同一时刻,共用体只存放了一个被选中的成员而结构体的所有成员都存在.2,对于联合体的不同成员赋值,将会对其他成员重写,原来的成员的值就不存在了,而对于结构体的不同成员赋值是互不影响的.3,结构体里可以含有union的成员,union里也可以含结构体成员.结构体:先存放数据成员;联合体:并排存放数据成员.\n"},{"title":"关于我使用VScode那些事","url":"/2023/10/30/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8VScode%E9%82%A3%E4%BA%9B%E4%BA%8B/","content":"文件带空格无法运行在code running这个插件中,如果遇到文件名带空格无法运行调试时,我们可以打开code running的拓展设置找到Executor Map,之后在settings.js中打开把cpp: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, 改为&quot;cd $dir &amp;&amp; g++ \\&quot;$fileName\\&quot; -o \\&quot;$fileNameWithoutExt.exe\\&quot; &amp;&amp; &amp; \\&quot;.\\\\$fileNameWithoutExt.exe\\&quot;&quot;, .\n文件名是中文无法调试我们可以通过电脑的设置找到更改地区和时间,再找到管理语言设置,之后选择更改系统设置,勾选beta版使用unicode UTF-8提供全球语言支持.\n关于使用字体用Ctrl+逗号进入设置输入font在这里能找到字体大小和字体个性化设置(推荐用Hack).\n关于调试VScode需要在内部下载微软C&#x2F;C++三件套,再配合MinGW配置语言环境进行调试.在MinGW中,点击Basic Setup需要勾选mingw-developer-yoolkit,mingw32-base,mingw32-gcc-g++,mingw32-gcc-objc,msys-base.之后点击左上角的Installation之后点击Updata Catalogue下载.\n"},{"title":"实用软件集合","url":"/2023/10/30/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%9B%86%E5%90%88/","content":"黑曜石文档Z-library电脑阅读exe硬盘检测C语言环境下载MinGW7z解压阅读appONLYOFFICE开源办公VM虚拟机的一个许可证MC60H-DWHD5-H80U9-6V85M-8280D(网上都能找到).\n"}]